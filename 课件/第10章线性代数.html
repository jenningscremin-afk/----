<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>第十章：线性代数基础 (交互式课件)</title>
<script src="../common-assets/js/d3-7.8.5.min.js"></script>
<!-- 使用统一的MathJax配置文件 -->
<script src="../common-assets/js/mathjax-config.js"></script>
<script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready!');
                    });
                }
            }
        };
    </script>
<script async="" id="MathJax-script" src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js" type="text/javascript">
</script>
<style>
        :root {
            --page-bg: #f0f4f8;
            --card-bg: #ffffff;
            --text-color: #1f2937;
            --primary-color: #2563eb;
            --accent-color: #f97316;
            --muted-color: #64748b;
            --axis-color: #475569;
            --border-color: #e2e8f0;
            --code-bg: #f8fafc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            background: var(--page-bg);
            color: var(--text-color);
            overflow: hidden;
        }

        .slide {
            display: none;
            animation: fadeIn 0.6s ease-in-out;
        }

        .slide.active {
            display: block;
        }

        .slide-container {
            width: 100%;
            height: 100vh;
            display: flex;
            position: relative;
        }

        .slide-container.single-column {
            justify-content: center;
        }

        .left-content {
            width: 50%;
            height: 100vh;
            padding: 48px 56px;
            background: var(--card-bg);
            overflow-y: auto;
            font-size: 17px;
            line-height: 1.9;
            color: var(--text-color);
            border-right: 1px solid var(--border-color);
        }

        .slide-container.single-column .left-content {
            width: 100%;
            max-width: 960px;
            border-right: none;
        }

        .left-content h2 {
            font-size: 2.4rem;
            margin-bottom: 1.2rem;
            color: var(--primary-color);
        }

        .left-content h3 {
            font-size: 1.6rem;
            margin: 1.2rem 0 0.6rem;
            color: var(--axis-color);
        }

        .left-content p {
            margin-bottom: 1rem;
        }

        .left-content ul,
        .left-content ol {
            margin: 1rem 0 1rem 1.25rem;
        }

        .left-content li {
            margin-bottom: 0.6rem;
        }

        .math-formula {
            background: var(--code-bg);
            border-left: 4px solid var(--primary-color);
            padding: 14px 18px;
            margin: 1.2rem 0;
            border-radius: 10px;
            font-size: 1.05rem;
        }

        .highlight {
            color: var(--primary-color);
            font-weight: 600;
        }

        .right-visual {
            width: 50%;
            height: 100vh;
            background: var(--code-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: 1px solid var(--border-color);
            padding: 32px;
        }

        .slide-container.single-column .right-visual {
            display: none;
        }

        .right-visual > div {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--card-bg);
            border-radius: 24px;
            box-shadow: 0 24px 60px rgba(15, 23, 42, 0.12);
            padding: 24px;
        }

        .right-visual > div > * {
            width: 100%;
            height: 100%;
        }

        .right-visual canvas,
        .right-visual svg {
            max-width: 100%;
            max-height: 100%;
        }

        .right-visual svg text {
            fill: var(--text-color);
        }

        .right-visual svg .domain,
        .right-visual svg .tick line {
            stroke: var(--axis-color);
        }

        .nav-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
            backdrop-filter: blur(12px);
            z-index: 1100;
        }

        .nav-btn {
            border: none;
            background: var(--primary-color);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 999px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(37, 99, 235, 0.25);
        }

        .nav-btn:disabled {
            background: #e2e8f0;
            color: var(--muted-color);
            cursor: not-allowed;
            box-shadow: none;
        }

        #page-indicator {
            font-size: 0.95rem;
            color: var(--axis-color);
            min-width: 80px;
            text-align: center;
            font-weight: 600;
        }

        .directory-toggle {
            border: none;
            background: var(--card-bg);
            color: var(--axis-color);
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(15, 23, 42, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .directory-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.12);
        }

        .directory-menu {
            position: fixed;
            bottom: 90px;
            right: 24px;
            width: 320px;
            max-height: 60vh;
            overflow-y: auto;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.18);
            display: none;
            z-index: 1200;
        }

        .directory-menu.active {
            display: block;
        }

        .directory-menu h3 {
            margin-bottom: 16px;
            font-size: 1.1rem;
            color: var(--axis-color);
        }

        .directory-item {
            margin-bottom: 12px;
            color: var(--text-color);
            text-decoration: none;
            display: block;
            padding: 10px 12px;
            border-radius: 12px;
            transition: background 0.2s ease;
        }

        .directory-item:hover {
            background: rgba(37, 99, 235, 0.08);
        }

        .global-animation-controls {
            position: fixed;
            bottom: 24px;
            left: 24px;
            display: flex;
            gap: 12px;
            padding: 12px 18px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
            backdrop-filter: blur(12px);
            z-index: 1100;
        }

        .global-control-btn {
            background: transparent;
            border: none;
            color: var(--axis-color);
            padding: 6px 12px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: color 0.2s ease;
        }

        .global-control-btn:hover {
            color: var(--primary-color);
        }

        .global-control-btn.pause {
            color: #dc2626;
        }

        .slide-note {
            font-size: 0.95rem;
            color: var(--muted-color);
            margin-top: 12px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 1200px) {
            .slide-container {
                flex-direction: column;
            }

            .left-content,
            .right-visual {
                width: 100%;
                height: auto;
                min-height: 50vh;
            }

            .right-visual {
                border-left: none;
                border-top: 1px solid var(--border-color);
            }
        }

        @media print {
            body {
                overflow: visible;
            }
            .slide {
                display: block !important;
                page-break-after: always;
            }
            .nav-container,
            .global-animation-controls,
            .directory-menu,
            .directory-toggle {
                display: none !important;
            }
        }
    </style>
<link href="../common-assets/css/chapter-light-overrides.css" rel="stylesheet"/>
<style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
<div id="slidesContainer">
<!-- 第1页：标题页 -->
<div class="slide active"><div class="slide-container single-column"><div class="left-content tex2jax_process">
<h2 style="font-size: 4rem">第十章</h2>
<p style="font-size: 2.5rem; color: var(--text-color)">线性代数基础</p>
<div style="margin-top: 50px; font-size: 1.2rem">
<p>适合高职学生的实用教程</p>
<ul style="text-align: left; margin: 30px auto; max-width: 400px">
<li>矩阵：数字的表格</li>
<li>行列式：矩阵的特征值</li>
<li>向量：有方向的量</li>
<li>线性方程组：多元一次方程</li>
<li>特征值：矩阵的"基因"</li>
</ul>
<p style="margin-top: 30px; font-size: 1rem">
                    💡 提示：本章内容循序渐进，从生活实例开始
                </p>
</div>
</div></div></div>
<!-- 第2页：什么是矩阵 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>什么是矩阵？</h2>
<p>想象一个 <span class="highlight">班级成绩表</span>：</p>
<ul>
<li>横向：不同科目</li>
<li>纵向：不同学生</li>
<li>交叉点：具体成绩</li>
</ul>
<p>这就是矩阵！一个有序的数字表格。</p>
<h3>生活中的矩阵</h3>
<p>• <strong>Excel表格</strong>：最常见的矩阵</p>
<p>• <strong>座位表</strong>：行×列的矩阵</p>
<p>• <strong>像素图片</strong>：RGB颜色矩阵</p>
<div class="math-formula">
                学生成绩矩阵 = $\begin{pmatrix}
                85 &amp; 92 &amp; 78 \\
                90 &amp; 88 &amp; 95 \\
                76 &amp; 84 &amp; 89
                \end{pmatrix}$
            </div>
<p style="text-align: center">3个学生 × 3门课程</p>
</div><div class="right-visual"><div id="vis-matrix-intro"></div></div></div></div>
<!-- 第3页：矩阵加法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>矩阵加法</h2>
<p>就像 <span class="highlight">两个班级成绩相加</span>！</p>
<h3>加法规则</h3>
<p>• 矩阵大小必须相同</p>
<p>• 对应位置的数字相加</p>
<p>• 就像Excel中的单元格相加</p>
<div class="math-formula">
                $\begin{pmatrix}
                1 &amp; 2 \\
                3 &amp; 4
                \end{pmatrix} + \begin{pmatrix}
                5 &amp; 6 \\
                7 &amp; 8
                \end{pmatrix} = \begin{pmatrix}
                6 &amp; 8 \\
                10 &amp; 12
                \end{pmatrix}$
            </div>
<h3>实际应用</h3>
<p>两个月的销售额相加：</p>
<p>1月销售 + 2月销售 = 两月总销售</p>
</div><div class="right-visual"><div id="vis-matrix-addition"></div></div></div></div>
<!-- 第4页：矩阵乘法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>矩阵乘法</h2>
<p>像 <span class="highlight">价格×数量=总价</span></p>
<h3>乘法步骤</h3>
<p>1. 第一个矩阵的<span class="highlight">行</span></p>
<p>2. 乘以第二个矩阵的<span class="highlight">列</span></p>
<p>3. 对应元素相乘后相加</p>
<h3>记忆口诀</h3>
<p style="padding: 10px">
                "横着走，竖着算"<br/>
                左手指行，右手指列
            </p>
<h3>实例：购物计算</h3>
<p>商品单价 × 购买数量 = 总价</p>
<div class="math-formula">
                $\begin{pmatrix}
                苹果: 5元 \\
                香蕉: 3元
                \end{pmatrix} × \begin{pmatrix}
                买2斤 \\
                买3斤
                \end{pmatrix} = 19元$
            </div>
</div><div class="right-visual"><div id="vis-matrix-multiplication"></div></div></div></div>
<!-- 第5页：行列式入门 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>行列式</h2>
<p>矩阵的"指纹" - <span class="highlight">一个数值</span></p>
<h3>2×2行列式</h3>
<div class="math-formula">
                $\begin{vmatrix}
                a &amp; b \\
                c &amp; d
                \end{vmatrix} = ad - bc$
            </div>
<h3>记忆方法</h3>
<p style="padding: 10px">
                主对角线（↘）相乘 <span class="highlight">减去</span><br/>
                副对角线（↙）相乘
            </p>
<h3>几何意义</h3>
<p>• 2×2行列式 = 平行四边形<span class="highlight">面积</span></p>
<p>• 行列式为0 = 图形被"压扁"了</p>
<h3>用途</h3>
<p>判断方程组是否有唯一解：</p>
<p>行列式 ≠ 0 → 有唯一解 ✓</p>
<p>行列式 = 0 → 无解或无穷解 ✗</p>
</div><div class="right-visual"><div id="vis-determinant"></div></div></div></div>
<!-- 第6页：向量基础 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>向量</h2>
<p>不只有大小，还有<span class="highlight">方向</span>的量</p>
<h3>生活中的向量</h3>
<p>• <strong>导航</strong>：往东走3公里</p>
<p>• <strong>风速</strong>：西北风5级</p>
<p>• <strong>力</strong>：向上提10公斤</p>
<h3>向量表示</h3>
<div class="math-formula">
                $\vec{v} = (x, y) = (3, 4)$<br/>
                表示：向右3，向上4
            </div>
<h3>向量长度</h3>
<p>用勾股定理计算：</p>
<div class="math-formula">
                $|\vec{v}| = \sqrt{3^2 + 4^2} = 5$
            </div>
<h3>向量运算</h3>
<p>• <strong>加法</strong>：首尾相接</p>
<p>• <strong>数乘</strong>：改变长度</p>
</div><div class="right-visual"><div id="vis-vector"></div></div></div></div>
<!-- 第7页：线性方程组 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>线性方程组</h2>
<p>多个未知数的<span class="highlight">联立方程</span></p>
<h3>实例：购物问题</h3>
<p>买了苹果和香蕉：</p>
<div class="math-formula">
                $\begin{cases}
                2x + 3y = 16 \text{ (总价)} \\
                x + y = 6 \text{ (总数量)}
                \end{cases}$
            </div>
<p>x = 苹果数量，y = 香蕉数量</p>
<h3>求解方法</h3>
<p>1. <strong>消元法</strong>：逐个消除未知数</p>
<p>2. <strong>代入法</strong>：用一个表示另一个</p>
<p>3. <strong>矩阵法</strong>：转化为矩阵运算</p>
<h3>几何理解</h3>
<p>• 每个方程是一条直线</p>
<p>• 解是直线的<span class="highlight">交点</span></p>
<p>• 无交点 = 无解</p>
<p>• 重合 = 无穷多解</p>
</div><div class="right-visual"><div id="vis-linear-system"></div></div></div></div>
<!-- 第8页：克拉默法则 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>克拉默法则</h2>
<p>用<span class="highlight">行列式</span>解方程组</p>
<h3>公式</h3>
<div class="math-formula">
                $x = \frac{D_x}{D}, \quad y = \frac{D_y}{D}$
            </div>
<h3>步骤</h3>
<p>1. 算系数行列式 D</p>
<p>2. 用常数项替换第1列，算 D_x</p>
<p>3. 用常数项替换第2列，算 D_y</p>
<p>4. 相除得答案</p>
<h3>实例计算</h3>
<div style="padding: 10px">
                方程组：2x + y = 5<br/>
                　　　　x - y = 1<br/>
<br/>
                D = 2×(-1) - 1×1 = -3<br/>
                D_x = 5×(-1) - 1×1 = -6<br/>
                x = -6/(-3) = 2 ✓
            </div>
<p style="margin-top: 15px">
                💡 适用条件：D ≠ 0
            </p>
</div><div class="right-visual"><div id="vis-cramers"></div></div></div></div>
<!-- 第9页：特征值特征向量 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>特征值与特征向量</h2>
<p>矩阵的<span class="highlight">"个性特征"</span></p>
<h3>直观理解</h3>
<p>矩阵变换某些特殊向量时：</p>
<p>• 只改变<span class="highlight">长度</span></p>
<p>• 不改变<span class="highlight">方向</span></p>
<div class="math-formula">
                $A\vec{v} = \lambda\vec{v}$<br/>
                矩阵×特征向量 = 数值×特征向量
            </div>
<h3>实际意义</h3>
<p>• <strong>振动分析</strong>：找到共振频率</p>
<p>• <strong>人脸识别</strong>：提取面部特征</p>
<p>• <strong>数据压缩</strong>：保留主要信息</p>
<h3>计算步骤</h3>
<p>1. 解特征方程：|A - λI| = 0</p>
<p>2. 得到特征值 λ</p>
<p>3. 代入求特征向量</p>
<p style="padding: 10px">
                类比：DNA是人的特征<br/>
                特征值是矩阵的"DNA"
            </p>
</div><div class="right-visual"><div id="vis-eigenvalue"></div></div></div></div>
<!-- 第10页：应用实例 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>实际应用案例</h2>
<h3>1. 图像处理</h3>
<p>• 图片 = RGB三个矩阵</p>
<p>• 滤镜 = 矩阵运算</p>
<p>• 旋转 = 旋转矩阵</p>
<h3>2. 经济分析</h3>
<p>• 投入产出表 = 矩阵</p>
<p>• 供需平衡 = 线性方程组</p>
<h3>3. 工程计算</h3>
<p>• 电路分析：节点电压法</p>
<p>• 结构分析：受力平衡</p>
<h3>4. 数据科学</h3>
<p>• 推荐系统：用户-物品矩阵</p>
<p>• 机器学习：特征提取</p>
<div style="padding: 15px; margin-top: 20px">
<strong>记住：</strong><br/>
                线性代数 = 处理多维数据的工具<br/>
                掌握它，就掌握了数据分析的钥匙！
            </div>
</div><div class="right-visual"><div id="vis-applications"></div></div></div></div>
<!-- 第11页：总结 -->
<div class="slide"><div class="slide-container single-column"><div class="left-content tex2jax_process">
<h2>课程总结</h2>
<div style="text-align: left; max-width: 600px; margin: 0 auto">
<h3>✓ 已掌握</h3>
<ul>
<li>矩阵：数字表格的运算</li>
<li>行列式：判断解的存在性</li>
<li>向量：有方向的量</li>
<li>线性方程组：多元方程求解</li>
<li>特征值：矩阵的本质特征</li>
</ul>
<h3 style="margin-top: 30px">🎯 应用场景</h3>
<ul>
<li>Excel数据处理</li>
<li>图像编辑软件</li>
<li>经济数据分析</li>
<li>工程计算</li>
</ul>
<h3 style="margin-top: 30px">💡 学习建议</h3>
<p>1. 多做实际应用题</p>
<p>2. 用Excel练习矩阵运算</p>
<p>3. 结合专业课程使用</p>
</div>
<div style="margin-top: 40px; font-size: 2rem">
                继续加油！💪
            </div>
</div></div></div>
<!-- 导航按钮 -->
<!-- 页面指示器 -->
<!-- 全局动画控制面板 -->
<div class="nav-container">
<button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">上一页</button>
<span id="page-indicator">1 / 10</span>
<button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">下一页</button>
</div>
<div class="global-animation-controls" id="globalAnimationControls">
<button class="global-control-btn" id="globalPlayPauseBtn">暂停</button>
<button class="global-control-btn" id="globalSpeedBtn">1.0x</button>
</div>
</div>
<!-- 浮动菜单按钮 -->
<div id="floating-menu">
<div class="menu-toggle" id="menu-toggle">
<span class="menu-icon">☰</span>
</div>
<div class="menu-content" id="menu-content">
<a class="menu-item" href="#" onclick="showExample('matrix')">
<span class="menu-icon">📊</span>
<span class="menu-text">矩阵计算器</span>
</a>
<a class="menu-item" href="#" onclick="showExample('determinant')">
<span class="menu-icon">🔢</span>
<span class="menu-text">行列式求解器</span>
</a>
<a class="menu-item" href="#" onclick="showExample('vector')">
<span class="menu-icon">➡️</span>
<span class="menu-text">向量可视化</span>
</a>
<a class="menu-item" href="#" onclick="showExample('equation')">
<span class="menu-icon">📐</span>
<span class="menu-text">方程组求解</span>
</a>
<a class="menu-item" href="#" onclick="downloadNotes()">
<span class="menu-icon">📝</span>
<span class="menu-text">下载笔记</span>
</a>
</div>
</div>
<script>
    let slides, totalSlides, counter, currentSlide = 0;
    let globalAnimationPlaying = true;
    let globalAnimationSpeed = 1.0;
    let currentAnimation = null;

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        counter = document.getElementById('page-indicator');

        showSlide(0);
        initGlobalAnimationControls();
        initFloatingMenu();

        // 键盘导航
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                previousSlide();
            }
        });

        // 鼠标滚轮导航
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY > 0) {
                nextSlide();
            } else {
                previousSlide();
            }
        }, { passive: false });
    });

    // 显示幻灯片
    function showSlide(index) {
        if (index < 0 || index >= totalSlides) return;

        slides.forEach(slide => slide.classList.remove('active'));
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        counter.textContent = `${currentSlide + 1} / ${totalSlides}`;

        updateNavButtons();
        runVisualization(currentSlide);
        
        // 渲染数学公式
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([slides[currentSlide]]).catch(() => {});
        }
    }

    function nextSlide() {
        if (currentSlide < totalSlides - 1) {
            showSlide(currentSlide + 1);
        }
    }

    function previousSlide() {
        if (currentSlide > 0) {
            showSlide(currentSlide - 1);
        }
    }

    function updateNavButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        prevBtn.disabled = (currentSlide === 0);
        nextBtn.disabled = (currentSlide === totalSlides - 1);
    }

    // 全局动画控制
    function initGlobalAnimationControls() {
        const playPauseBtn = document.getElementById('globalPlayPauseBtn');
        const speedBtn = document.getElementById('globalSpeedBtn');

        const speedOptions = [0.5, 1, 1.5, 2, 3];
        let currentSpeedIndex = 1;

        playPauseBtn.addEventListener('click', () => {
            globalAnimationPlaying = !globalAnimationPlaying;
            playPauseBtn.textContent = globalAnimationPlaying ? '暂停' : '播放';
            playPauseBtn.className = globalAnimationPlaying ? 'global-control-btn' : 'global-control-btn pause';
        });

        speedBtn.addEventListener('click', () => {
            currentSpeedIndex = (currentSpeedIndex + 1) % speedOptions.length;
            globalAnimationSpeed = speedOptions[currentSpeedIndex];
            speedBtn.textContent = globalAnimationSpeed.toFixed(1) + 'x';
        });
    }

    // 浮动菜单
    function initFloatingMenu() {
        const menuToggle = document.getElementById('menu-toggle');
        const menuContent = document.getElementById('menu-content');
        
        if (menuToggle && menuContent) {
            menuToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                menuToggle.classList.toggle('active');
                menuContent.classList.toggle('active');
            });
            
            document.addEventListener('click', function(e) {
                if (!menuToggle.contains(e.target) && !menuContent.contains(e.target)) {
                    menuToggle.classList.remove('active');
                    menuContent.classList.remove('active');
                }
            });
        }
    }

    // D3.js工具函数
    
    const rootStyles = getComputedStyle(document.documentElement);
    const themeColors = {
        text: rootStyles.getPropertyValue('--text-color').trim() || '#34495e',
        axis: rootStyles.getPropertyValue('--axis-color').trim() || '#475569',
        muted: rootStyles.getPropertyValue('--muted-color').trim() || '#94a3b8',
        surface: rootStyles.getPropertyValue('--card-bg').trim() || '#ffffff'
    };

function setupD3(containerId, margins = {top: 40, right: 40, bottom: 40, left: 40}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) return null;
        
        container.html('');
        const bounds = container.node().getBoundingClientRect();
        
        const svg = container.append('svg')
            .attr('width', bounds.width)
            .attr('height', bounds.height);
        
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margins.left}, ${margins.top})`);
        
        return { container, svg, g, width, height };
    }

    // 可视化函数
    function runVisualization(slideIndex) {
        // 清理之前的动画
        if (currentAnimation) {
            if (typeof currentAnimation === 'function') {
                currentAnimation();
            } else if (currentAnimation.stop) {
                currentAnimation.stop();
            }
        }

        switch(slideIndex) {
            case 1: visualizeMatrixIntro(); break;
            case 2: visualizeMatrixAddition(); break;
            case 3: visualizeMatrixMultiplication(); break;
            case 4: visualizeDeterminant(); break;
            case 5: visualizeVector(); break;
            case 6: visualizeLinearSystem(); break;
            case 7: visualizeCramersRule(); break;
            case 8: visualizeEigenvalue(); break;
            case 9: visualizeApplications(); break;
        }
    }

    // 矩阵介绍可视化
    function visualizeMatrixIntro() {
        const container = document.getElementById('vis-matrix-intro');
        if (!container) return;
        
        container.innerHTML = `
            <div class="vis-container">
                <h3 style="color: ${themeColors.text}; margin-bottom: 30px;">班级成绩矩阵 - 动态演示</h3>
                <div class="matrix-container">
                    <div class="matrix-wrapper">
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px;">
                            <div style="color: var(--warning-color); font-weight: bold;">学生/科目</div>
                            <div style="color: var(--warning-color);">语文</div>
                            <div style="color: var(--warning-color);">数学</div>
                            <div style="color: var(--warning-color);">英语</div>
                            <div style="color: var(--info-color);">张三</div>
                            <div class="matrix-cell" id="m11">85</div>
                            <div class="matrix-cell" id="m12">92</div>
                            <div class="matrix-cell" id="m13">78</div>
                            <div style="color: var(--info-color);">李四</div>
                            <div class="matrix-cell" id="m21">90</div>
                            <div class="matrix-cell" id="m22">88</div>
                            <div class="matrix-cell" id="m23">95</div>
                            <div style="color: var(--info-color);">王五</div>
                            <div class="matrix-cell" id="m31">76</div>
                            <div class="matrix-cell" id="m32">84</div>
                            <div class="matrix-cell" id="m33">89</div>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 30px; color: ${themeColors.text};">
                    <p id="matrix-info" style="font-size: 1.2rem; text-align: center;">
                        点击任意成绩查看详情
                    </p>
                </div>
            </div>
        `;

        // 添加交互
        const cells = document.querySelectorAll('.matrix-cell');
        cells.forEach(cell => {
            cell.addEventListener('click', function() {
                const value = this.textContent;
                const id = this.id;
                const row = id[1];
                const col = id[2];
                const students = ['张三', '李四', '王五'];
                const subjects = ['语文', '数学', '英语'];
                
                document.getElementById('matrix-info').innerHTML = `
                    <strong>${students[row-1]}</strong>的<strong>${subjects[col-1]}</strong>成绩是
                    <span style="color: var(--success-color); font-size: 1.5rem;">${value}分</span>
                `;
                
                // 高亮效果
                cells.forEach(c => c.classList.remove('highlight'));
                this.classList.add('highlight');
            });
        });

        // 自动演示
        let index = 0;
        const autoDemo = setInterval(() => {
            if (!globalAnimationPlaying) return;
            
            cells[index].click();
            index = (index + 1) % cells.length;
        }, 2000 / globalAnimationSpeed);

        currentAnimation = () => clearInterval(autoDemo);
    }

    // 矩阵加法可视化
    function visualizeMatrixAddition() {
        const container = document.getElementById('vis-matrix-addition');
        if (!container) return;
        
        container.innerHTML = `
            <div class="vis-container">
                <h3 style="color: ${themeColors.text}; margin-bottom: 30px;">矩阵加法动画演示</h3>
                <div class="matrix-container">
                    <div class="matrix-wrapper">
                        <div class="matrix-grid" style="grid-template-columns: repeat(2, 1fr);">
                            <div class="matrix-cell">2</div>
                            <div class="matrix-cell">3</div>
                            <div class="matrix-cell">1</div>
                            <div class="matrix-cell">4</div>
                        </div>
                    </div>
                    <div style="font-size: 2rem; color: ${themeColors.text};">+</div>
                    <div class="matrix-wrapper">
                        <div class="matrix-grid" style="grid-template-columns: repeat(2, 1fr);">
                            <div class="matrix-cell">5</div>
                            <div class="matrix-cell">1</div>
                            <div class="matrix-cell">2</div>
                            <div class="matrix-cell">3</div>
                        </div>
                    </div>
                    <div style="font-size: 2rem; color: ${themeColors.text};">=</div>
                    <div class="matrix-wrapper">
                        <div class="matrix-grid" style="grid-template-columns: repeat(2, 1fr);" id="result-add">
                            <div class="matrix-cell" style="opacity: 0;">7</div>
                            <div class="matrix-cell" style="opacity: 0;">4</div>
                            <div class="matrix-cell" style="opacity: 0;">3</div>
                            <div class="matrix-cell" style="opacity: 0;">7</div>
                        </div>
                    </div>
                </div>
                <div style="margin-top: 30px;">
                    <button onclick="animateAddition()" style="background: var(--primary-color); color: ${themeColors.text}; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">
                        重新演示
                    </button>
                </div>
            </div>
        `;

        // 自动播放加法动画
        setTimeout(() => animateAddition(), 500);
    }

    function animateAddition() {
        const resultCells = document.querySelectorAll('#result-add .matrix-cell');
        resultCells.forEach((cell, i) => {
            setTimeout(() => {
                cell.style.transition = 'all 0.5s ease';
                cell.style.opacity = '1';
                cell.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    cell.style.transform = 'scale(1)';
                }, 300);
            }, i * 200 / globalAnimationSpeed);
        });
    }

    // 矩阵乘法可视化
    function visualizeMatrixMultiplication() {
        const setup = setupD3('vis-matrix-multiplication');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建示例矩阵
        const matrixA = [[1, 2], [3, 4]];
        const matrixB = [[5, 6], [7, 8]];
        const result = [[19, 22], [43, 50]];

        const cellSize = 60;
        const gap = 100;

        // 绘制矩阵A
        const aGroup = g.append('g').attr('transform', `translate(0, ${height/2 - cellSize})`);
        aGroup.append('text')
            .attr('x', cellSize)
            .attr('y', -20)
            .text('A')
            .attr('fill', themeColors.text)
            .attr('font-size', '20px')
            .attr('text-anchor', 'middle');

        matrixA.forEach((row, i) => {
            row.forEach((val, j) => {
                aGroup.append('rect')
                    .attr('x', j * cellSize)
                    .attr('y', i * cellSize)
                    .attr('width', cellSize - 5)
                    .attr('height', cellSize - 5)
                    .attr('fill', 'rgba(52, 152, 219, 0.2)')
                    .attr('stroke', 'var(--primary-color)')
                    .attr('stroke-width', 2)
                    .attr('rx', 5);
                
                aGroup.append('text')
                    .attr('x', j * cellSize + cellSize/2 - 2.5)
                    .attr('y', i * cellSize + cellSize/2 + 5)
                    .text(val)
                    .attr('fill', themeColors.text)
                    .attr('font-size', '18px')
                    .attr('text-anchor', 'middle');
            });
        });

        // 绘制矩阵B
        const bGroup = g.append('g').attr('transform', `translate(${cellSize * 2 + gap}, ${height/2 - cellSize})`);
        bGroup.append('text')
            .attr('x', cellSize)
            .attr('y', -20)
            .text('B')
            .attr('fill', themeColors.text)
            .attr('font-size', '20px')
            .attr('text-anchor', 'middle');

        matrixB.forEach((row, i) => {
            row.forEach((val, j) => {
                bGroup.append('rect')
                    .attr('x', j * cellSize)
                    .attr('y', i * cellSize)
                    .attr('width', cellSize - 5)
                    .attr('height', cellSize - 5)
                    .attr('fill', 'rgba(46, 204, 113, 0.2)')
                    .attr('stroke', 'var(--success-color)')
                    .attr('stroke-width', 2)
                    .attr('rx', 5);
                
                bGroup.append('text')
                    .attr('x', j * cellSize + cellSize/2 - 2.5)
                    .attr('y', i * cellSize + cellSize/2 + 5)
                    .text(val)
                    .attr('fill', themeColors.text)
                    .attr('font-size', '18px')
                    .attr('text-anchor', 'middle');
            });
        });

        // 绘制结果矩阵
        const resultGroup = g.append('g').attr('transform', `translate(${cellSize * 4 + gap * 2 + 50}, ${height/2 - cellSize})`);
        resultGroup.append('text')
            .attr('x', cellSize)
            .attr('y', -20)
            .text('A × B')
            .attr('fill', themeColors.text)
            .attr('font-size', '20px')
            .attr('text-anchor', 'middle');

        result.forEach((row, i) => {
            row.forEach((val, j) => {
                const rect = resultGroup.append('rect')
                    .attr('x', j * cellSize)
                    .attr('y', i * cellSize)
                    .attr('width', cellSize - 5)
                    .attr('height', cellSize - 5)
                    .attr('fill', 'rgba(231, 76, 60, 0.2)')
                    .attr('stroke', 'var(--danger-color)')
                    .attr('stroke-width', 2)
                    .attr('rx', 5)
                    .style('opacity', 0);
                
                const text = resultGroup.append('text')
                    .attr('x', j * cellSize + cellSize/2 - 2.5)
                    .attr('y', i * cellSize + cellSize/2 + 5)
                    .text(val)
                    .attr('fill', themeColors.text)
                    .attr('font-size', '18px')
                    .attr('text-anchor', 'middle')
                    .style('opacity', 0);

                // 动画显示结果
                setTimeout(() => {
                    rect.transition()
                        .duration(500)
                        .style('opacity', 1);
                    text.transition()
                        .duration(500)
                        .style('opacity', 1);
                }, (i * 2 + j) * 500 / globalAnimationSpeed);
            });
        });

        // 添加运算符号
        g.append('text')
            .attr('x', cellSize * 2 + gap/2)
            .attr('y', height/2)
            .text('×')
            .attr('fill', themeColors.text)
            .attr('font-size', '30px')
            .attr('text-anchor', 'middle');

        g.append('text')
            .attr('x', cellSize * 4 + gap * 1.5 + 25)
            .attr('y', height/2)
            .text('=')
            .attr('fill', themeColors.text)
            .attr('font-size', '30px')
            .attr('text-anchor', 'middle');
    }

    // 行列式可视化
    function visualizeDeterminant() {
        const setup = setupD3('vis-determinant');
        if (!setup) return;
        const { g, width, height } = setup;

        // 2x2行列式示例
        const matrix = [[3, 2], [1, 4]];
        const det = 3 * 4 - 2 * 1; // = 10

        const cellSize = 80;
        const cx = width / 2;
        const cy = height / 2;

        // 绘制矩阵
        const matrixGroup = g.append('g')
            .attr('transform', `translate(${cx - cellSize}, ${cy - cellSize})`);

        // 绘制单元格
        matrix.forEach((row, i) => {
            row.forEach((val, j) => {
                matrixGroup.append('rect')
                    .attr('x', j * cellSize)
                    .attr('y', i * cellSize)
                    .attr('width', cellSize - 5)
                    .attr('height', cellSize - 5)
                    .attr('fill', 'rgba(52, 152, 219, 0.2)')
                    .attr('stroke', 'var(--primary-color)')
                    .attr('stroke-width', 2)
                    .attr('rx', 5);
                
                matrixGroup.append('text')
                    .attr('x', j * cellSize + cellSize/2 - 2.5)
                    .attr('y', i * cellSize + cellSize/2 + 8)
                    .text(val)
                    .attr('fill', themeColors.text)
                    .attr('font-size', '24px')
                    .attr('text-anchor', 'middle')
                    .attr('id', `det-${i}-${j}`);
            });
        });

        // 添加对角线动画
        setTimeout(() => {
            // 主对角线
            const mainDiag = matrixGroup.append('line')
                .attr('x1', 10)
                .attr('y1', 10)
                .attr('x2', 10)
                .attr('y2', 10)
                .attr('stroke', 'var(--success-color)')
                .attr('stroke-width', 3)
                .attr('opacity', 0.8);

            mainDiag.transition()
                .duration(1000 / globalAnimationSpeed)
                .attr('x2', cellSize * 2 - 15)
                .attr('y2', cellSize * 2 - 15);

            // 高亮主对角线元素
            d3.select('#det-0-0').transition().duration(500).attr('fill', 'var(--success-color)').attr('font-size', '28px');
            d3.select('#det-1-1').transition().duration(500).attr('fill', 'var(--success-color)').attr('font-size', '28px');
        }, 500);

        setTimeout(() => {
            // 副对角线
            const antiDiag = matrixGroup.append('line')
                .attr('x1', cellSize * 2 - 15)
                .attr('y1', 10)
                .attr('x2', cellSize * 2 - 15)
                .attr('y2', 10)
                .attr('stroke', 'var(--danger-color)')
                .attr('stroke-width', 3)
                .attr('opacity', 0.8);

            antiDiag.transition()
                .duration(1000 / globalAnimationSpeed)
                .attr('x2', 10)
                .attr('y2', cellSize * 2 - 15);

            // 高亮副对角线元素
            d3.select('#det-0-1').transition().duration(500).attr('fill', 'var(--danger-color)').attr('font-size', '28px');
            d3.select('#det-1-0').transition().duration(500).attr('fill', 'var(--danger-color)').attr('font-size', '28px');
        }, 2000 / globalAnimationSpeed);

        // 显示结果
        setTimeout(() => {
            g.append('text')
                .attr('x', cx)
                .attr('y', cy + 120)
                .text(`det = 3×4 - 2×1 = ${det}`)
                .attr('fill', themeColors.text)
                .attr('font-size', '24px')
                .attr('text-anchor', 'middle')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 3500 / globalAnimationSpeed);
    }

    // 向量可视化
    function visualizeVector() {
        const setup = setupD3('vis-vector');
        if (!setup) return;
        const { svg, g, width, height } = setup;

        const cx = width / 2;
        const cy = height / 2;
        const scale = 40;

        // 绘制坐标系
        g.append('line')
            .attr('x1', 0).attr('y1', cy)
            .attr('x2', width).attr('y2', cy)
            .attr('stroke', 'rgba(255,255,255,0.3)')
            .attr('stroke-width', 1);

        g.append('line')
            .attr('x1', cx).attr('y1', 0)
            .attr('x2', cx).attr('y2', height)
            .attr('stroke', 'rgba(255,255,255,0.3)')
            .attr('stroke-width', 1);

        // 添加坐标轴标签
        g.append('text')
            .attr('x', width - 20).attr('y', cy - 10)
            .text('x').attr('fill', themeColors.text).attr('font-size', '16px');

        g.append('text')
            .attr('x', cx + 10).attr('y', 20)
            .text('y').attr('fill', themeColors.text).attr('font-size', '16px');

        // 向量数据
        const vectors = [
            { x: 3, y: 2, color: 'var(--danger-color)', name: 'a' },
            { x: -2, y: 3, color: 'var(--success-color)', name: 'b' },
            { x: 1, y: -2.5, color: 'var(--warning-color)', name: 'c' }
        ];

        // 添加箭头标记
        svg.append('defs').selectAll('marker')
            .data(vectors)
            .enter().append('marker')
            .attr('id', (d, i) => `arrow-${i}`)
            .attr('markerWidth', 10)
            .attr('markerHeight', 10)
            .attr('refX', 8)
            .attr('refY', 3)
            .attr('orient', 'auto')
            .attr('markerUnits', 'strokeWidth')
            .append('path')
            .attr('d', 'M0,0 L0,6 L9,3 z')
            .attr('fill', d => d.color);

        // 绘制向量
        vectors.forEach((v, i) => {
            const endX = cx + v.x * scale;
            const endY = cy - v.y * scale;

            // 向量线
            const line = g.append('line')
                .attr('x1', cx)
                .attr('y1', cy)
                .attr('x2', cx)
                .attr('y2', cy)
                .attr('stroke', v.color)
                .attr('stroke-width', 3)
                .attr('marker-end', `url(#arrow-${i})`);

            // 动画
            line.transition()
                .delay(i * 500 / globalAnimationSpeed)
                .duration(1000 / globalAnimationSpeed)
                .attr('x2', endX)
                .attr('y2', endY);

            // 向量标签
            setTimeout(() => {
                g.append('text')
                    .attr('x', endX + 10)
                    .attr('y', endY - 10)
                    .text(`${v.name} = (${v.x}, ${v.y})`)
                    .attr('fill', v.color)
                    .attr('font-size', '16px')
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, (i * 500 + 1000) / globalAnimationSpeed);
        });

        // 添加向量加法演示
        setTimeout(() => {
            const sum = { x: vectors[0].x + vectors[1].x, y: vectors[0].y + vectors[1].y };
            const sumEndX = cx + sum.x * scale;
            const sumEndY = cy - sum.y * scale;

            // 平移第二个向量到第一个向量末端
            const v1EndX = cx + vectors[0].x * scale;
            const v1EndY = cy - vectors[0].y * scale;

            g.append('line')
                .attr('x1', v1EndX)
                .attr('y1', v1EndY)
                .attr('x2', v1EndX)
                .attr('y2', v1EndY)
                .attr('stroke', vectors[1].color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('opacity', 0.6)
                .transition()
                .duration(1000 / globalAnimationSpeed)
                .attr('x2', sumEndX)
                .attr('y2', sumEndY);

            // 和向量
            g.append('line')
                .attr('x1', cx)
                .attr('y1', cy)
                .attr('x2', cx)
                .attr('y2', cy)
                .attr('stroke', 'var(--info-color)')
                .attr('stroke-width', 3)
                .attr('stroke-dasharray', '10,5')
                .transition()
                .delay(1000 / globalAnimationSpeed)
                .duration(1000 / globalAnimationSpeed)
                .attr('x2', sumEndX)
                .attr('y2', sumEndY);

            // 标签
            g.append('text')
                .attr('x', sumEndX + 10)
                .attr('y', sumEndY + 10)
                .text(`a + b = (${sum.x}, ${sum.y})`)
                .attr('fill', 'var(--info-color)')
                .attr('font-size', '16px')
                .style('opacity', 0)
                .transition()
                .delay(2000 / globalAnimationSpeed)
                .duration(500)
                .style('opacity', 1);
        }, 2000 / globalAnimationSpeed);
    }

    // 线性方程组可视化
    function visualizeLinearSystem() {
        const setup = setupD3('vis-linear-system');
        if (!setup) return;
        const { g, width, height } = setup;

        // 方程组: 2x + y = 6, x - y = 0
        // 解: x = 2, y = 2

        const scale = 40;
        const cx = width / 2;
        const cy = height / 2;

        // 绘制坐标系
        g.append('line')
            .attr('x1', 0).attr('y1', cy)
            .attr('x2', width).attr('y2', cy)
            .attr('stroke', 'rgba(255,255,255,0.3)')
            .attr('stroke-width', 1);

        g.append('line')
            .attr('x1', cx).attr('y1', 0)
            .attr('x2', cx).attr('y2', height)
            .attr('stroke', 'rgba(255,255,255,0.3)')
            .attr('stroke-width', 1);

        // 绘制网格
        for (let i = -5; i <= 5; i++) {
            if (i !== 0) {
                g.append('line')
                    .attr('x1', cx + i * scale).attr('y1', 0)
                    .attr('x2', cx + i * scale).attr('y2', height)
                    .attr('stroke', 'rgba(255,255,255,0.1)')
                    .attr('stroke-width', 0.5);

                g.append('line')
                    .attr('x1', 0).attr('y1', cy - i * scale)
                    .attr('x2', width).attr('y2', cy - i * scale)
                    .attr('stroke', 'rgba(255,255,255,0.1)')
                    .attr('stroke-width', 0.5);
            }
        }

        // 第一条直线: 2x + y = 6 => y = -2x + 6
        const line1Data = [];
        for (let x = -1; x <= 4; x += 0.1) {
            line1Data.push({ x: x, y: -2 * x + 6 });
        }

        const line1 = d3.line()
            .x(d => cx + d.x * scale)
            .y(d => cy - d.y * scale);

        const path1 = g.append('path')
            .datum(line1Data)
            .attr('d', line1)
            .attr('fill', 'none')
            .attr('stroke', 'var(--danger-color)')
            .attr('stroke-width', 3);

        // 第二条直线: x - y = 0 => y = x
        const line2Data = [];
        for (let x = -1; x <= 4; x += 0.1) {
            line2Data.push({ x: x, y: x });
        }

        const line2 = d3.line()
            .x(d => cx + d.x * scale)
            .y(d => cy - d.y * scale);

        const path2 = g.append('path')
            .datum(line2Data)
            .attr('d', line2)
            .attr('fill', 'none')
            .attr('stroke', 'var(--success-color)')
            .attr('stroke-width', 3);

        // 动画绘制
        const totalLength1 = path1.node().getTotalLength();
        const totalLength2 = path2.node().getTotalLength();

        path1.attr('stroke-dasharray', totalLength1)
            .attr('stroke-dashoffset', totalLength1)
            .transition()
            .duration(2000 / globalAnimationSpeed)
            .attr('stroke-dashoffset', 0);

        path2.attr('stroke-dasharray', totalLength2)
            .attr('stroke-dashoffset', totalLength2)
            .transition()
            .delay(1000 / globalAnimationSpeed)
            .duration(2000 / globalAnimationSpeed)
            .attr('stroke-dashoffset', 0);

        // 标记交点
        setTimeout(() => {
            const intersectX = cx + 2 * scale;
            const intersectY = cy - 2 * scale;

            g.append('circle')
                .attr('cx', intersectX)
                .attr('cy', intersectY)
                .attr('r', 0)
                .attr('fill', 'var(--warning-color)')
                .attr('stroke', themeColors.axis)
                .attr('stroke-width', 2)
                .transition()
                .duration(500)
                .attr('r', 8);

            g.append('text')
                .attr('x', intersectX + 15)
                .attr('y', intersectY - 15)
                .text('解: (2, 2)')
                .attr('fill', 'var(--warning-color)')
                .attr('font-size', '18px')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 3500 / globalAnimationSpeed);

        // 添加方程标签
        g.append('text')
            .attr('x', cx + 3 * scale)
            .attr('y', cy - 0 * scale)
            .text('2x + y = 6')
            .attr('fill', 'var(--danger-color)')
            .attr('font-size', '14px')
            .style('opacity', 0)
            .transition()
            .delay(2000 / globalAnimationSpeed)
            .duration(500)
            .style('opacity', 1);

        g.append('text')
            .attr('x', cx + 3.5 * scale)
            .attr('y', cy - 3.5 * scale)
            .text('x - y = 0')
            .attr('fill', 'var(--success-color)')
            .attr('font-size', '14px')
            .style('opacity', 0)
            .transition()
            .delay(3000 / globalAnimationSpeed)
            .duration(500)
            .style('opacity', 1);
    }

    // 克拉默法则可视化
    function visualizeCramersRule() {
        const container = document.getElementById('vis-cramers');
        if (!container) return;
        
        container.innerHTML = `
            <div class="vis-container">
                <h3 style="color: ${themeColors.text}; margin-bottom: 20px;">克拉默法则计算演示</h3>
                <div style="color: ${themeColors.text}; text-align: center;">
                    <p style="font-size: 1.2rem;">方程组：2x + y = 5, x - y = 1</p>
                    
                    <div style="display: flex; justify-content: center; gap: 30px; margin: 30px 0;">
                        <div class="matrix-wrapper">
                            <p>系数行列式 D</p>
                            <div class="matrix-grid" style="grid-template-columns: repeat(2, 1fr);">
                                <div class="matrix-cell">2</div>
                                <div class="matrix-cell">1</div>
                                <div class="matrix-cell">1</div>
                                <div class="matrix-cell">-1</div>
                            </div>
                            <p id="det-d" style="margin-top: 10px; opacity: 0;">= 2×(-1) - 1×1 = -3</p>
                        </div>
                        
                        <div class="matrix-wrapper">
                            <p>D_x (第1列替换)</p>
                            <div class="matrix-grid" style="grid-template-columns: repeat(2, 1fr);">
                                <div class="matrix-cell" style="background: var(--warning-color);">5</div>
                                <div class="matrix-cell">1</div>
                                <div class="matrix-cell" style="background: var(--warning-color);">1</div>
                                <div class="matrix-cell">-1</div>
                            </div>
                            <p id="det-dx" style="margin-top: 10px; opacity: 0;">= 5×(-1) - 1×1 = -6</p>
                        </div>
                    </div>
                    
                    <div id="solution" style="font-size: 1.5rem; margin-top: 30px; opacity: 0;">
                        x = D_x/D = -6/(-3) = <span style="color: var(--success-color);">2</span>
                    </div>
                </div>
            </div>
        `;

        // 动画显示计算步骤
        setTimeout(() => {
            document.getElementById('det-d').style.transition = 'opacity 0.5s';
            document.getElementById('det-d').style.opacity = '1';
        }, 1000 / globalAnimationSpeed);

        setTimeout(() => {
            document.getElementById('det-dx').style.transition = 'opacity 0.5s';
            document.getElementById('det-dx').style.opacity = '1';
        }, 2000 / globalAnimationSpeed);

        setTimeout(() => {
            document.getElementById('solution').style.transition = 'opacity 0.5s';
            document.getElementById('solution').style.opacity = '1';
        }, 3000 / globalAnimationSpeed);
    }

    // 特征值特征向量可视化
    function visualizeEigenvalue() {
        const setup = setupD3('vis-eigenvalue');
        if (!setup) return;
        const { g, width, height } = setup;

        const cx = width / 2;
        const cy = height / 2;
        const scale = 60;

        // 矩阵 A = [[2, 0], [0, 3]]
        // 特征值: λ1 = 2, λ2 = 3
        // 特征向量: v1 = [1, 0], v2 = [0, 1]

        // 绘制坐标系
        g.append('line')
            .attr('x1', 0).attr('y1', cy)
            .attr('x2', width).attr('y2', cy)
            .attr('stroke', 'rgba(255,255,255,0.3)');

        g.append('line')
            .attr('x1', cx).attr('y1', 0)
            .attr('x2', cx).attr('y2', height)
            .attr('stroke', 'rgba(255,255,255,0.3)');

        // 原始向量
        const v1 = { x: 1, y: 0, color: 'var(--danger-color)' };
        const v2 = { x: 0, y: 1, color: 'var(--success-color)' };

        // 绘制原始向量
        g.append('line')
            .attr('x1', cx).attr('y1', cy)
            .attr('x2', cx + v1.x * scale).attr('y2', cy - v1.y * scale)
            .attr('stroke', v1.color)
            .attr('stroke-width', 3)
            .attr('id', 'eigen-v1');

        g.append('line')
            .attr('x1', cx).attr('y1', cy)
            .attr('x2', cx + v2.x * scale).attr('y2', cy - v2.y * scale)
            .attr('stroke', v2.color)
            .attr('stroke-width', 3)
            .attr('id', 'eigen-v2');

        // 标签
        g.append('text')
            .attr('x', cx + scale + 10).attr('y', cy + 5)
            .text('v₁')
            .attr('fill', v1.color)
            .attr('font-size', '16px');

        g.append('text')
            .attr('x', cx + 5).attr('y', cy - scale - 10)
            .text('v₂')
            .attr('fill', v2.color)
            .attr('font-size', '16px');

        // 变换后的向量（动画）
        setTimeout(() => {
            // v1 变为 2v1
            d3.select('#eigen-v1')
                .transition()
                .duration(1500 / globalAnimationSpeed)
                .attr('x2', cx + 2 * v1.x * scale);

            // v2 变为 3v2
            d3.select('#eigen-v2')
                .transition()
                .duration(1500 / globalAnimationSpeed)
                .attr('y2', cy - 3 * v2.y * scale);

            // 添加说明
            g.append('text')
                .attr('x', cx + 2 * scale + 10).attr('y', cy + 5)
                .text('2v₁')
                .attr('fill', v1.color)
                .attr('font-size', '16px')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);

            g.append('text')
                .attr('x', cx + 5).attr('y', cy - 3 * scale - 10)
                .text('3v₂')
                .attr('fill', v2.color)
                .attr('font-size', '16px')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 1000 / globalAnimationSpeed);

        // 显示矩阵信息
        g.append('text')
            .attr('x', 20).attr('y', 40)
            .text('矩阵 A = [[2, 0], [0, 3]]')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px');

        g.append('text')
            .attr('x', 20).attr('y', 65)
            .text('特征值: λ₁ = 2, λ₂ = 3')
            .attr('fill', 'var(--warning-color)')
            .attr('font-size', '16px');

        g.append('text')
            .attr('x', 20).attr('y', 90)
            .text('特征向量只改变长度，不改变方向')
            .attr('fill', 'var(--info-color)')
            .attr('font-size', '14px');
    }

    // 应用案例可视化
    function visualizeApplications() {
        const container = document.getElementById('vis-applications');
        if (!container) return;
        
        container.innerHTML = `
            <div class="vis-container">
                <h3 style="color: ${themeColors.text}; margin-bottom: 30px;">线性代数实际应用</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 30px; max-width: 800px;">
                    
                    <div class="matrix-wrapper" style="text-align: center;">
                        <h4 style="color: var(--primary-color); margin-bottom: 15px;">图像处理</h4>
                        <div style="display: flex; align-items: center; justify-content: center; gap: 20px;">
                            <div style="width: 60px; height: 60px; background: linear-gradient(45deg, #333, #666); border-radius: 5px;"></div>
                            <span style="color: ${themeColors.text};">→</span>
                            <div style="width: 60px; height: 60px; background: linear-gradient(45deg, #666, #999); border-radius: 5px; filter: blur(2px);"></div>
                        </div>
                        <p style="color: rgba(255,255,255,0.8); margin-top: 10px; font-size: 0.9rem;">
                            滤镜 = 矩阵卷积
                        </p>
                    </div>
                    
                    <div class="matrix-wrapper" style="text-align: center;">
                        <h4 style="color: var(--success-color); margin-bottom: 15px;">数据分析</h4>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;">
                                ${[1,2,3,4,5,6,7,8,9].map(i => 
                                    `<div style="width: 20px; height: 20px; background: rgba(52,152,219,${i/10});"></div>`
                                ).join('')}
                            </div>
                        </div>
                        <p style="color: rgba(255,255,255,0.8); margin-top: 10px; font-size: 0.9rem;">
                            数据矩阵分析
                        </p>
                    </div>
                    
                    <div class="matrix-wrapper" style="text-align: center;">
                        <h4 style="color: var(--warning-color); margin-bottom: 15px;">3D图形</h4>
                        <div class="rotate-3d" style="width: 60px; height: 60px; margin: 0 auto;">
                            <div style="width: 60px; height: 60px; border: 2px solid var(--warning-color); transform: rotateX(45deg) rotateY(45deg);"></div>
                        </div>
                        <p style="color: rgba(255,255,255,0.8); margin-top: 10px; font-size: 0.9rem;">
                            3D变换矩阵
                        </p>
                    </div>
                    
                    <div class="matrix-wrapper" style="text-align: center;">
                        <h4 style="color: var(--danger-color); margin-bottom: 15px;">机器学习</h4>
                        <div style="display: flex; justify-content: center; gap: 5px;">
                            <div style="width: 8px; height: 40px; background: var(--danger-color);"></div>
                            <div style="width: 8px; height: 60px; background: var(--danger-color);"></div>
                            <div style="width: 8px; height: 30px; background: var(--danger-color);"></div>
                            <div style="width: 8px; height: 50px; background: var(--danger-color);"></div>
                        </div>
                        <p style="color: rgba(255,255,255,0.8); margin-top: 10px; font-size: 0.9rem;">
                            神经网络权重矩阵
                        </p>
                    </div>
                </div>
            </div>
        `;
    }

    // 示例功能
    function showExample(type) {
        alert(`${type} 功能演示 - 开发中...`);
    }

    function downloadNotes() {
        alert('笔记下载功能 - 开发中...');
    }
</script>
</body>
</html>
