<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            processEnvironments: true,
            packages: {'[+]': ['ams', 'noerrors', 'color']},
            macros: {
                RR: '{\\mathbb{R}}',
                NN: '{\\mathbb{N}}',
                ZZ: '{\\mathbb{Z}}',
                QQ: '{\\mathbb{Q}}',
                CC: '{\\mathbb{C}}'
            }
        },
        options: {
            ignoreHtmlClass: 'tex2jax_ignore',
            processHtmlClass: 'tex2jax_process',
            renderActions: {
                addMenu: []
            }
        },
        startup: {
            // This prevents MathJax from running automatically on page load.
            // We will call it manually after our slides are created.
            ready: () => {
                console.log('MathJax is ready, but we will render manually.');
                MathJax.startup.defaultReady();
            },
            // Add this line to ensure the initial typeset is fully disabled
            pageReady: () => {}
        }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        /* 页面整体样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            background: #f0f2f5; /* 使用淡灰色背景 */
            overflow: hidden; /* 防止body滚动 */
        }

        /* 幻灯片主容器 */
        .slide-container {
            width: 100%;
            height: 100vh;
            display: flex;
            position: relative;
        }

        /* 左侧文本内容区域 */
        .left-content {
            width: 50%;
            height: 100vh;
            padding: 40px 50px;
            background: #ffffff;
            overflow-y: auto; /* 内容过长时允许滚动 */
            font-size: 17px;
            line-height: 1.9;
            color: #333;
        }

        /* 右侧可视化区域 */
        .right-visual {
            width: 50%;
            height: 100vh;
            background: #fdfdfd;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border-left: 1px solid #e0e0e0;
        }

        /* 幻灯片可见性与动画 */
        .slide {
            display: none;
            animation: fadeIn 0.6s ease-in-out;
        }

        .slide.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 标题排版 */
        h1 { color: #1a1a2e; font-size: 36px; margin-bottom: 25px; padding-bottom: 15px; border-bottom: 4px solid #4a90e2; }
        h2 { color: #34495e; font-size: 28px; margin: 30px 0 15px; }
        h3 { color: #555; font-size: 24px; margin: 25px 0 10px; }
        h4 { color: #666; font-size: 20px; margin: 20px 0 10px; }

        /* 内容模块样式 */
        .definition, .theorem, .example, .note {
            padding: 18px 25px;
            margin: 20px 0;
            border-radius: 8px;
            border-left-width: 5px;
            border-left-style: solid;
        }
        .definition { background: #eaf2f8; border-color: #3498db; }
        .theorem { background: #fef5e7; border-color: #f39c12; }
        .example { background: #e8f8f5; border-color: #2ecc71; }
        .note { background: #fdedec; border-color: #e74c3c; font-style: italic; }

        .formula-highlight {
            background: #f8f9fa;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-size: 1.25em;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        /* MathJax SVG 公式样式优化 */
        .MathJax {
            outline: 0;
            display: inline-block;
        }

        .MathJax_Display {
            text-align: center !important;
            margin: 1em 0 !important;
        }

        mjx-container[jax="SVG"] {
            display: inline-block;
            line-height: 0;
        }

        mjx-container[jax="SVG"][display="true"] {
            display: block;
            text-align: center;
            margin: 1em 0;
        }

        mjx-container[jax="SVG"] svg {
            display: inline-block;
            vertical-align: middle;
        }

        mjx-container[jax="SVG"][display="true"] svg {
            display: block;
            margin: 0 auto;
        }

        /* 确保SVG公式在不同设备上的清晰度 */
        mjx-container svg {
            shape-rendering: geometricPrecision;
            text-rendering: geometricPrecision;
        }

        /* 强制显示SVG数学公式 */
        mjx-container[jax="SVG"] {
            visibility: visible !important;
            opacity: 1 !important;
        }

        mjx-container[jax="SVG"] svg {
            visibility: visible !important;
            opacity: 1 !important;
            width: auto !important;
            height: auto !important;
        }

        /* 确保数学公式容器正确显示 */
        .slide-container .left-content mjx-container {
            display: inline-block !important;
        }

        .slide-container .left-content mjx-container[display="true"] {
            display: block !important;
            text-align: center !important;
        }

        /* Stage 3 新增：step-stack 与教师提示样式 */
        .step-stack { display: flex; flex-direction: column; gap: 10px; }
        .step-item { border: 1px dashed rgba(79,70,229,0.3); border-radius: 12px; padding: 10px 12px; background: rgba(79,70,229,0.04); display: none; }
        .step-item.active { display: block; background: rgba(79,70,229,0.12); border-color: #4f46e5; }
        .step-btn { margin-top: 8px; padding: 6px 10px; border-radius: 8px; border: 1px solid #e5e7eb; background: #ffffff; cursor: pointer; }
        .prompt-card { background: rgba(79,70,229,0.08); border: 1px solid rgba(79,70,229,0.18); border-radius: 12px; padding: 12px; }
        .teacher-note { background: #fff7ed; border: 1px solid #fed7aa; border-radius: 12px; padding: 12px; }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 悬浮AI按钮样式 */
        .ai-float-btn {
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
            border: none;
            color: white;
            font-size: 24px;
            animation: pulse 2s infinite;
        }

        .ai-float-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .ai-float-btn.show {
            display: flex;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            }
            50% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.8);
            }
            100% {
                box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            }
        }

        /* AI按钮提示文字 */
        .ai-float-btn::before {
            content: "AI数列助手";
            position: absolute;
            right: 70px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .ai-float-btn:hover::before {
            opacity: 1;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
.ai-float-btn {
                bottom: 80px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            .ai-float-btn::before {
                right: 60px;
                font-size: 12px;
                padding: 6px 10px;
            }
        }

        /* 可视化Canvas样式 */
        canvas {
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
        }

        /* 导航栏样式 - 重新设计为右下角小控件 */
        .nav-container {
            position: fixed;
            bottom: 15px;
            right: 15px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.3);
            padding: 6px 10px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
            opacity: 0.6;
            transition: opacity 0.3s ease;
            font-size: 12px;
        }

        .nav-container:hover {
            opacity: 1;
        }

        .nav-btn {
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }
        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }

        .slide-number {
            color: white;
            font-size: 10px;
            padding: 0 6px;
            font-weight: normal;
        }


        
        /* 其他UI元素 */
        ul, ol { margin-left: 25px; }
        li { margin: 10px 0; }

        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th { background: #3498db; color: white; padding: 12px; text-align: left; }
        td { padding: 10px; border: 1px solid #ddd; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .slide-container {
                flex-direction: column;
            }
            .left-content, .right-visual {
                width: 100%;
                height: 50vh;
            }
            .left-content {
                padding: 20px;
                font-size: 14px;
            }
            .nav-container {
                bottom: 10px;
                right: 10px;
                
                padding: 4px 8px;
                font-size: 10px;
            }
            .nav-btn {
                padding: 3px 6px;
                font-size: 9px;
            }
            canvas {
                max-width: 100%;
                height: auto;
            }
        }

        /* 打印样式 */
        @media print {
            .nav-container {
                display: none;
            }
            .slide {
                page-break-after: always;
            }
        }

        /* 加载指示器 */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #3498db;
            z-index: 9999;
        }

        /* 无障碍改进 */
        .nav-btn:focus {
            outline: 2px solid #3498db;
            outline-offset: 2px;
        }

        /* 错误提示 */
        .error-message {
            color: #e74c3c;
            text-align: center;
            padding: 20px;
            font-size: 16px;
        }



        /* Lab Menu Button Styles */
        .lab-menu-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 999;
            background: rgba(52, 73, 94, 0.8);
            color: #ecf0f1;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .lab-menu-button:hover {
            background: rgba(52, 73, 94, 1);
            transform: scale(1.1);
        }

        /* Lab Menu Dropdown */
        .lab-menu {
            position: fixed;
            bottom: 90px;
            right: 30px;
            z-index: 998;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            padding: 15px;
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }

        .lab-menu.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .lab-menu h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }

        .lab-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .lab-item {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            text-decoration: none;
            padding: 10px 8px;
            border-radius: 8px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            display: block;
        }

        .lab-item:hover {
            background: linear-gradient(135deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        /* Step Stack Styles for Interactive Learning */
        .step-stack {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }

        .step-item {
            display: none;
            padding: 15px;
            margin: 10px 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .step-item.active {
            display: block;
            animation: fadeInUp 0.5s ease;
        }

        .step-item.completed {
            background: #e8f5e8;
            border-left: 3px solid #27ae60;
        }

        .step-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .step-btn:hover {
            background: linear-gradient(135deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .step-btn.completed {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .step-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .prompt-card {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border: 1px solid #f39c12;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            position: relative;
        }

        .prompt-card::before {
            content: "💡";
            position: absolute;
            top: -10px;
            left: 15px;
            background: #f39c12;
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .teacher-note {
            background: linear-gradient(135deg, #e8f4fd, #dbeafe);
            border: 1px solid #3498db;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            position: relative;
            font-style: italic;
        }

        .teacher-note::before {
            content: "👩‍🏫";
            position: absolute;
            top: -10px;
            left: 15px;
            background: #3498db;
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .knowledge-objective {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .student-pain-points {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

    </style>
</head>
<body>
    <!-- Lab Menu Button -->
    <button class="lab-menu-button" onclick="toggleLabMenu()" title="第二章实验室">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 11H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2h-4"/>
            <path d="M9 7V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v3"/>
            <circle cx="12" cy="13" r="1"/>
        </svg>
    </button>

    <!-- Lab Menu Dropdown -->
    <div class="lab-menu" id="labMenu">
        <h3>第二章实验室</h3>
        <div class="lab-grid">
            <a href="../网页资源/lab 2-1.html" class="lab-item" target="_blank">Lab 2-1</a>
            <a href="../网页资源/lab 2-2.html" class="lab-item" target="_blank">Lab 2-2</a>
            <a href="../网页资源/lab 2-3.html" class="lab-item" target="_blank">Lab 2-3</a>
            <a href="../网页资源/lab 2-4.html" class="lab-item" target="_blank">Lab 2-4</a>
            <a href="../网页资源/lab 2-5.html" class="lab-item" target="_blank">Lab 2-5</a>
            <a href="../网页资源/lab 2-6.html" class="lab-item" target="_blank">Lab 2-6</a>
            <a href="../网页资源/lab 2-7.html" class="lab-item" target="_blank">Lab 2-7</a>
            <a href="../网页资源/lab 2-8.html" class="lab-item" target="_blank">Lab 2-8</a>
            <a href="../网页资源/lab 2-9.html" class="lab-item" target="_blank">Lab 2-9</a>
            <a href="../网页资源/lab 2-10.html" class="lab-item" target="_blank">Lab 2-10</a>
            <a href="../网页资源/lab 2-11.html" class="lab-item" target="_blank">Lab 2-11</a>
            <a href="../网页资源/lab 2-12.html" class="lab-item" target="_blank">Lab 2-12</a>
            <a href="../网页资源/lab 2-13.html" class="lab-item" target="_blank">Lab 2-13</a>
        </div>
    </div>

    <!-- 幻灯片将在此处动态生成 -->
    <div id="slidesContainer"></div>

    <!-- 导航控件 -->
    <div class="nav-container">
        <button class="nav-btn" onclick="prevSlide()" aria-label="上一页">上一页</button>
        <span class="slide-number" id="slideNumber">1 / 48</span>
        <button class="nav-btn" onclick="nextSlide()" aria-label="下一页">下一页</button>
        <button class="nav-btn" onclick="autoPlay()" id="autoPlayBtn" aria-label="自动播放">自动播放</button>
        <button class="nav-btn" onclick="forceRerenderMath()" id="rerenderMathBtn" style="background: #f59e0b; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-left: 10px;">重新渲染公式</button>
    </div>

    <!-- AI数列助手悬浮按钮 -->
    <button class="ai-float-btn" id="aiFloatBtn" title="打开AI数列助手">🤖</button>

    <script>
        // 包含所有幻灯片内容的数组
        const slidesData = [
            {
                title: "第2章 极限与连续",
                content: `<h1>第2章 极限与连续</h1><h2>本章内容</h2><ul><li><strong>01</strong> 极限的概念</li><li><strong>02</strong> 极限的性质和运算法则</li><li><strong>03</strong> 两个重要极限及无穷小的比较</li><li><strong>04</strong> 函数的连续性</li></ul><div class="note">函数极限的概念和思想是整个高等数学的灵魂, 随后我们要学习的导数、积分、级数等概念的建立, 都是以极限思想为出发点的, 没有极限就没有整个微积分.</div>`,
                animation: "title"
            },
            {
                title: "课堂目标与学生痛点",
                content: `
                <div class="knowledge-objective">
                    <h3>🎯 本节课学生需要掌握的3件事</h3>
                    <ol>
                        <li><strong>理解极限的本质</strong>：能用自己的话解释"无限接近"的含义</li>
                        <li><strong>判断收敛与发散</strong>：能够识别数列是否有极限</li>
                        <li><strong>掌握求极限的基本方法</strong>：直接代入、因式分解、有理化等技巧</li>
                    </ol>
                </div>
                <div class="student-pain-points">
                    <h3>⚠️ 学生常见困难点</h3>
                    <ul>
                        <li><strong>符号理解</strong>：$\lim_{n\to\infty}$、$\varepsilon$-$N$定义看不懂</li>
                        <li><strong>概念混淆</strong>：极限值 vs 数列的项，无限接近 vs 等于</li>
                        <li><strong>计算技能</strong>：遇到0/0型不知道如何处理</li>
                    </ul>
                    <div class="teacher-note">
                        <strong>教学策略</strong>：多用生活类比，分步骤展示解题过程，强调"先试后想"的解题习惯
                    </div>
                </div>`,
                animation: "objective"
            },
            {
                title: "1. 认识数列",
                content: `
                <h2>🏢 从生活中认识数列</h2>
                <div class="prompt-card">
                    <strong>教师提问</strong>：我们生活中会遇到很多按顺序排列的数字，比如楼层号1, 2, 3... 这种按一定次序排列的一列数，我们叫它什么？
                </div>

                <div class="step-stack" id="sequence-intro">
                    <div class="step-item active" data-step="1">
                        <h4>生活中的数列例子</h4>
                        <ul>
                            <li>🏢 楼层号：1楼、2楼、3楼...</li>
                            <li>📱 手机号码的每一位</li>
                            <li>🎵 音阶：do、re、mi、fa...</li>
                            <li>📅 日期：1号、2号、3号...</li>
                        </ul>
                        <button class="step-btn" data-action="next">下一步：数学定义</button>
                    </div>

                    <div class="step-item" data-step="2">
                        <div class="definition">
                            <strong>定义1</strong> 在某一法则下,当 $n(n\in N^{+})$ 依次取 $1,2,3,\cdots,n,\cdots$ 时,对应的实数排成一列数 $x_{1},x_{2},x_{3},...,x_{n},\cdots$,这列数就称为数列,记作 $\\{x_n\\}$。
                        </div>
                        <p>数列中的每一个数称为数列的项,第n项 $x_{n}$ 称为数列的一般项或通项。</p>
                        <button class="step-btn" data-action="next">下一步：常见误区</button>
                    </div>

                    <div class="step-item" data-step="3">
                        <h4>⚠️ 常见误区纠正</h4>
                        <div style="background: #ffe6e6; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <strong>❌ 误区</strong>：认为数列必须是连续的整数
                        </div>
                        <div style="background: #e6ffe6; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <strong>✅ 纠正</strong>：数列可以是任何按顺序排列的数，如1, 4, 9, 16...（平方数列）
                        </div>
                        <button class="step-btn completed" data-action="reset">重新开始</button>
                    </div>
                </div>`,
                animation: "sequence"
            },
            {
                title: "视角的转变：高中 vs 大学",
                content: `
                <h2>🔍 视角的转变：高中 vs 大学</h2>
                <div class="prompt-card">
                    <strong>教师串词</strong>：“在高中阶段，我们研究数列时，关注的是它的内部规律和有限步骤；到了大学，我们要关心的是它的终点命运。”
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div style="background: rgba(59,130,246,0.08); padding: 18px; border-radius: 12px; border-left: 4px solid #3b82f6;">
                        <h3>高中数学：有限视角</h3>
                        <ul>
                            <li><strong>研究对象：</strong>前 n 项（n 是具体的、有限的）</li>
                            <li><strong>核心问题：</strong>
                                <ul>
                                    <li>通项公式 $a_n$ 是什么？</li>
                                    <li>前 n 项和 $S_n$ 多少？</li>
                                </ul>
                            </li>
                            <li><strong>关键词：</strong>等差、等比、通项、求和</li>
                            <li><strong>视角：</strong>内部结构 &amp; 有限过程</li>
                        </ul>
                    </div>
                    <div style="background: rgba(16,185,129,0.08); padding: 18px; border-radius: 12px; border-left: 4px solid #10b981;">
                        <h3>大学高数：无限视角</h3>
                        <ul>
                            <li><strong>研究对象：</strong>整个数列，尤其是无限多项的趋势</li>
                            <li><strong>核心问题：</strong>
                                <ul>
                                    <li>当 $n \to \infty$ 时，$a_n$ 趋向哪个值？</li>
                                    <li>数列收敛还是发散？</li>
                                </ul>
                            </li>
                            <li><strong>关键词：</strong>极限、收敛、发散、趋势</li>
                            <li><strong>视角：</strong>终点行为 &amp; 无限过程</li>
                        </ul>
                    </div>
                </div>`,
                animation: "view_shift"
            },
            {
                title: "2. 观察趋势",
                content: `
                <h2>🏃‍♂️ 观察数列的变化趋势</h2>
                <div class="prompt-card">
                    <strong>教师提问</strong>：我们来看这个数列 $x_n = \frac{n}{n+1}$。当 n=1, 2, 10, 100 时，这个数分别是多少？你发现 n 越来越大时，这个数越来越接近哪个固定的数字？它会等于那个数吗？
                </div>

                <div class="step-stack" id="trend-observation">
                    <div class="step-item active" data-step="1">
                        <h4>让学生计算几个值</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                            <p>$x_1 = \frac{1}{1+1} = \frac{1}{2} = 0.5$</p>
                            <p>$x_2 = \frac{2}{2+1} = \frac{2}{3} ≈ 0.667$</p>
                            <p>$x_{10} = \frac{10}{10+1} = \frac{10}{11} ≈ 0.909$</p>
                            <p>$x_{100} = \frac{100}{100+1} = \frac{100}{101} ≈ 0.990$</p>
                        </div>
                        <button class="step-btn" data-action="next">下一步：类比理解</button>
                    </div>

                    <div class="step-item" data-step="2">
                        <h4>🏃‍♂️ 跑步类比</h4>
                        <p><strong>跑1000米</strong>：第1秒跑了1/2，第2秒跑了2/3，第10秒跑了10/11...越来越接近全程，但永远差一点点</p>
                        <h4>💧 水杯类比</h4>
                        <p><strong>倒水</strong>：杯子容量n+1，已倒入n，比例越来越接近满杯(1)但永远不满</p>
                        <button class="step-btn" data-action="next">下一步：误区纠正</button>
                    </div>

                    <div class="step-item" data-step="3">
                        <h4>⚠️ 常见误区纠正</h4>
                        <div style="background: #ffe6e6; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <strong>❌ 误区1</strong>：认为数列最终会等于1
                        </div>
                        <div style="background: #e6ffe6; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <strong>✅ 纠正</strong>：无限接近1但永远不等于1
                        </div>
                        <div style="background: #ffe6e6; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <strong>❌ 误区2</strong>：分子分母都趋于无穷所以极限不存在
                        </div>
                        <div style="background: #e6ffe6; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <strong>✅ 纠正</strong>：要看比值的趋势，不是单独看分子分母
                        </div>
                        <button class="step-btn completed" data-action="reset">重新开始</button>
                    </div>
                </div>`,
                animation: "trend"
            },
            {
                title: "终点行为的三种命运",
                content: `
                <h2>🎬 数列的“终点行为”</h2>
                <p>数列写到无穷时，可能出现三种典型命运：</p>
                <ol>
                    <li><strong>收敛：</strong>项越来越靠近某个固定的数值</li>
                    <li><strong>发散到无穷：</strong>项不断增大（或减小）没有上界</li>
                    <li><strong>摆动发散：</strong>项在多个值之间来回震荡</li>
                </ol>
                <div class="teacher-note">“接下来我们要发展一种语言——极限，来精准描述这些命运。”</div>
                `,
                animation: "terminal_behaviors"
            },
            {
                title: "视角升级：数列是一种特殊的函数",
                content: `
                <h2>🔁 视角升级：数列 = 特殊的函数</h2>
                <p>数列可以理解为定义域仅包含正整数的函数：</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div style="background: rgba(99,102,241,0.08); padding: 16px; border-radius: 12px; border-left: 4px solid #6366f1;">
                        <h3>数列写法</h3>
                        <p>$\\{x_n\\}: x_1, x_2, x_3, \cdots$</p>
                        <p>例：$x_n=\frac{n}{n+1} = \frac{1}{2}, \frac{2}{3}, \frac{3}{4}, \cdots$</p>
                    </div>
                    <div style="background: rgba(14,165,233,0.08); padding: 16px; border-radius: 12px; border-left: 4px solid #0ea5e9;">
                        <h3>函数写法</h3>
                        <p>$f(n),\\ n\in\mathbb{N}^+$</p>
                        <p>例：$f(n)=\frac{n}{n+1}\Rightarrow f(1)=\frac{1}{2}, f(2)=\frac{2}{3}$</p>
                    </div>
                </div>
                <div class="teacher-note">“换个视角，数列就是一个只在整数点上取值的离散函数。”</div>
                `,
                animation: "sequence_function"
            },
            {
                title: "定义域决定逼近方式",
                content: `
                    <h2>🛤️ 定义域不同，逼近方式也不同</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div style="background: rgba(251,191,36,0.12); padding: 16px; border-radius: 12px; border-left: 4px solid #fbbf24;">
                            <h3>数列：离散的道路</h3>
                            <p>自变量只能取 $1,2,3,\cdots$，唯一的逼近方式是 $n\to\infty$。</p>
                        </div>
                        <div style="background: rgba(34,197,94,0.12); padding: 16px; border-radius: 12px; border-left: 4px solid #22c55e;">
                            <h3>函数：连续的高速公路</h3>
                            <p>自变量是连续实数，可以左逼近、右逼近、趋向 $+\infty$ 或 $-\infty$。</p>
                        </div>
                    </div>
                    <div class="prompt-card">
                        <strong>教师提问</strong>：“定义域扩展后，逼近方式为何变多？这就是函数极限比数列极限复杂的原因。”
                    </div>
                `,
                animation: "domain_approach"
            },

            {
                title: "3. 极限定义与通俗解释",
                content: `
                <h2>🎯 理解极限的本质</h2>
                <div class="prompt-card">
                    <strong>教师提问</strong>：刚才我们看到的'无限接近'，在数学上就叫'极限'。谁能用自己的话描述一下什么是'极限'？它像一个我们永远也到不了，但可以无限靠近的目标。
                </div>

                <div class="step-stack" id="limit-definition">
                    <div class="step-item active" data-step="1">
                        <h4>🎯 射箭类比</h4>
                        <p><strong>高手射箭</strong>：箭越来越接近靶心，但永远有微小偏差</p>
                        <h4>🚗 停车类比</h4>
                        <p><strong>自动泊车系统</strong>：让车无限接近完美位置</p>
                        <button class="step-btn" data-action="next">下一步：数学定义</button>
                    </div>

                    <div class="step-item" data-step="2">
                        <div class="definition">
                            <strong>定义2</strong> 对于数列 $\\{x_{n}\\}$,如果当n无限增大时,数列的一般项 $x_{n}$ 无限地接近于某一确定的数值a,则称常数a是数列 $\\{x_{n}\\}$ 的极限,或称数列 $\\{x_{n}\\}$ 收敛于a,记作 $$\displaystyle\lim_{n\to\infty}x_{n}=a$$
                        </div>
                        <p>如果数列没有极限,就说数列是发散的。</p>
                        <button class="step-btn" data-action="next">下一步：ε-N承诺</button>
                    </div>

                    <div class="step-item" data-step="3">
                        <h4>📐 ε-N承诺理解</h4>
                        <p><strong>承包商承诺</strong>：就像承包商说"给我足够时间(N)，我能把误差控制在你要求的范围(ε)内"</p>
                        <div class="teacher-note">
                            书上的 ε-N 定义其实就是在说：无论你要求多小的误差（ε），我总能找到一个位置（N），从这个位置往后，所有的数都满足你的误差要求。这像不像一个承诺？
                        </div>
                        <button class="step-btn completed" data-action="reset">重新开始</button>
                    </div>
                </div>`,
                animation: "limit"
            },
            {
                title: "极限的通俗理解",
                content: `<h4>极限的通俗理解</h4><p><strong>极限就是一个"目标值"或"靶心"</strong>。想象一下，数列的每一项 $x_n$ 就像一个射手在不同时间点（时间点就是n）射出的一支箭。</p><ul><li>如果随着时间的推移（n越来越大），这些箭射得<strong>越来越靠近一个固定的靶心</strong>（数值a），那么这个靶心"a"就是这个数列的<strong>极限</strong>。</li><li>如果这些箭到处乱飞，没有一个明确的靶心，那它就没有极限。</li></ul>`,
                animation: "target"
            },
            {
                title: "收敛与发散",
                content: `<h4>"收敛"与"发散"</h4><div class="definition"><strong>收敛 (Convergent)</strong>：就是数列有极限。想象所有的项最终都"收"拢到极限那个点附近。</div><div class="theorem"><strong>发散 (Divergent)</strong>：就是数列没有极限。发散有两种主要情况：<ul><li>一种是项的值越来越大或越来越小，奔向无穷了</li><li>另一种是项的值在几个数之间来回"震荡"，总也稳定不下来</li></ul></div>`,
                animation: "convergence"
            },
            {
                title: "Collatz猜想",
                content: `<h4>Collatz 猜想 (3n+1 数列)</h4><p>从任何正数开始并遵循两个简单规则：</p><ul><li>如果 $x_{n}$ 是偶数,则 $x_{n+1}=\frac{x_{n}}{2}$</li><li>如果 $x_{n}$ 是奇数,则 $x_{n+1}=3x_{n}+1$</li></ul><p>猜想表明,无论起始数字如何,最终总会达到4, 2, 1的循环。</p>`,
                animation: "collatz"
            },
            {
                title: "斐波那契数列",
                content: `<h4>斐波那契数列与黄金分割</h4><div class="example"><p><strong>斐波那契数列</strong>: 每个数是前两个数的和。<br>0, 1, 1, 2, 3, 5, 8, 13, 21, 34,...</p><p><strong>黄金分割 $\phi$</strong>: 约等于1.618。</p><div class="formula-highlight">$$\displaystyle\lim_{n\to\infty}\frac{F(n)}{F(n-1)}=\phi$$</div></div>`,
                animation: "fibonacci"
            },
            {
                title: "例1-1",
                content: `
                <div class="step-stack" data-steps="example1_1">
                  <div class="step-item active" data-step="1">
                    <h4>题面</h4>
                    <p>讨论数列 $x_n=\frac{n}{n+1}$ 的变化趋势</p>
                    <button class="step-btn" data-action="next">显示思考提示</button>
                  </div>
                  <div class="step-item" data-step="2">
                    <h4>思考提示</h4>
                    <p>代入 n=1,2,10,100，观察值接近哪个常数？</p>
                    <button class="step-btn" data-action="next">显示解析</button>
                  </div>
                  <div class="step-item" data-step="3">
                    <h4>解析</h4>
                    <p>$\lim\limits_{n\to\infty}\frac{n}{n+1}=1$，无限接近但不等于 1。</p>
                  </div>
                </div>
                <div class="canvas-wrapper">
                  <canvas class="step-canvas" width="640" height="360" data-scene="example1_1"></canvas>
                </div>
                `,
                animation: "example1_1"
            },
            {
                title: "例1-2",
                content: `
                <div class="step-stack" data-steps="example1_2">
                  <div class="step-item active" data-step="1">
                    <h4>题面</h4>
                    <p>数列 $x_{n}=\frac{1}{2}[1+(-1)^{n}]$ 是否收敛？</p>
                    <button class="step-btn" data-action="next">显示思考提示</button>
                  </div>
                  <div class="step-item" data-step="2">
                    <h4>思考提示</h4>
                    <p>写出前几项并观察是否趋于固定值：$0,1,0,1,\cdots$</p>
                    <button class="step-btn" data-action="next">显示解析</button>
                  </div>
                  <div class="step-item" data-step="3">
                    <h4>解析</h4>
                    <p>在 0 与 1 之间震荡不趋于常数，故极限不存在（发散）。</p>
                  </div>
                </div>
                <div class="canvas-wrapper">
                  <canvas class="step-canvas" width="640" height="360" data-scene="example1_2"></canvas>
                </div>
                `,
                animation: "example1_2"
            },
            {
                title: "例1-3",
                content: `
                <div class="step-stack" data-steps="example1_3">
                  <div class="step-item active" data-step="1">
                    <h4>题面</h4>
                    <p>讨论 $x_{n}=\frac{1}{(-3)^{n}}$ 的收敛性</p>
                    <button class="step-btn" data-action="next">显示思考提示</button>
                  </div>
                  <div class="step-item" data-step="2">
                    <h4>思考提示</h4>
                    <p>$|x_n|=3^{-n}$，随 n 增大迅速趋于 0</p>
                    <button class="step-btn" data-action="next">显示解析</button>
                  </div>
                  <div class="step-item" data-step="3">
                    <h4>解析</h4>
                    <p>$\lim\limits_{n\to\infty} x_n = 0$，收敛到 0（符号交替但幅度衰减）。</p>
                  </div>
                </div>
                <div class="canvas-wrapper">
                  <canvas class="step-canvas" width="640" height="360" data-scene="example1_3"></canvas>
                </div>
                `,
                animation: "example1_3"
            },
            {
                title: "例1-4",
                content: `
                <div class="step-stack" data-steps="example1_4">
                  <div class="step-item active" data-step="1">
                    <h4>题面</h4>
                    <p>常数数列 $x_n=8$ 的极限是什么？</p>
                    <button class="step-btn" data-action="next">显示思考提示</button>
                  </div>
                  <div class="step-item" data-step="2">
                    <h4>思考提示</h4>
                    <p>每一项都等于同一个常数，是否存在“靠近”的目标？</p>
                    <button class="step-btn" data-action="next">显示解析</button>
                  </div>
                  <div class="step-item" data-step="3">
                    <h4>解析</h4>
                    <p>$\lim\limits_{n\to\infty} 8 = 8$，常数列的极限即该常数。</p>
                  </div>
                </div>
                <div class="canvas-wrapper">
                  <canvas class="step-canvas" width="640" height="360" data-scene="example1_4"></canvas>
                </div>
                `,
                animation: "example1_4"
            },
            {
            title: "拓展案例：Collatz 猜想",
                content: `
                <h2>🔎 拓展案例：Collatz 猜想</h2>
                <p>任意正整数按“奇数乘3加1、偶数除以2”的规则演化，似乎都会回到 $1 \rightarrow 4 \rightarrow 2 \rightarrow 1$ 的循环。</p>
                <div class="note">未被证明的开放问题：所有起点是否都最终进入该循环？</div>
                `,
                animation: "collatz"
            },
            {
                title: "拓展案例：斐波那契与黄金分割",
                content: `
                <h2>📐 斐波那契数列与黄金分割</h2>
                <p>斐波那契数列：$0,1,1,2,3,5,8,\cdots$</p>
                <p>比值极限：$\displaystyle\lim_{n\to\infty}\frac{F_n}{F_{n-1}}=\Phi\approx1.618$</p>
                <div class="teacher-note">这个极限解释了自然界与艺术中反复出现的黄金比例。</div>
                `,
                animation: "fibonacci"
            },
            {
                title: "拓展案例：折旧模型",
                content: `
                <h2>💼 折旧模型：现实中的收敛</h2>
                <p>例：一台设备每年折旧 10%，价格模型 $V_n = V_0 (0.9)^{n}$。</p>
                <p>随着 $n \to \infty$，$V_n \to 0$，说明实际价值将无限接近残值。</p>
                `,
                animation: "depreciation"
            },            {
                title: "函数的极限：整体视角",
                content: `<h3>2.1.2 函数的极限</h3><p>自变量可以不限于整数，我们关注的是函数值在不同趋近方式下的表现。</p><div class="teacher-note">“函数极限”是把数列极限推广到连续自变量的第一步。</div>`,
                animation: "function_notation"
            },
            {
                title: "函数的极限：x → ∞",
                content: `<h3>$x \to \infty$（趋向无穷）</h3><ul><li><strong>含义：</strong>$x$ 的绝对值无限增大</li><li><strong>记号：</strong>$\displaystyle\lim_{x\to\infty}f(x)=L$</li><li><strong>几何意义：</strong>沿数轴向两端移动时，函数值越来越接近 $L$。</li></ul>`,
                animation: "function_infinity"
            },
            {
                title: "函数的极限：x → +∞",
                content: `<h3>$x \to +\infty$（趋向正无穷）</h3><ul><li><strong>含义：</strong>$x$ 取越来越大的正数</li><li><strong>记号：</strong>$\displaystyle\lim_{x\to+\infty}f(x)=L$</li><li><strong>几何意义：</strong>沿数轴右端前进时，函数值逼近 $L$。</li></ul>`,
                animation: "function_infinity"
            },
            {
                title: "函数的极限：x → -∞",
                content: `<h3>$x \to -\infty$（趋向负无穷）</h3><ul><li><strong>含义：</strong>$x$ 取越来越小的负数</li><li><strong>记号：</strong>$\displaystyle\lim_{x\to-\infty}f(x)=L$</li><li><strong>几何意义：</strong>沿数轴左端前进时，函数值逼近 $L$。</li></ul>`,
                animation: "function_infinity"
            },
            {
                title: "函数的极限：x → x₀",
                content: `<h3>$x \to x_0$（趋向某个点）</h3><ul><li><strong>含义：</strong>$x$ 可以从左右两边无限靠近 $x_0$。</li><li><strong>记号：</strong>$\displaystyle\lim_{x\to x_0}f(x)=L$</li><li><strong>几何意义：</strong>在点 $x_0$ 附近观察函数的局部行为。</li></ul>`,
                animation: "point_limit"
            },
            {
                title: "函数的右极限：x → x₀⁺",
                content: `<h3>$x \to x_0^+$（从右侧逼近）</h3><ul><li><strong>含义：</strong>$x$ 取大于 $x_0$ 的值并逐渐接近它。</li><li><strong>记号：</strong>$\displaystyle\lim_{x\to x_0^+}f(x)=L$</li><li><strong>理解：</strong>只沿数轴右侧靠近目标点。</li></ul>`,
                animation: "right_limit_viz"
            },
            {
                title: "函数的左极限：x → x₀⁻",
                content: `<h3>$x \to x_0^-$（从左侧逼近）</h3><ul><li><strong>含义：</strong>$x$ 取小于 $x_0$ 的值并逐渐接近它。</li><li><strong>记号：</strong>$\displaystyle\lim_{x\to x_0^-}f(x)=L$</li><li><strong>理解：</strong>只沿数轴左侧靠近目标点。</li></ul>`,
                animation: "left_limit_viz"
            },
            {
                title: "函数的极限通俗理解",
                content: `<h4>函数极限的通俗理解</h4><div class="note"><p><strong>当 $x \to \infty$ 时：</strong><br>好比你站在函数图像上，沿着x轴一直向右($x \to +\infty$)或向左($x \to -\infty$)走。我们关心的是，当你走得非常远时，你所在位置的高度(y值)是否会稳定在某一个值？</p><p><strong>当 $x \to x_0$ 时：</strong><br>我们关心x<strong>无限靠近</strong> $x_0$ 时函数的高度 $f(x)$ 会怎样。<strong>只关心 $x_0$ 点附近的趋势，不在乎函数在 $x_0$ 点本身的值！</strong></p></div>`,
                animation: "function_limit_concept"
            },
            {
                title: "实例1 动物数量",
                content: `<div class="example"><strong>实例1 自然保护区中动物数量的变化规律</strong><br>动物群体数量会逐渐增长，但由于资源限制，群体不可能无限增大，它应达到某一饱和状态。饱和状态就是时间 $t \to \infty$ 时动物群的数量。</div>`,
                animation: "population"
            },
            {
                title: "$x \to \infty$ 时极限定义",
                content: `<div class="definition"><strong>定义3</strong> 如果当 $x\to\infty$ 时,函数值 $f(x)$ 无限趋近于某一个确定的常数A,那么A就称为函数 $f(x)$ 当 $x\to\infty$ 时的极限,记作 $$\displaystyle\lim_{x\to\infty}f(x)=A$$</div><div class="theorem"><strong>定理1</strong> $$\displaystyle\lim_{x\to\infty}f(x)=A \iff \lim_{x\to+\infty}f(x)=\lim_{x\to-\infty}f(x)=A$$</div>`,
                animation: "function_infinity"
            },
            {
                title: "例3 y=1/x",
                content: `<div class="example"><strong>例3</strong> 讨论当 $x\to+\infty$ 时,函数 $y=\frac{1}{x}$ 的变化趋势。</div><p><strong>解</strong>: 当x沿x轴正方向无限增大时,曲线 $y=\frac{1}{x}$ 无限接近于x轴,故极限为0。</p><div class="formula-highlight">$$\displaystyle\lim_{x\to+\infty}\frac{1}{x}=0$$</div>`,
                animation: "one_over_x"
            },
            {
                title: "例4 反正切函数",
                content: `<div class="example"><strong>例4</strong> 讨论反正切函数 $y=\arctan x$ 的极限。</div><p><strong>解</strong>: $$\displaystyle\lim_{x\to+\infty}\arctan x=\frac{\pi}{2}$$ $$\displaystyle\lim_{x\to-\infty}\arctan x=-\frac{\pi}{2}$$</p><p>由于左右极限不相等, 所以 $\displaystyle\lim_{x\to\infty}\arctan x$ 不存在。</p>`,
                animation: "arctan"
            },
            {
                title: "x趋向x0时的极限",
                content: `<h4>2. 当 $x\to x_{0}$ 时,函数 $f(x)$ 的极限</h4><div class="example"><strong>实例4 人影长度</strong><br>若一个人走向路灯正下方,他越靠近目标 $(x \to 0)$,其影子长度越短,逐渐趋于 $0(y \to 0)$。</div>`,
                animation: "shadow"
            },
            {
                title: "函数在点的极限定义",
                content: `<div class="definition"><strong>定义2-3</strong> 如果当 $x \to x_0$ 时, 函数 $f(x)$ 无限接近于一个确定的常数A, 那么称A为函数 $f(x)$ 在 $x \to x_0$ 时的极限, 记为 $$\displaystyle\lim_{x \to x_0} f(x) = A$$</div>`,
                animation: "point_limit"
            },
            {
                title: "瞬时速度",
                content: `<div class="example"><strong>实例5 瞬时速度</strong><br>自由落体运动的路程函数为 $s = \frac{1}{2}gt^2$。$t_0$ 时刻的瞬时速度就是 $t_0$ 到 $t$ 的平均速度在 $t \to t_0$ 时的极限。</div><p>$$v(t_0) = \displaystyle\lim_{t \to t_0} \frac{s(t) - s(t_0)}{t - t_0} = gt_0$$</p>`,
                animation: "velocity"
            },
            {
                title: "例6",
                content: `<div class="example"><strong>例6</strong> 设 $f(x)=\begin{cases}x+2, & x\geq 1 \\ 3x, & x<1\end{cases}$,判断 $\displaystyle\lim_{x\to 1}f(x)$ 是否存在。</div><p><strong>解</strong>: $\displaystyle\lim_{x\to 1^{+}}f(x)=\lim_{x\to 1^{+}}(x+2)=3$</p><p>$\displaystyle\lim_{x\to 1^{-}}f(x)=\lim_{x\to 1^{-}}3x=3$</p><p>左右极限存在且相等, 所以 $\displaystyle\lim_{x\to 1}f(x)=3$。</p>`,
                animation: "piecewise1"
            },
            {
                title: "例7",
                content: `<div class="example"><strong>例7</strong> 设 $f(x)=\begin{cases}x^{2}, & x\geq 0 \\ x+1, & x<0\end{cases}$ 讨论 $\displaystyle\lim_{x\to 0}f(x)$ 是否存在?</div><p><strong>解</strong>: $\displaystyle\lim_{x\to 0^{-}}f(x)=\lim_{x\to 0^{-}}(x+1)=1$</p><p>$\displaystyle\lim_{x\to 0^{+}}f(x)=\lim_{x\to 0^{+}}x^{2}=0$</p><p>左右极限不相等, 所以 $\displaystyle\lim_{x\to 0}f(x)$ 不存在。</p>`,
                animation: "piecewise2"
            },
            {
                title: "无穷小量",
                content: `<h3>2.1.3 无穷小量与无穷大量</h3><h4>1. 无穷小量</h4><div class="definition"><strong>定义5</strong> 在自变量x的某一变化过程中,若函数 $f(x)$ 的极限为0,即 $\lim f(x)=0$,则称 $f(x)$ 为在该变化过程中的<strong>无穷小量</strong>。</div><div class="note"><strong>注意</strong>：无穷小不是一个"很小的数"，而是一个以零为极限的函数。</div>`,
                animation: "infinitesimal"
            },
            {
                title: "无穷小的性质",
                content: `<h4>无穷小的性质</h4><div class="theorem"><strong>性质1</strong> 有限个无穷小的代数和仍是无穷小。<br><strong>性质2</strong> 有限个无穷小的乘积仍是无穷小。<br><strong>性质3</strong> 有界函数与无穷小的乘积仍是无穷小。</div><div class="example"><strong>例8</strong> 求 $\\displaystyle\\lim_{x\\to\\infty}\\frac{1}{x}\\cos x$ 。<br><strong>解</strong>: $\\frac{1}{x}$ 是无穷小, $|\\cos x|\\geq 1$ 是有界函数, 故极限为0。</div>`,
                animation: "infinitesimal_prop"
            },            {
                title: "无穷大量：概念",
                content: `<h3>无穷大量的定义</h3><p>在某个变化过程中，若 $|f(x)|$ 无限增大，则称 $f(x)$ 为<strong>无穷大量</strong>，记作 $\displaystyle\lim f(x)=\infty$。</p><div class="visual-hint">📈 想象函数值越走越远，没有上界。</div>`,
                animation: "infinite"
            },
            {
                title: "无穷大量：分类",
                content: `<h3>常见三种情形</h3><ul><li><strong>正无穷：</strong>$f(x)\to +\infty$</li><li><strong>负无穷：</strong>$f(x)\to -\infty$</li><li><strong>无穷：</strong>$|f(x)|\to \infty$ 不区分正负。</li></ul>`,
                animation: "infinite"
            },
            {
                title: "无穷大量：与无穷小的关系",
                content: `<h3>互为倒数</h3><p>若 $\alpha\to 0$，则 $\frac{1}{\alpha}\to \infty$；反之亦然。无穷大和无穷小是一对“镜像”概念。</p>`,
                animation: "infinitesimal_compare"
            },
            {
                title: "无穷大量：典型例子",
                content: `<h3>三类常见例子</h3><ul><li>$\displaystyle\frac{1}{x}$ 当 $x\to 0$。</li><li>$e^x$ 当 $x\to +\infty$。</li><li>$\tan x$ 当 $x\to \frac{\pi}{2}$。</li></ul>`,
                animation: "infinite"
            },
            {
                title: "极限的性质",
                content: `<h2>2.2 极限的性质和运算法则</h2><h3>2.2.1 极限的性质</h3><div class="theorem"><p><strong>定理1（唯一性）</strong> 如果极限存在,则极限唯一。</p><p><strong>定理2（有界性）</strong> 如果极限存在,则在某邻域内有界。</p><p><strong>定理3（保号性）</strong> 如果函数值 $\geq 0$,则极限也 $\geq 0$。</p></div>`,
                animation: "limit_properties"
            },
            {
                title: "极限的运算法则",
                content: `<h3>2.2.2 极限的运算法则</h3><div class="theorem"><strong>定理4</strong> 设 $\lim f(x)=A$ , $\lim g(x)=B$ ,则<ol><li>$\lim [f(x)\pm g(x)]=A\pm B$</li><li>$\lim [f(x)\cdot g(x)]=A\cdot B$</li><li>$\lim \frac{f(x)}{g(x)}=\frac{A}{B}(B\geq 0)$</li></ol></div>`,
                animation: "limit_rules"
            },
            {
                title: "直接代入法",
                content: `<h3>2.2.3 极限的求法</h3><h4>1. 直接代入法</h4><div class="example"><strong>例1</strong> 求 $\displaystyle\lim_{x \to 1} \frac{3x^2 + x + 1}{4x^3 + x^2 - x + 3}$<br><strong>解</strong>: $\frac{3(1)^2 + 1 + 1}{4(1)^3 + 1^2 - 1 + 3} = \frac{5}{7}$</div>`,
                animation: "direct_sub"
            },
            {
                title: "0/0型极限",
                content: `<h4>3. 分解因式,约去零因子法（$\frac{0}{0}$ 型）</h4><p>$\frac{0}{0}$ 型极限被称为"未定式"。它就像一场拔河比赛,分子想把结果拉向0,分母想把结果拉向无穷大。方法：将分子或分母分解因式,<strong>约去共同的零因子</strong>,再用直接代入法。</p>`,
                animation: "zero_zero"
            },
            {
                title: "有理化",
                content: `<h4>4. 分子或分母有理化（$\frac{0}{0}$ 型）</h4><div class="example"><strong>例3</strong> 求 $\displaystyle\lim_{x \to 4} \frac{x-4}{\sqrt{x-2}-\sqrt{2}}$<br><strong>解</strong>: $$\displaystyle\lim_{x \to 4} \frac{(x-4)(\sqrt{x-2}+\sqrt{2})}{(\sqrt{x-2}-\sqrt{2})(\sqrt{x-2}+\sqrt{2})} = \lim_{x \to 4} (\sqrt{x-2}+\sqrt{2}) = 2\sqrt{2}$$</div>`,
                animation: "rationalize"
            },
            {
                title: "无穷/无穷型",
                content: `<h4>5. 公式法（$\frac{\infty}{\infty}$ 型）</h4><div class="formula-highlight">$$\displaystyle\lim_{x\to\infty}\frac{a_{0}x^{n}+\cdots}{b_{0}x^{m}+\cdots}=\begin{cases} \frac{a_{0}}{b_{0}}, & n=m \\ 0, & n<m \\ \infty, & n>m \end{cases}$$</div><p>极限的结果,取决于分子和分母中"跑得最快的那个领头项"。</p>`,
                animation: "infinity_infinity"
            },
            {
                title: "第一个重要极限",
                content: `<h2>2.3 两个重要极限及无穷小的比较</h2><h3>2.3.1 两个重要极限</h3><h4>第一个重要极限</h4><div class="formula-highlight">$$\displaystyle\lim_{x\to 0}\frac{\sin x}{x}=1$$</div><p>它揭示了：<strong>当角度x非常小时, $\sin(x)$ 的值和 $x$ 的值几乎是一样的</strong> (x为弧度制)。</p>`,
                animation: "sinx_x"
            },
            {
                title: "第二个重要极限",
                content: `<h4>第二个重要极限</h4><div class="formula-highlight">$$\displaystyle\lim_{x\to\infty}\left(1+\frac{1}{x}\right)^{x}=e$$</div><p>它定义了自然常数 <strong>e (≈2.718)</strong>, 其背景是<strong>银行的连续复利</strong>。如果计息次数无限增多,最终得到的钱会趋向于极限值e。</p>`,
                animation: "e_limit"
            },
            {
                title: "无穷小比较：全局视图",
                content: `<h3>2.3.2 无穷小的比较</h3>
                <p>设 $\alpha, \beta$ 是无穷小量，通过比较 $\displaystyle\lim\frac{\beta}{\alpha}$ 的值来判断谁“跑得更快”。</p>
                <div style="display: grid; gap: 12px; margin: 20px 0;">
                    <div style="background: rgba(52, 152, 219, 0.1); padding: 12px; border-radius: 8px; border-left: 4px solid #3498db;">
                        <strong>高阶无穷小：</strong>$\displaystyle\lim\frac{\beta}{\alpha}=0$ → $\beta$ 比 $\alpha$ “小得更快”
                    </div>
                    <div style="background: rgba(231, 76, 60, 0.1); padding: 12px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                        <strong>低阶无穷小：</strong>$\displaystyle\lim\frac{\beta}{\alpha}=\infty$ → $\beta$ 比 $\alpha$ “小得更慢”
                    </div>
                    <div style="background: rgba(155, 89, 182, 0.1); padding: 12px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                        <strong>同阶无穷小：</strong>$\displaystyle\lim\frac{\beta}{\alpha}=c\neq0$ → $\beta$ 与 $\alpha$ “小得一样快”
                    </div>
                    <div style="background: rgba(46, 204, 113, 0.1); padding: 12px; border-radius: 8px; border-left: 4px solid #2ecc71;">
                        <strong>等价无穷小：</strong>$\displaystyle\lim\frac{\beta}{\alpha}=1$ → $\beta$ 与 $\alpha$ “几乎相等”，记作 $\alpha\sim\beta$
                    </div>
                </div>
                <div class="visual-hint">🏃‍♂️ 四种“跑向 0” 的节奏，决定我们如何比较无穷小。</div>`,
                animation: "infinitesimal_compare"
            },
            {
                title: "高阶无穷小",
                content: `<h3>高阶无穷小：掉得更快</h3>
                <div class="definition" style="background: rgba(52, 152, 219, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #3498db;">
                    <p><strong>定义：</strong>若 $\displaystyle\lim\frac{\beta}{\alpha}=0$，则 $\beta = o(\alpha)$，即 $\beta$ 比 $\alpha$ “小得更快”。</p>
                </div>
                <div style="margin: 20px 0;">
                    <h4>📝 典型例子</h4>
                    <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                        <p><strong>例1：</strong>当 $x \to 0$，$\displaystyle\frac{x^2}{x} \to 0$，因此 $x^2$ 是 $x$ 的高阶无穷小。</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px;">
                        <p><strong>例2：</strong>当 $x \to 0$，$\displaystyle\frac{x^3}{x} \to 0$，因此 $x^3$ 也是 $x$ 的高阶无穷小。</p>
                    </div>
                </div>
                <div class="visual-hint">📉 高阶无穷小“俯冲”得最迅速，是我们判断收敛速度的标杆。</div>`,
                animation: "infinitesimal_compare"
            },
            {
                title: "低阶无穷小",
                content: `<h3>低阶无穷小：掉得更慢</h3>
                <div class="definition" style="background: rgba(231, 76, 60, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #e74c3c;">
                    <p><strong>定义：</strong>若 $\displaystyle\lim\frac{\beta}{\alpha}=\infty$，则 $\beta$ 是比 $\alpha$ 更低阶的无穷小。</p>
                </div>
                <div style="margin: 20px 0;">
                    <h4>📝 典型例子</h4>
                    <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                        <p><strong>例1：</strong>当 $x \to 0$，$\displaystyle\frac{x}{x^2} \to \infty$，因此 $x$ 是比 $x^2$ 更低阶的无穷小。</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px;">
                        <p><strong>例2：</strong>当 $x \to 0^+$，$\displaystyle\frac{\sqrt{x}}{x} \to \infty$，因此 $\sqrt{x}$ 低于 $x$。</p>
                    </div>
                </div>
                <div class="visual-hint">📈 低阶无穷小像“慢跑者”，需要更长时间才能接近 0。</div>`,
                animation: "infinitesimal_compare"
            },
            {
                title: "同阶无穷小",
                content: `<h3>同阶无穷小：并驾齐驱</h3>
                <div class="definition" style="background: rgba(155, 89, 182, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #9b59b6;">
                    <p><strong>定义：</strong>若 $\displaystyle\lim\frac{\beta}{\alpha}=c\neq0$，则 $\beta$ 与 $\alpha$ 是同阶无穷小。</p>
                    <p><strong>理解：</strong>两个量朝 0 的“速度”一致。</p>
                </div>
                <div style="margin: 20px 0;">
                    <h4>📝 典型例子</h4>
                    <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                        <p><strong>例1：</strong>$\displaystyle\frac{2x}{x} \to 2$，因此 $2x$ 与 $x$ 同阶。</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px;">
                        <p><strong>例2：</strong>$\displaystyle\frac{3x^2}{x^2} \to 3$，因此 $3x^2$ 与 $x^2$ 同阶。</p>
                    </div>
                </div>
                <div class="visual-hint">🏃‍♂️🏃‍♀️ 两个选手并肩冲线，意味着它们可以互相比较也能互换尺度。</div>`,
                animation: "infinitesimal_compare"
            },
            {
                title: "等价无穷小：可互换的替身",
                content: `<h3>等价无穷小：计算里的黄金搭档</h3>
                <div class="definition" style="background: rgba(46, 204, 113, 0.12); padding: 20px; border-radius: 10px; border-left: 4px solid #2ecc71;">
                    <p><strong>定义：</strong>若 $\displaystyle\lim\frac{\beta}{\alpha}=1$，记作 $\alpha\sim\beta$，它们在极限运算中可以互换。</p>
                    <p><strong>意义：</strong>把复杂表达式换成熟悉的“替身”，能显著简化极限运算。</p>
                </div>
                <div class="prompt-card">在下一张幻灯片，我们整理了最常用的等价无穷小表，讲题时直接引用即可。</div>
                <div class="visual-hint">🔄 等价无穷小是一对“影分身”，随时可以无缝替换。</div>`,
                animation: "infinitesimal_compare"
            },            {
                title: "常用等价无穷小",
                content: `<h3>常用的等价无穷小（当 $x\to 0$ 时）</h3>
                <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 16px; margin: 20px 0;">
                    <div style="background: rgba(59,130,246,0.1); padding: 14px; border-radius: 10px; border-left: 4px solid #3b82f6;">
                        <p>$\sin x \sim x$</p>
                        <p>$\tan x \sim x$</p>
                        <p>$\arcsin x \sim x$</p>
                        <p>$\arctan x \sim x$</p>
                    </div>
                    <div style="background: rgba(16,185,129,0.1); padding: 14px; border-radius: 10px; border-left: 4px solid #10b981;">
                        <p>$1-\cos x \sim \tfrac{1}{2}x^{2}$</p>
                        <p>$\ln(1+x) \sim x$</p>
                        <p>$e^{x}-1 \sim x$</p>
                        <p>$\sqrt{1+x}-1 \sim \tfrac{1}{2}x$</p>
                    </div>
                </div>
                <div class="note">等价无穷小可以在极限运算中<strong>直接互换</strong>，记得附带“$x\to 0$”这一前提条件。</div>`,
                animation: "equivalent_infinitesimal"
            },            {
                title: "回归初心：谁能直接代入？",
                content: `
                <h2>🔄 回归初心：什么样的函数“好到可以直接代入”?</h2>
                <p>我们最早接触的求极限方法——直接代入法，需要函数在目标点附近表现“平滑”。</p>
                <div class="teacher-note">“连续性”正是用极限语言刻画这种好性质的工具。</div>
                `,
                animation: "continuity_intro"
            },
            {
                title: "连续性概念",
                content: `<h2>2.4 函数的连续性</h2><h3>2.4.1 连续函数的概念</h3><h4>1. 函数的增量</h4><p>自变量的增量: $\Delta x = x - x_0$</p><p>函数的增量: $\Delta y=f(x_{0}+\Delta x)-f(x_{0})$</p><div class="note">一个微小的x变化($\Delta x \to 0$), 只会引起一个微小的y变化($\Delta y \to 0$), 这就是连续。</div>`,
                animation: "continuity_concept"
            },
            {
                title: "连续性的三位一体",
                content: `
                <h2>🏗️ 连续性的三位一体</h2>
                <p>函数 $f(x)$ 在 $x_0$ 处连续，当且仅当以下三件事同时成立：</p>
                <ol>
                    <li>$f(x_0)$ 有定义（目标存在）</li>
                    <li>$\displaystyle\lim_{x\to x_0} f(x)$ 存在（左右隧道会师）</li>
                    <li>极限值等于函数值（会师点正好落在目标点）</li>
                </ol>
                <div class="teacher-note">“这三个条件缺一不可——少了任何一项，隧道都会断。”</div>
                `,
                animation: "continuity_three"
            },
            {
                title: "如何诊断不连续：对症下药",
                content: `
                <h2>🩺 诊断间断点：哪一步出了问题？</h2>
                <ul>
                    <li><strong>可去间断：</strong>极限存在，但 $f(x_0)$ 没定义或不等于极限 —— “把缺口补上即可。”</li>
                    <li><strong>跳跃间断：</strong>左右极限存在但不相等 —— “两支队伍高度对不上。”</li>
                    <li><strong>无穷间断：</strong>至少一侧极限为无穷 —— “隧道挖进了无底洞。”</li>
                </ul>
                `,
                animation: "discontinuity_diagnose"
            },
            {
                title: "好消息：初等函数都乖",
                content: `
                <h2>🎉 好消息：初等函数在定义域内都连续</h2>
                <p>多项式、指数、对数、三角、反三角……这些熟悉的函数，只要所求的点在定义域内，就可以放心用“直接代入”。</p>
                <div class="note">我们构建的极限理论，为这个“看似简单”的操作提供了严格保障。</div>
                `,
                animation: "elementary_continuity"
            },
            {
                title: "实例3 冰融化",
                content: `<div class="example"><strong>实例3 冰融化所需热量</strong><br>$f(x) = \begin{cases} 2.1x + 84, & x \geq 0 \\ 4.2x + 420, & x > 0 \end{cases}$<br>当 $x=0$ 时,函数是否连续?</div><p><strong>解</strong>: $\displaystyle\lim_{x \to 0^-} f(x) = 84$, $\displaystyle\lim_{x \to 0^+} f(x) = 420$</p><p>左右极限不相等, 所以函数在 $x=0$ 处不连续。</p>`,
                animation: "ice_melting"
            },
            {
                title: "间断点",
                content: `<h3>2.4.2 函数的间断点</h3><p>函数不连续的点称为<strong>间断点</strong>。有三种情形：(1)在 $x_0$ 无定义；(2)在 $x_0$ 无极限；(3)极限不等于函数值。</p>`,
                animation: "discontinuity"
            },
            {
                title: "第一类间断点",
                content: `<h4>第一类间断点 (左右极限都存在)</h4><div class="definition"><strong>可去间断点</strong>：就像路上的一个<strong>小坑</strong>。左右极限相等, 但该点无定义或函数值不等于极限值。</div><div class="theorem"><strong>跳跃间断点</strong>：就像路上的一个<strong>台阶</strong>。左右极限存在但不相等。</div>`,
                animation: "first_discontinuity"
            },
            {
                title: "第二类间断点",
                content: `<h4>第二类间断点 (至少一个极限不存在)</h4><div class="definition"><strong>无穷间断点</strong>：就像一个<strong>无底深渊</strong>。极限为无穷大, 如 $y = \\tan x$ 在 $x = \\frac{\\pi}{2}$ 处。</div><div class="theorem"><strong>震荡间断点</strong>：就像一个<strong>地震带</strong>。函数在某点附近无限次震荡, 如 $y = \\sin \\frac{1}{x}$ 在 $x=0$ 处。</div>`,
                animation: "second_discontinuity"
            },
            {
                title: "初等函数的连续性",
                content: `<h3>2.4.3 初等函数的连续性</h3><div class="theorem"><strong>定理3</strong> 一切初等函数在其定义区间内都是连续的。</div><div class="note">这意味着对于多项式、指数、对数、三角函数等，我们只需在定义域的分界点、或可能导致分母为0的点检查连续性。</div>`,
                animation: "elementary_continuity"
            },
            {
                title: "练习题1",
                content: `<div class="example"><strong>练习1</strong> 若 $\displaystyle\lim_{x \to -1} \frac{x^3+ax^2-x+4}{x+1} = b$, 求a, b.</div><p><strong>解</strong>: 分母 $\to 0$ 且极限存在 $\implies$ 分子 $\to 0$。<br>$(-1)^3 + a(-1)^2 - (-1) + 4 = 0 \implies a = -4$</p><p>代入后约去零因子 $(x+1)$, 得 $b = \displaystyle\lim_{x \to -1} (x^2-5x+4) = 10$</p>`,
                animation: "exercise1"
            },
            {
                title: "练习题2",
                content: `<div class="example"><strong>练习2</strong> 求 $\displaystyle\lim_{x \to 0} \frac{\sqrt{1+x}-\sqrt{1-x}}{\sin 3x}$</div><p><strong>解</strong>: 分子有理化并用等价无穷小替换 $\sin 3x \sim 3x$</p><p>$\displaystyle\lim_{x \to 0} \frac{(1+x)-(1-x)}{3x(\sqrt{1+x}+\sqrt{1-x})} = \lim_{x \to 0} \frac{2x}{3x(\sqrt{1+x}+\sqrt{1-x})} = \frac{2}{3(2)} = \frac{1}{3}$</p>`,
                animation: "exercise2"
            },
            {
                title: "总结",
                content: `<h2>本章总结</h2><h3>核心概念</h3><ul><li><strong>极限</strong>：函数变化的"目标值"</li><li><strong>连续</strong>：没有"跳跃"的函数</li><li><strong>无穷小</strong>：趋向于0的变量</li><li><strong>两个重要极限</strong>：微积分的基石</li></ul>`,
                animation: "summary"
            }
        ];

        let currentSlide = 1;
        const totalSlides = slidesData.length;
        let autoPlayInterval = null;
        let animationFrameId = null;

        // 渲染器状态
        let renderingInProgress = false;

        // MathJax 辅助函数，确保在任何地方调用时都能按顺序安全渲染
        function waitForMathJaxReady(timeout = 10000) {
            return new Promise((resolve, reject) => {
                const start = Date.now();

                const check = () => {
                    const mj = window.MathJax;
                    if (mj && mj.typesetPromise) {
                        const startupPromise = mj.startup && mj.startup.promise;
                        if (startupPromise && typeof startupPromise.then === 'function') {
                            const elapsed = Date.now() - start;
                            if (elapsed >= timeout) {
                                reject(new Error('MathJax startup timeout'));
                                return;
                            }
                            const remaining = timeout - elapsed;
                            const timeoutId = setTimeout(() => {
                                reject(new Error('MathJax startup timeout'));
                            }, remaining);
                            startupPromise.then(() => {
                                clearTimeout(timeoutId);
                                resolve(mj);
                            }).catch((err) => {
                                clearTimeout(timeoutId);
                                reject(err);
                            });
                        } else {
                            resolve(mj);
                        }
                        return;
                    }

                    if (Date.now() - start >= timeout) {
                        reject(new Error('MathJax not available after timeout'));
                        return;
                    }

                    setTimeout(check, 100);
                };

                check();
            });
        }

        const queueMathTypeset = (() => {
            let chain = Promise.resolve();
            return function(rootElements) {
                if (!window.MathJax || !window.MathJax.typesetPromise) {
                    return Promise.resolve();
                }

                let elements;
                if (Array.isArray(rootElements)) {
                    elements = rootElements;
                } else if (rootElements && typeof rootElements.length === 'number' && typeof rootElements !== 'string') {
                    elements = Array.from(rootElements);
                } else if (rootElements) {
                    elements = [rootElements];
                }

                chain = chain.then(() => {
                    if (!window.MathJax || !window.MathJax.typesetPromise) {
                        return true;
                    }
                    const promise = (elements && elements.length > 0)
                        ? window.MathJax.typesetPromise(elements)
                        : window.MathJax.typesetPromise();
                    return promise.then(() => true);
                }).catch((err) => {
                    console.error('MathJax typeset error:', err);
                    return false;
                });

                return chain;
            };
        })();

        function resetMathJaxState() {
            if (!window.MathJax) {
                return;
            }
            if (typeof window.MathJax.texReset === 'function') {
                window.MathJax.texReset();
            }
            if (typeof window.MathJax.typesetClear === 'function') {
                window.MathJax.typesetClear();
            } else if (window.MathJax.startup && window.MathJax.startup.document && typeof window.MathJax.startup.document.state === 'function') {
                window.MathJax.startup.document.state(0);
            }
        }

        // 初始化并创建所有幻灯片
        async function initSlides() {
            try {
                const container = document.getElementById('slidesContainer');
                if (!container) {
                    console.error('Slides container not found');
                    return;
                }

                // 清空容器
                container.innerHTML = '';

                // 创建所有幻灯片
                slidesData.forEach((slide, index) => {
                    const slideDiv = document.createElement('div');
                    slideDiv.className = `slide ${index === 0 ? 'active' : ''}`;
                    slideDiv.id = `slide${index + 1}`;
                    slideDiv.innerHTML = `<div class="slide-container"><div class="left-content tex2jax_process">${slide.content}</div><div class="right-visual"><canvas id="canvas${index + 1}" width="600" height="400"></canvas></div></div>`;
                    container.appendChild(slideDiv);
                });

                // 等待MathJax加载完成后渲染
                waitForMathJaxReady()
                    .then(() => {
                        console.log('开始渲染数学公式...');
                        // 渲染所有幻灯片
                        return queueMathTypeset();
                    })
                    .then((success) => {
                        if (!success) {
                            console.warn('初始公式渲染过程中出现问题');
                        } else {
                            console.log('公式渲染完成');
                        }
                        drawAnimation(1);
                        hideLoading();
                    })
                    .catch((err) => {
                        console.error('MathJax typeset error:', err);
                        drawAnimation(1);
                        hideLoading();
                    });
            } catch (error) {
                console.error('Error initializing slides:', error);
            }
        }

        // 显示指定幻灯片
        function showSlide(n) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            const slides = document.getElementsByClassName('slide');
            currentSlide = (n > totalSlides) ? 1 : (n < 1) ? totalSlides : n;
            
            // 移除所有活动状态
            Array.from(slides).forEach(s => s.classList.remove('active'));
            
            // 获取目标幻灯片
            const targetSlide = slides[currentSlide - 1];
            targetSlide.classList.add('active');
            
            // 重新渲染当前幻灯片的公式
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([targetSlide]).catch((err) => console.log('MathJax typeset error:', err));
            }
            
            // 更新页码显示
            document.getElementById('slideNumber').textContent = `${currentSlide} / ${totalSlides}`;
            
            // 直接绘制动画，MathJax会自动处理公式
            setTimeout(() => drawAnimation(currentSlide), 100);
        }

        // 导航功能
        function nextSlide() { showSlide(currentSlide + 1); }
        function prevSlide() { showSlide(currentSlide - 1); }
        function autoPlay() {
            const btn = document.getElementById('autoPlayBtn');
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
                btn.textContent = '自动播放';
            } else {
                autoPlayInterval = setInterval(nextSlide, 5000);
                btn.textContent = '停止播放';
            }
        }

        // 动画主路由
        function drawAnimation(slideNum) {
            try {
                const canvas = document.getElementById(`canvas${slideNum}`);
                if (!canvas) {
                    console.warn(`Canvas not found for slide ${slideNum}`);
                    return;
                }
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.warn(`Could not get 2D context for canvas ${slideNum}`);
                    return;
                }

                const slide = slidesData[slideNum - 1];
                if (!slide) {
                    console.warn(`Slide data not found for slide ${slideNum}`);
                    return;
                }

                const animationType = slide.animation;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const animationMap = {
                    title: drawTitleAnimation, view_shift: drawViewShift, sequence: drawSequenceAnimation, sequence_function: drawSequenceFunction, queue: drawQueueVisualization,
                    limit: drawLimitConcept, target: drawTargetAnimation, convergence: drawConvergenceDivergence,
                    collatz: drawCollatzSequence, fibonacci: drawFibonacciRatio, example1_1: drawSequenceAnimation,
                    example1_2: drawExample1_2, example1_3: drawExample1_3, example1_4: drawExample1_4,
                    depreciation: drawDepreciation, function_notation: drawFunctionNotation,
                    "function_limit_concept": drawFunctionLimitConcept, domain_approach: drawDomainApproach, population: drawPopulationGrowth,
                    function_infinity: drawFunctionInfinity, one_over_x: drawOneOverX, arctan: drawArctan,
                    shadow: drawShadowAnimation, point_limit: drawPointLimit, velocity: drawVelocity,
                    left_right: drawLeftRightLimits, left_limit_viz: drawLeftLimitViz, right_limit_viz: drawRightLimitViz, limit_convergence_viz: drawLimitConvergenceViz, piecewise1: drawPiecewise1, piecewise2: drawPiecewise2,
                    infinitesimal: drawInfinitesimalConcept, infinitesimal_prop: drawInfinitesimalProperties,
                    infinite: drawInfiniteConcept, limit_properties: drawLimitProperties, limit_rules: drawLimitRules,
                    direct_sub: drawDirectSubstitution, zero_zero: drawZeroOverZero, rationalize: drawRationalization,
                    infinity_infinity: drawInfinityOverInfinity, sinx_x: drawSinXOverX, e_limit: drawELimit,
                    infinitesimal_compare: drawInfinitesimalComparison, "equivalent_infinitesimal": drawEquivalentInfinitesimal,
                    continuity_concept: drawContinuityConcept, continuity_def: drawContinuityDefinition,
                    ice_melting: drawIceMelting, discontinuity: drawDiscontinuityTypes,
                    first_discontinuity: drawFirstDiscontinuity, second_discontinuity: drawSecondDiscontinuity,
                    elementary_continuity: drawElementaryContinuity, exercise1: drawExercise1, exercise2: drawExercise2,
                    summary: drawSummaryAnimation
                };

                const animationFunction = animationMap[animationType] || drawDefaultAnimation;
                animationFunction(ctx, canvas);
            } catch (error) {
                console.error(`Error in drawAnimation for slide ${slideNum}:`, error);
                // Fallback to default animation
                const canvas = document.getElementById(`canvas${slideNum}`);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    if (ctx) drawDefaultAnimation(ctx, canvas);
                }
            }
        }

        // --- 所有动画绘制函数 ---
        
        function drawTitleAnimation(ctx, canvas) { 
            let angle = 0; 
            function animate() { 
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                ctx.save(); 
                ctx.translate(canvas.width / 2, canvas.height / 2); 
                for (let i = 0; i < 5; i++) { 
                    ctx.beginPath(); 
                    ctx.strokeStyle = `hsla(${i * 60 + angle * 100}, 80%, 60%, 0.7)`; 
                    ctx.lineWidth = 3; 
                    const radius = 50 + i * 20; 
                    ctx.arc(0, 0, radius, angle + i * 0.5, angle + i * 0.5 + Math.PI * 1.5); 
                    ctx.stroke(); 
                } 
                ctx.restore(); 
                ctx.font = 'bold 36px Arial'; 
                ctx.fillStyle = '#2c3e50'; 
                ctx.textAlign = 'center'; 
                ctx.fillText('极限与连续', canvas.width / 2, canvas.height / 2 - 20); 
                ctx.font = '20px Arial'; 
                ctx.fillText('微积分的基础', canvas.width / 2, canvas.height / 2 + 30); 
                angle += 0.01; 
                animationFrameId = requestAnimationFrame(animate); 
            } 
            animate(); 
        }

        function drawSequenceAnimation(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' }); 
            ctx.fillStyle = '#3498db'; 
            let n = 1; 
            function animate() { 
                if (n > 15) { 
                    // Draw limit line after points are drawn
                    const limitY = canvas.height - 50 - 1 * (canvas.height - 100); 
                    ctx.strokeStyle = '#e74c3c'; 
                    ctx.setLineDash([5, 5]); 
                    ctx.beginPath(); 
                    ctx.moveTo(50, limitY); 
                    ctx.lineTo(canvas.width - 50, limitY); 
                    ctx.stroke(); 
                    ctx.setLineDash([]); 
                    ctx.fillStyle = '#e74c3c'; 
                    ctx.font = '14px Arial'; 
                    ctx.fillText('极限 a = 1', canvas.width - 90, limitY - 5); 
                    return; 
                } 
                const x_coord = 50 + n * 30; 
                const y_val = n / (n + 1); 
                const y_coord = canvas.height - 50 - y_val * (canvas.height - 100); 
                ctx.beginPath(); 
                ctx.arc(x_coord, y_coord, 4, 0, 2 * Math.PI); 
                ctx.fill(); 
                ctx.font = '10px Arial'; 
                ctx.textAlign = 'center'; 
                ctx.fillText(n, x_coord, canvas.height - 35); 
                n++; 
                animationFrameId = setTimeout(animate, 100); 
            } 
            animate(); 
        }

        function drawQueueVisualization(ctx, canvas) { 
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            for (let i = 0; i < 5; i++) { 
                const x = 80 + i * 100; 
                const y = 200; 
                ctx.fillStyle = '#3498db'; 
                ctx.beginPath(); 
                ctx.arc(x, y - 20, 20, 0, 2 * Math.PI); 
                ctx.fill(); 
                ctx.fillRect(x - 20, y, 40, 50); 
                ctx.fillStyle = '#fff'; 
                ctx.font = 'bold 18px Arial'; 
                ctx.textAlign = 'center'; 
                ctx.fillText(i + 1, x, y - 15); 
                ctx.fillStyle = '#2c3e50'; 
                ctx.font = '14px Arial'; 
                ctx.fillText(`x_${i + 1}`, x, y + 80); 
            } 
            drawArrow(ctx, 550, 220, 600, 220, '#e74c3c', 3); 
            ctx.font = '20px Arial'; 
            ctx.fillText('...', 575, 225); 
        }

        function drawLimitConcept(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            ctx.fillStyle = '#3498db'; 
            for (let n = 1; n <= 30; n++) { 
                const x = 50 + n * 15; 
                const y = canvas.height / 2 + (1 / n) * 100 * (n % 2 === 0 ? 1 : -1); 
                ctx.beginPath(); 
                ctx.arc(x, y, 2, 0, 2 * Math.PI); 
                ctx.fill(); 
            } 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.setLineDash([5, 5]); 
            ctx.beginPath(); 
            ctx.moveTo(50, canvas.height / 2); 
            ctx.lineTo(canvas.width - 50, canvas.height / 2); 
            ctx.stroke(); 
            ctx.setLineDash([]); 
        }

        function drawTargetAnimation(ctx, canvas) { 
            let points = Array.from({length: 20}, () => ({
                angle: Math.random() * 2 * Math.PI, 
                radius: 20 + Math.random() * 150, 
                speed: 0.5 + Math.random()
            })); 
            function animate() { 
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                const centerX = canvas.width / 2; 
                const centerY = canvas.height / 2; 
                for (let r = 150; r > 0; r -= 30) { 
                    ctx.beginPath(); 
                    ctx.strokeStyle = (r / 30 % 2 === 1) ? '#e74c3c' : '#3498db'; 
                    ctx.lineWidth = 15; 
                    ctx.arc(centerX, centerY, r, 0, 2 * Math.PI); 
                    ctx.stroke(); 
                } 
                ctx.fillStyle = '#2c3e50'; 
                points.forEach(p => { 
                    p.radius -= p.speed; 
                    if (p.radius < 5) p.radius = 170; 
                    const x = centerX + Math.cos(p.angle) * p.radius; 
                    const y = centerY + Math.sin(p.angle) * p.radius; 
                    ctx.beginPath(); 
                    ctx.arc(x, y, 3, 0, 2 * Math.PI); 
                    ctx.fill(); 
                }); 
                animationFrameId = requestAnimationFrame(animate); 
            } 
            animate(); 
        }

        function drawConvergenceDivergence(ctx, canvas) { 
            ctx.save(); 
            drawCoordinateSystem(ctx, { width: canvas.width / 2, height: canvas.height }); 
            ctx.fillStyle = '#2ecc71'; 
            for (let n = 1; n < 20; n++) { 
                const x = 20 + n * 12; 
                const y = canvas.height / 2 + (1 / n) * 80 * (n % 2 === 0 ? 1 : -1); 
                ctx.beginPath(); 
                ctx.arc(x, y, 2, 0, 2 * Math.PI); 
                ctx.fill(); 
            } 
            ctx.font = 'bold 16px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.fillText('收敛', canvas.width / 4, 40); 
            ctx.restore(); 
            ctx.save(); 
            ctx.translate(canvas.width / 2, 0); 
            drawCoordinateSystem(ctx, { width: canvas.width / 2, height: canvas.height }); 
            ctx.fillStyle = '#e74c3c'; 
            for (let n = 1; n < 15; n++) { 
                const x = 20 + n * 15; 
                const y = canvas.height / 2 + Math.sin(n) * 80; 
                ctx.beginPath(); 
                ctx.arc(x, y, 2, 0, 2 * Math.PI); 
                ctx.fill(); 
            } 
            ctx.font = 'bold 16px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.fillText('发散', canvas.width / 4, 40); 
            ctx.restore(); 
        }

        function drawCollatzSequence(ctx, canvas) { 
            let n = 27; 
            const sequence = [n]; 
            while (n !== 1 && sequence.length < 50) { 
                n = (n % 2 === 0) ? n / 2 : 3 * n + 1; 
                sequence.push(n); 
            } 
            drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' }); 
            ctx.strokeStyle = '#9b59b6'; 
            ctx.lineWidth = 1.5; 
            ctx.beginPath(); 
            sequence.forEach((val, i) => { 
                const x = 50 + i * 10; 
                const y = canvas.height - 50 - Math.min(val * 2, canvas.height - 100); 
                if (i === 0) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
            }); 
            ctx.stroke(); 
        }

        function drawFibonacciRatio(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' }); 
            let a = 1, b = 1; 
            ctx.strokeStyle = '#f39c12'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for (let i = 0; i < 15; i++) { 
                const ratio = b / a; 
                const x = 50 + i * 35; 
                const y = canvas.height - 50 - ratio * 100; 
                if (i === 0) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
                const temp = b; 
                b = a + b; 
                a = temp; 
            } 
            ctx.stroke(); 
            const phi = 1.618; 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.setLineDash([5, 5]); 
            const phiY = canvas.height - 50 - phi * 100; 
            ctx.moveTo(50, phiY); 
            ctx.lineTo(canvas.width - 50, phiY); 
            ctx.stroke(); 
            ctx.setLineDash([]); 
        }

        function drawExample1_2(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' }); 
            ctx.fillStyle = '#e74c3c'; 
            for (let n = 1; n <= 20; n++) { 
                const x = 50 + n * 25; 
                const val = (1 + Math.pow(-1, n)) / 2; 
                const y = canvas.height - 50 - val * 200; 
                ctx.beginPath(); 
                ctx.arc(x, y, 4, 0, 2 * Math.PI); 
                ctx.fill(); 
            } 
        }

        function drawExample1_3(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            ctx.fillStyle = '#2ecc71'; 
            for (let n = 1; n <= 10; n++) { 
                const x = 50 + n * 50; 
                const val = 1 / Math.pow(-3, n); 
                const y = canvas.height / 2 - val * 500; 
                ctx.beginPath(); 
                ctx.arc(x, y, 3, 0, 2 * Math.PI); 
                ctx.fill(); 
            } 
        }

        function drawExample1_4(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            const y_coord = canvas.height / 2 - 80; 
            ctx.strokeStyle = '#9b59b6'; 
            ctx.lineWidth = 3; 
            ctx.beginPath(); 
            ctx.moveTo(50, y_coord); 
            ctx.lineTo(canvas.width - 50, y_coord); 
            ctx.stroke(); 
        }

        function drawDepreciation(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' }); 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for (let n = 0; n <= 40; n++) { 
                const val = 100 * Math.pow(0.9, n); 
                const x = 50 + n * 12; 
                const y = canvas.height - 50 - val * 3; 
                if (n === 0) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
            } 
            ctx.stroke(); 
        }

        function drawFunctionNotation(ctx, canvas) { 
            ctx.font = '20px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.fillText('函数的各种趋近方式', canvas.width / 2, 50); 
            drawCoordinateSystem(ctx, canvas); 
            ctx.fillStyle = '#3498db'; 
            // x -> +inf
            drawArrow(ctx, 400, canvas.height/2, 550, canvas.height/2); 
            // x -> x0-
            drawArrow(ctx, 150, canvas.height/2 + 50, 290, canvas.height/2 + 5); 
            // x -> x0+
            drawArrow(ctx, 450, canvas.height/2 - 50, 310, canvas.height/2 - 5); 
        }

        function drawFunctionLimitConcept(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for(let x_val = -3; x_val <= 3; x_val += 0.1) { 
                const x = canvas.width/2 + x_val * 80; 
                const y = canvas.height/2 - (1/(x_val*x_val + 1)) * 150; 
                if(x_val===-3) ctx.moveTo(x, y); 
                else ctx.lineTo(x,y); 
            } 
            ctx.stroke(); 
        }

        function drawPopulationGrowth(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' }); 
            ctx.strokeStyle = '#2ecc71'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for (let t = 0; t <= 50; t++) { 
                const K = 250; 
                const x = 50 + t * 10; 
                const y = canvas.height - 50 - (K / (1 + 24 * Math.exp(-0.1 * t))); 
                if (t === 0) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
            } 
            ctx.stroke(); 
            const limitY = canvas.height - 50 - 250; 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.setLineDash([5, 5]); 
            ctx.moveTo(50, limitY); 
            ctx.lineTo(canvas.width - 50, limitY); 
            ctx.stroke(); 
            ctx.setLineDash([]); 
        }

        function drawFunctionInfinity(ctx, canvas) { 
            drawArctan(ctx, canvas); 
        }

        function drawOneOverX(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for (let x_val = 0.1; x_val <= 5; x_val += 0.05) { 
                const x = canvas.width / 2 + x_val * 50; 
                const y = canvas.height / 2 - (1 / x_val) * 50; 
                if (x_val === 0.1) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
            } 
            ctx.stroke(); 
            ctx.beginPath(); 
            for (let x_val = -5; x_val <= -0.1; x_val += 0.05) { 
                const x = canvas.width / 2 + x_val * 50; 
                const y = canvas.height / 2 - (1 / x_val) * 50; 
                if (x_val === -5) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
            } 
            ctx.stroke(); 
        }

        function drawArctan(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            ctx.strokeStyle = '#9b59b6'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for (let x_val = -10; x_val <= 10; x_val += 0.1) { 
                const x = canvas.width / 2 + x_val * 25; 
                const y = canvas.height / 2 - Math.atan(x_val) * 80; 
                if (x_val === -10) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
            } 
            ctx.stroke(); 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.setLineDash([5, 5]); 
            const y_plus = canvas.height / 2 - (Math.PI / 2) * 80; 
            const y_minus = canvas.height / 2 + (Math.PI / 2) * 80; 
            ctx.moveTo(50, y_plus); 
            ctx.lineTo(canvas.width - 50, y_plus); 
            ctx.stroke(); 
            ctx.moveTo(50, y_minus); 
            ctx.lineTo(canvas.width - 50, y_minus); 
            ctx.stroke(); 
            ctx.setLineDash([]); 
        }

        function drawShadowAnimation(ctx, canvas) { 
            let personX = 100; 
            function animate() { 
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                const lightX = canvas.width / 2; 
                const lightY = 50; 
                const personHeight = 80; 
                const groundY = 350; 
                ctx.fillStyle = '#f39c12'; 
                ctx.beginPath(); 
                ctx.arc(lightX, lightY, 15, 0, 2*Math.PI); 
                ctx.fill(); 
                ctx.fillStyle = '#3498db'; 
                ctx.fillRect(personX - 10, groundY - personHeight, 20, personHeight); 
                const shadowEndX = lightX - (lightX - personX) * (lightY / (lightY - (groundY-personHeight))); 
                ctx.strokeStyle = '#7f8c8d'; 
                ctx.setLineDash([3,3]); 
                ctx.beginPath(); 
                ctx.moveTo(lightX, lightY); 
                ctx.lineTo(personX, groundY - personHeight); 
                ctx.stroke(); 
                ctx.setLineDash([]); 
                ctx.fillStyle = 'rgba(0,0,0,0.4)'; 
                ctx.beginPath(); 
                ctx.ellipse( (personX + shadowEndX) / 2, groundY, Math.abs(personX - shadowEndX)/2, 5, 0, 0, 2*Math.PI); 
                ctx.fill(); 
                personX += 0.5; 
                if(personX > canvas.width - 50) personX = 50; 
                animationFrameId = requestAnimationFrame(animate); 
            } 
            animate(); 
        }

        function drawPointLimit(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            const x0 = canvas.width / 2; 
            const y0 = canvas.height / 2 - 80; 
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for (let x_val = -2.5; x_val <= 2.5; x_val += 0.1) { 
                const x = x0 + x_val * 80; 
                const y = y0 - (x_val * x_val - 1) * 30; 
                if (Math.abs(x_val) > 0.1) { 
                    if (x_val === -2.5) ctx.moveTo(x, y); 
                    else ctx.lineTo(x, y); 
                } 
            } 
            ctx.stroke(); 
            ctx.beginPath(); 
            ctx.arc(x0, y0 + 30, 5, 0, 2 * Math.PI); 
            ctx.fillStyle = 'white'; 
            ctx.fill(); 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.stroke(); 
        }

        function drawVelocity(ctx, canvas) { 
            let t=0; 
            function animate() { 
                ctx.clearRect(0,0,canvas.width, canvas.height); 
                const g = 9.8; 
                const y = 50 + 0.5 * g * t*t * 10; 
                if (y > canvas.height - 20) t=0; 
                ctx.fillStyle = '#3498db'; 
                ctx.beginPath(); 
                ctx.arc(canvas.width/2, y, 20, 0, 2*Math.PI); 
                ctx.fill(); 
                t += 0.05; 
                animationFrameId = requestAnimationFrame(animate); 
            } 
            animate(); 
        }

        function drawLeftRightLimits(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            const x0 = canvas.width/2; 
            const y0 = canvas.height/2; 
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth=2; 
            ctx.beginPath(); 
            ctx.moveTo(50, y0+50); 
            ctx.lineTo(x0, y0+20); 
            ctx.stroke(); 
            ctx.strokeStyle = '#2ecc71'; 
            ctx.beginPath(); 
            ctx.moveTo(x0, y0-20); 
            ctx.lineTo(canvas.width-50, y0-50); 
            ctx.stroke(); 
            ctx.beginPath(); 
            ctx.arc(x0, y0+20, 5, 0, 2*Math.PI); 
            ctx.stroke(); 
            ctx.beginPath(); 
            ctx.arc(x0, y0-20, 5, 0, 2*Math.PI); 
            ctx.stroke(); 
        }

        function drawPiecewise1(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas, {x_origin: 100}); 
            const x1 = 100 + 1 * 50; 
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth=2; 
            ctx.beginPath(); 
            ctx.moveTo(100 - 2*50, 300); 
            ctx.lineTo(x1, 150); 
            ctx.stroke(); 
            ctx.strokeStyle = '#2ecc71'; 
            ctx.beginPath(); 
            ctx.moveTo(x1, 150); 
            ctx.lineTo(100+5*50, 50); 
            ctx.stroke(); 
            ctx.fillStyle='#e74c3c'; 
            ctx.beginPath(); 
            ctx.arc(x1, 150, 5, 0, 2*Math.PI); 
            ctx.fill(); 
        }

        function drawPiecewise2(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            const x0 = canvas.width/2; 
            const y0 = canvas.height/2; 
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth=2; 
            ctx.beginPath(); 
            ctx.moveTo(x0 - 100, y0+50); 
            ctx.lineTo(x0, y0); 
            ctx.stroke(); 
            ctx.strokeStyle = '#2ecc71'; 
            ctx.beginPath(); 
            ctx.moveTo(x0, y0); 
            ctx.quadraticCurveTo(x0+50, y0-20, x0+100, y0-100); 
            ctx.stroke(); 
            ctx.beginPath(); 
            ctx.arc(x0, y0, 5, 0, 2*Math.PI); 
            ctx.fillStyle='white'; 
            ctx.fill(); 
            ctx.stroke(); 
        }

        function drawInfinitesimalConcept(ctx, canvas) { 
            let scale = 1; 
            function animate() { 
                ctx.clearRect(0,0,canvas.width,canvas.height); 
                drawCoordinateSystem(ctx, canvas); 
                ctx.strokeStyle = '#3498db'; 
                ctx.lineWidth=2; 
                ctx.beginPath(); 
                for(let x_val=-3; x_val<=3; x_val+=0.1){
                    const x = canvas.width/2 + x_val*80; 
                    const y = canvas.height/2 - Math.exp(-x_val*x_val)*100*scale; 
                    if(x_val===-3)ctx.moveTo(x,y); 
                    else ctx.lineTo(x,y);
                } 
                ctx.stroke(); 
                scale *= 0.99; 
                if(scale < 0.01) scale = 1; 
                animationFrameId=requestAnimationFrame(animate);
            } 
            animate(); 
        }

        function drawInfinitesimalProperties(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas);
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 1.5;
            
            // 绘制 1/x (无穷小)
            ctx.beginPath();
            for(let x_val = 0.1; x_val <= 5; x_val += 0.05) {
                const x = canvas.width/2 + x_val * 60;
                const y = canvas.height/2 - (1/x_val) * 20;
                if(x_val === 0.1) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // 绘制 cos(x) (有界函数)
            ctx.strokeStyle = '#e74c3c';
            ctx.beginPath();
            for(let x_val = 0.1; x_val <= 5; x_val += 0.05) {
                const x = canvas.width/2 + x_val * 60;
                const y = canvas.height/2 - Math.cos(x_val) * 30;
                if(x_val === 0.1) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // 绘制乘积 (1/x)*cos(x)
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let x_val = 0.1; x_val <= 5; x_val += 0.05) {
                const x = canvas.width/2 + x_val * 60;
                const y = canvas.height/2 - (Math.cos(x_val)/x_val) * 20;
                if(x_val === 0.1) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawInfiniteConcept(ctx, canvas) { 
            drawOneOverX(ctx, canvas); 
        }

        function drawLimitProperties(ctx, canvas) { 
            const props=['唯一性', '有界性', '保号性']; 
            props.forEach((p, i) => { 
                ctx.fillStyle = `hsl(${i*120}, 70%, 50%)`; 
                ctx.fillRect(50 + i*180, 150, 150, 100); 
                ctx.fillStyle='white'; 
                ctx.font='20px Arial'; 
                ctx.textAlign='center'; 
                ctx.fillText(p, 125+i*180, 205); 
            }); 
        }

        function drawLimitRules(ctx, canvas) { 
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#2c3e50';
            
            // 绘制运算法则图示
            ctx.fillText('lim[f(x) ± g(x)] = A ± B', canvas.width/2, 120);
            ctx.fillText('lim[f(x) · g(x)] = A · B', canvas.width/2, 180);
            ctx.fillText('lim[f(x)/g(x)] = A/B (B≠0)', canvas.width/2, 240);
            
            // 绘制示意图
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            drawArrow(ctx, 150, 300, 200, 300);
            ctx.fillText('A', 175, 330);
            
            ctx.strokeStyle = '#e74c3c';
            drawArrow(ctx, 300, 300, 350, 300);
            ctx.fillText('B', 325, 330);
            
            ctx.strokeStyle = '#2ecc71';
            drawArrow(ctx, 450, 300, 500, 300);
            ctx.fillText('A◦B', 475, 330);
        }

        function drawDirectSubstitution(ctx, canvas) { 
            ctx.font = '28px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#2c3e50';
            
            ctx.fillText('直接代入法', canvas.width/2, 80);
            
            // 示例
            ctx.font = '20px Arial';
            ctx.fillText('如果 f(x) 在 x₀ 处连续', canvas.width/2, 140);
            ctx.fillText('则 lim f(x) = f(x₀)', canvas.width/2, 180);
            ctx.fillText('x→x₀', canvas.width/2, 200);
            
            // 绘制连续函数图像
            drawCoordinateSystem(ctx, canvas);
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for(let x = -3; x <= 3; x += 0.1) {
                const canvasX = canvas.width/2 + x * 60;
                const canvasY = canvas.height/2 - (x*x - 1) * 20;
                if(x === -3) ctx.moveTo(canvasX, canvasY);
                else ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
            
            // 标记点
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(canvas.width/2, canvas.height/2 + 20, 6, 0, 2*Math.PI);
            ctx.fill();
        }

        function drawZeroOverZero(ctx, canvas) { 
            let pos = 0; 
            let dir = 1; 
            function animate(){ 
                ctx.clearRect(0,0,canvas.width,canvas.height); 
                ctx.fillStyle='#3498db'; 
                ctx.font='40px Arial'; 
                ctx.textAlign='center'; 
                ctx.fillText('分子 → 0', 150, 200); 
                ctx.fillStyle='#e74c3c'; 
                ctx.fillText('分母 → 0', 450, 200); 
                ctx.font='80px Arial'; 
                ctx.fillStyle='#9b59b6'; 
                ctx.fillText('?', canvas.width/2, 200 + pos); 
                pos += dir; 
                if(pos > 20 || pos < -20) dir *= -1; 
                animationFrameId = requestAnimationFrame(animate); 
            } 
            animate(); 
        }

        function drawRationalization(ctx, canvas) { 
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#2c3e50';
            
            ctx.fillText('有理化方法', canvas.width/2, 80);
            
            // 展示有理化过程
            ctx.font = '18px Arial';
            ctx.fillText('√(a) - √(b)', canvas.width/2, 140);
            ctx.fillText('×', canvas.width/2, 180);
            ctx.fillText('√(a) + √(b)', canvas.width/2, 220);
            ctx.fillText('= a - b', canvas.width/2, 280);
            
            // 绘制乘法符号
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2 - 20, 160);
            ctx.lineTo(canvas.width/2 + 20, 200);
            ctx.moveTo(canvas.width/2 + 20, 160);
            ctx.lineTo(canvas.width/2 - 20, 200);
            ctx.stroke();
            
            // 绘制下划线
            ctx.beginPath();
            ctx.moveTo(canvas.width/2 - 80, 240);
            ctx.lineTo(canvas.width/2 + 80, 240);
            ctx.stroke();
        }

        function drawInfinityOverInfinity(ctx, canvas) { 
            let t=0; 
            function animate(){ 
                ctx.clearRect(0,0,canvas.width,canvas.height); 
                ctx.fillStyle='#3498db'; 
                ctx.fillRect(50, 150, 50+t*5, 30); 
                ctx.fillText('x²', 20, 170); 
                ctx.fillStyle='#2ecc71'; 
                ctx.fillRect(50, 250, 50+t*2, 30); 
                ctx.fillText('x', 20, 270); 
                
                // 添加说明文字
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#2c3e50';
                ctx.fillText('最高次项的增长比较', canvas.width/2, 100);
                
                t+=0.5; 
                if(50+t*5 > canvas.width) t=0; 
                animationFrameId=requestAnimationFrame(animate); 
            } 
            animate(); 
        }

        function drawSinXOverX(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for (let x_val = -10; x_val <= 10; x_val += 0.1) { 
                const x = canvas.width / 2 + x_val * 25; 
                const y_val = x_val === 0 ? 1 : Math.sin(x_val) / x_val; 
                const y = canvas.height / 2 - y_val * 100; 
                if (x_val === -10) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
            } 
            ctx.stroke(); 
            ctx.beginPath(); 
            ctx.arc(canvas.width / 2, canvas.height / 2 - 100, 5, 0, 2 * Math.PI); 
            ctx.fillStyle = 'white'; 
            ctx.fill(); 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.stroke(); 
        }

        function drawELimit(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            ctx.strokeStyle = '#2ecc71'; 
            ctx.beginPath(); 
            for (let x_val = 1; x_val < 50; x_val++) { 
                const y_val = Math.pow(1 + 1 / x_val, x_val); 
                const x = 50 + x_val * 10; 
                const y = canvas.height - 50 - (y_val - 2) * 200; 
                if (x_val === 1) ctx.moveTo(x, y); 
                else ctx.lineTo(x, y); 
            } 
            ctx.stroke(); 
            const e_y = canvas.height - 50 - (Math.E - 2) * 200; 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.setLineDash([5, 5]); 
            ctx.moveTo(50, e_y); 
            ctx.lineTo(canvas.width - 50, e_y); 
            ctx.stroke(); 
            ctx.setLineDash([]); 
        }

        function drawInfinitesimalComparison(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            const funcs = [
                {f:x=>x, c:'#3498db', name:'x'}, 
                {f:x=>x*x, c:'#2ecc71', name:'x²'}, 
                {f:x=>x*x*x, c:'#e74c3c', name:'x³'}
            ]; 
            funcs.forEach((fn, i) => { 
                ctx.strokeStyle = fn.c; 
                ctx.lineWidth = 2; 
                ctx.beginPath(); 
                for(let x_val = -2; x_val <= 2; x_val+=0.05){
                    const x=canvas.width/2+x_val*80; 
                    const y=canvas.height/2-fn.f(x_val)*40; 
                    if(x_val===-2)ctx.moveTo(x,y); 
                    else ctx.lineTo(x,y);
                } 
                ctx.stroke(); 
                
                // 添加标签
                ctx.fillStyle = fn.c;
                ctx.font = '16px Arial';
                ctx.fillText(fn.name, 50 + i*60, 50);
            }); 
        }

        function drawEquivalentInfinitesimal(ctx, canvas) { 
            drawCoordinateSystem(ctx, canvas); 
            ctx.strokeStyle = '#3498db'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            for(let x_val=-2;x_val<=2;x_val+=0.05){
                const x=canvas.width/2+x_val*80;
                const y=canvas.height/2-Math.sin(x_val)*80;
                if(x_val===-2)ctx.moveTo(x,y);
                else ctx.lineTo(x,y);
            } 
            ctx.stroke(); 
            ctx.strokeStyle = '#e74c3c'; 
            ctx.setLineDash([5,5]); 
            ctx.beginPath(); 
            ctx.moveTo(canvas.width/2-160, canvas.height/2+160); 
            ctx.lineTo(canvas.width/2+160, canvas.height/2-160); 
            ctx.stroke(); 
            ctx.setLineDash([]); 
            
            // 添加标签
            ctx.font = '16px Arial';
            ctx.fillStyle = '#3498db';
            ctx.fillText('sin(x)', 50, 50);
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('x', 50, 80);
        }

        function drawContinuityConcept(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas);
            let x = 100;
            let y = 250;
            function animate(){
                ctx.clearRect(0,0,canvas.width,canvas.height);
                drawCoordinateSystem(ctx, canvas);
                ctx.strokeStyle='#3498db';
                ctx.lineWidth=2;
                ctx.beginPath();
                ctx.moveTo(50, 300);
                ctx.quadraticCurveTo(300, 100, 550, 300);
                ctx.stroke();
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                const cur_y = 300 - 0.0025 * (x-300)*(x-300);
                ctx.arc(x, cur_y, 5, 0, 2*Math.PI);
                ctx.fill();
                x += 1;
                if(x > 550) x=50;
                animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function drawContinuityDefinition(ctx, canvas) {
            drawContinuityConcept(ctx, canvas);
        }

        function drawIceMelting(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas, {x_origin: 100});
            const x0=100;
            const y0=canvas.height/2;
            ctx.strokeStyle='#3498db';
            ctx.lineWidth=2;
            ctx.beginPath();
            ctx.moveTo(50, y0+50);
            ctx.lineTo(x0, y0);
            ctx.stroke();
            ctx.strokeStyle='#e74c3c';
            ctx.beginPath();
            ctx.moveTo(x0, y0-80);
            ctx.lineTo(550, y0-120);
            ctx.stroke();
        }

        function drawDiscontinuityTypes(ctx, canvas) {
            drawFirstDiscontinuity(ctx, canvas);
        }

        function drawFirstDiscontinuity(ctx, canvas) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const x0 = canvas.width / 2;
            const y_rem = canvas.height / 4;
            const y_jump = canvas.height * 3 / 4;
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, y_rem);
            ctx.lineTo(x0 - 5, y_rem);
            ctx.moveTo(x0 + 5, y_rem);
            ctx.lineTo(canvas.width - 50, y_rem);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x0, y_rem, 4, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.font = '14px Arial';
            ctx.fillText('可去间断点', x0, y_rem + 20);
            ctx.beginPath();
            ctx.moveTo(50, y_jump + 20);
            ctx.lineTo(x0, y_jump + 20);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x0, y_jump - 20);
            ctx.lineTo(canvas.width - 50, y_jump - 20);
            ctx.stroke();
            ctx.fillText('跳跃间断点', x0, y_jump + 40);
        }

        function drawSecondDiscontinuity(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas);
            const x0 = canvas.width / 2;
            ctx.strokeStyle = '#e74c3c';
            ctx.setLineDash([5, 5]);
            ctx.moveTo(x0, 0);
            ctx.lineTo(x0, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for(let x_val=0.1; x_val<=3; x_val+=0.05){
                const x=x0+x_val*50;
                const y=canvas.height/2- (1/x_val)*50;
                if(x_val===0.1)ctx.moveTo(x,y);
                else ctx.lineTo(x,y);
            }
            ctx.stroke();
        }

        function drawElementaryContinuity(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
        }

        function drawExercise1(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
        }

        function drawExercise2(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
        }

        function drawSummaryAnimation(ctx, canvas) {
            let t = 0;
            const icons = ['🎯', '📈', '🤏', '🔑'];
            function animate() {
                t += 0.01;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.font = '100px sans-serif';
                ctx.textAlign = 'center';
                const iconIndex = Math.floor(t) % icons.length;
                const scale = 1 + 0.1 * Math.sin(t * 5);
                ctx.scale(scale, scale);
                ctx.fillText(icons[iconIndex], 0, 0);
                ctx.restore();
                animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }
        function drawViewShift(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(80, 120, 160, 160);
            ctx.fillStyle = '#ffffff';
            ctx.font = '20px Microsoft YaHei';
            ctx.textAlign = 'center';
            ctx.fillText('高中', 160, 200);
            ctx.fillStyle = '#10b981';
            ctx.fillRect(canvas.width - 240, 120, 160, 160);
            ctx.fillStyle = '#ffffff';
            ctx.fillText('大学', canvas.width - 160, 200);
        }

        function drawTerminalBehaviors(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
            ctx.strokeStyle = '#10b981';
            ctx.beginPath();
            for (let n = 1; n <= 10; n++) {
                const x = 60 + n * 40;
                const y = canvas.height - 80 - (1 - 1 / n) * 150;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            for (let n = 1; n <= 10; n++) {
                const x = 60 + n * 40;
                const y = canvas.height - 80 - (n / 10) * 200;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.strokeStyle = '#f59e0b';
            ctx.beginPath();
            for (let n = 1; n <= 10; n++) {
                const x = 60 + n * 40;
                const y = canvas.height / 2 - Math.sin(n) * 80;
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawSequenceFunction(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' });
            ctx.fillStyle = '#6366f1';
            for (let n = 1; n <= 8; n++) {
                const x = 60 + n * 60;
                const y = canvas.height - 80 - (n / (n + 1)) * 180;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawDomainApproach(ctx, canvas) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(60, canvas.height / 3);
            ctx.lineTo(canvas.width - 60, canvas.height / 3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(60, (canvas.height * 2) / 3);
            ctx.lineTo(canvas.width - 60, (canvas.height * 2) / 3);
            ctx.stroke();
            ctx.fillStyle = '#1d4ed8';
            ctx.font = '18px Microsoft YaHei';
            ctx.fillText('n = 1,2,3,... → 只往右', canvas.width / 2, canvas.height / 3 - 20);
            ctx.fillText('x ∈ ℝ → 左、右、±∞', canvas.width / 2, (canvas.height * 2) / 3 - 20);
        }

        function drawLeftLimitViz(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas);
            ctx.strokeStyle = '#3b82f6';
            ctx.beginPath();
            ctx.moveTo(60, canvas.height / 2);
            ctx.lineTo(canvas.width / 2, canvas.height / 2);
            ctx.stroke();
            drawArrow(ctx, canvas.width / 2 - 80, canvas.height / 2 - 40, canvas.width / 2 - 10, canvas.height / 2);
        }

        function drawRightLimitViz(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas);
            ctx.strokeStyle = '#10b981';
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, canvas.height / 2);
            ctx.lineTo(canvas.width - 60, canvas.height / 2);
            ctx.stroke();
            drawArrow(ctx, canvas.width / 2 + 80, canvas.height / 2 - 40, canvas.width / 2 + 10, canvas.height / 2);
        }

        function drawLimitConvergenceViz(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas);
            drawArrow(ctx, 80, canvas.height / 2 - 40, canvas.width / 2 - 10, canvas.height / 2, '#3b82f6');
            drawArrow(ctx, canvas.width - 80, canvas.height / 2 + 40, canvas.width / 2 + 10, canvas.height / 2, '#10b981');
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 6, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawInfinitesimalFramework(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
            ctx.fillStyle = '#2563eb';
            ctx.font = '18px Microsoft YaHei';
            ctx.fillText('比较 lim β/α → 分类', canvas.width / 2, canvas.height / 2);
        }

        function drawHigherInfinitesimal(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas);
            ctx.strokeStyle = '#2563eb';
            ctx.beginPath();
            for (let x = -2; x <= 2; x += 0.05) {
                const canvasX = canvas.width / 2 + x * 80;
                const canvasY = canvas.height / 2 - (x * x) * 60;
                if (x === -2) ctx.moveTo(canvasX, canvasY);
                else ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
            ctx.strokeStyle = '#94a3b8';
            ctx.beginPath();
            for (let x = -2; x <= 2; x += 0.05) {
                const canvasX = canvas.width / 2 + x * 80;
                const canvasY = canvas.height / 2 - x * 60;
                if (x === -2) ctx.moveTo(canvasX, canvasY);
                else ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
        }

        function drawLowerInfinitesimal(ctx, canvas) {
            drawHigherInfinitesimal(ctx, canvas);
        }

        function drawSameOrderInfinitesimal(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas);
            ctx.strokeStyle = '#2563eb';
            ctx.beginPath();
            for (let x = -2; x <= 2; x += 0.05) {
                const canvasX = canvas.width / 2 + x * 80;
                const canvasY = canvas.height / 2 - x * 60;
                if (x === -2) ctx.moveTo(canvasX, canvasY);
                else ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
            ctx.strokeStyle = '#16a34a';
            ctx.beginPath();
            for (let x = -2; x <= 2; x += 0.05) {
                const canvasX = canvas.width / 2 + x * 80;
                const canvasY = canvas.height / 2 - (0.5 * x) * 60;
                if (x === -2) ctx.moveTo(canvasX, canvasY);
                else ctx.lineTo(canvasX, canvasY);
            }
            ctx.stroke();
        }

        function drawContinuityIntro(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
            ctx.fillStyle = '#14b8a6';
            ctx.font = '20px Microsoft YaHei';
            ctx.textAlign = 'center';
            ctx.fillText('直接代入法成立 ← 函数在点上够“平滑”', canvas.width / 2, canvas.height / 2);
        }

        function drawContinuityThree(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
            ctx.fillStyle = '#2563eb';
            ctx.font = '18px Microsoft YaHei';
            ctx.fillText('① 函数值存在  ② 极限存在  ③ 极限=函数值', canvas.width / 2, canvas.height / 2);
        }

        function drawDiscontinuityDiagnose(ctx, canvas) {
            drawDefaultAnimation(ctx, canvas);
            ctx.fillStyle = '#ef4444';
            ctx.font = '18px Microsoft YaHei';
            ctx.fillText('可去 · 跳跃 · 无穷 —— 找出缺失条件', canvas.width / 2, canvas.height / 2);
        }
        // 辅助函数
        function drawCoordinateSystem(ctx, canvas, options = {}) {
            const width = canvas.width;
            const height = canvas.height;
            const mode = options.mode || (options.center ? 'center' : 'center');
            const padding = options.padding ?? 50;
            const axisColor = options.axisColor ?? '#d1d5db';
            const lineWidth = options.lineWidth ?? 1.2;
            const originX = options.x_origin ?? options.originX ?? (mode === 'quadrant' ? padding : width / 2);
            const originY = options.y_origin ?? options.originY ?? (mode === 'quadrant' ? height - padding : height / 2);
            const showTicks = options.showTicks !== false;
            const tickLength = options.tickLength ?? 6;
            const xTickStep = options.xTickStep ?? 60;
            const yTickStep = options.yTickStep ?? 60;

            ctx.save();
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = lineWidth;

            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(width, originY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, height);
            ctx.stroke();

            if (showTicks) {
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let x = originX + xTickStep; x < width; x += xTickStep) {
                    ctx.moveTo(x, originY - tickLength);
                    ctx.lineTo(x, originY + tickLength);
                }
                if (mode !== 'quadrant') {
                    for (let x = originX - xTickStep; x > 0; x -= xTickStep) {
                        ctx.moveTo(x, originY - tickLength);
                        ctx.lineTo(x, originY + tickLength);
                    }
                }
                for (let y = originY - yTickStep; y > 0; y -= yTickStep) {
                    ctx.moveTo(originX - tickLength, y);
                    ctx.lineTo(originX + tickLength, y);
                }
                if (mode === 'center') {
                    for (let y = originY + yTickStep; y < height; y += yTickStep) {
                        ctx.moveTo(originX - tickLength, y);
                        ctx.lineTo(originX + tickLength, y);
                    }
                }
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, color = '#e74c3c', width = 2) {
            const headlen = 10;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
            ctx.restore();
        }

        // Step Stack Management Functions
        function showStep(stackId, stepNumber) {
            const stack = document.getElementById(stackId);
            if (!stack) return;

            // Hide all steps
            const steps = stack.querySelectorAll('.step-item');
            steps.forEach(step => {
                step.classList.remove('active');
            });

            // Show target step
            const targetStep = stack.querySelector(`[data-step="${stepNumber}"]`);
            if (targetStep) {
                targetStep.classList.add('active');

                // Mark previous steps as completed
                steps.forEach(step => {
                    const stepNum = parseInt(step.dataset.step);
                    if (stepNum < stepNumber) {
                        step.classList.add('completed');
                    } else {
                        step.classList.remove('completed');
                    }
                });

                // Re-render MathJax for new content
                if (window.MathJax && window.MathJax.typesetPromise) {
                    queueMathTypeset(targetStep).then((success) => {
                        if (!success) {
                            console.warn('步骤内容的公式渲染未成功');
                        }
                    });
                }

                // Update animation based on step
                updateAnimationForStep(stackId, stepNumber);
            }
        }

        function updateAnimationForStep(stackId, stepNumber) {
            // This function can be expanded to show different animations based on the step
            const canvas = document.getElementById('animationCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Clear previous animation
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }

            // Draw step-specific animation
            switch(stackId) {
                case 'sequence-intro':
                    drawSequenceStepAnimation(ctx, canvas, stepNumber);
                    break;
                case 'trend-observation':
                    drawTrendStepAnimation(ctx, canvas, stepNumber);
                    break;
                case 'limit-definition':
                    drawLimitStepAnimation(ctx, canvas, stepNumber);
                    break;
                default:
                    drawDefaultAnimation(ctx, canvas);
            }
        }

        function drawSequenceStepAnimation(ctx, canvas, step) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';

            switch(step) {
                case 1:
                    // Show building floors
                    ctx.fillStyle = '#3498db';
                    for (let i = 0; i < 5; i++) {
                        ctx.fillRect(canvas.width/2 - 30, canvas.height - 50 - i*40, 60, 35);
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillText(`${i+1}F`, canvas.width/2, canvas.height - 30 - i*40);
                        ctx.fillStyle = '#3498db';
                    }
                    break;
                case 2:
                    // Show mathematical sequence
                    ctx.fillStyle = '#2c3e50';
                    const sequence = ['x₁', 'x₂', 'x₃', '...', 'xₙ'];
                    for (let i = 0; i < sequence.length; i++) {
                        ctx.fillText(sequence[i], 50 + i*80, canvas.height/2);
                    }
                    break;
                case 3:
                    // Show correct vs incorrect examples
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillText('❌ 只能是 1,2,3,4...', canvas.width/2, canvas.height/2 - 30);
                    ctx.fillStyle = '#27ae60';
                    ctx.fillText('✅ 可以是 1,4,9,16...', canvas.width/2, canvas.height/2 + 30);
                    break;
            }
        }

        function drawTrendStepAnimation(ctx, canvas, step) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            switch(step) {
                case 1:
                    // Show calculation results
                    drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' });
                    ctx.fillStyle = '#3498db';
                    ctx.font = '16px Arial';
                    const values = [0.5, 0.667, 0.909, 0.990];
                    const labels = ['n=1', 'n=2', 'n=10', 'n=100'];
                    for (let i = 0; i < values.length; i++) {
                        const x = 50 + i * 100;
                        const y = canvas.height - values[i] * 200;
                        ctx.fillRect(x-2, y-2, 4, 4);
                        ctx.fillText(labels[i], x-15, y-10);
                        ctx.fillText(values[i].toFixed(3), x-20, y+20);
                    }
                    break;
                case 2:
                    // Show running analogy
                    ctx.font = '30px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('🏃‍♂️', canvas.width/4, canvas.height/2);
                    ctx.fillText('💧', 3*canvas.width/4, canvas.height/2);
                    break;
                case 3:
                    // Show limit approaching 1
                    drawCoordinateSystem(ctx, canvas, { mode: 'quadrant' });
                    ctx.strokeStyle = '#e74c3c';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height - 200);
                    ctx.lineTo(canvas.width, canvas.height - 200);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '16px Arial';
                    ctx.fillText('y = 1 (极限值)', canvas.width - 80, canvas.height - 210);
                    break;
            }
        }

        function drawLimitStepAnimation(ctx, canvas, step) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.textAlign = 'center';

            switch(step) {
                case 1:
                    // Show target analogy
                    ctx.font = '50px Arial';
                    ctx.fillText('🎯', canvas.width/2, canvas.height/2);
                    ctx.font = '20px Arial';
                    ctx.fillText('射箭越来越接近靶心', canvas.width/2, canvas.height/2 + 60);
                    break;
                case 2:
                    // Show mathematical definition
                    ctx.font = '24px Arial';
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillText('lim', canvas.width/2 - 40, canvas.height/2);
                    ctx.font = '16px Arial';
                    ctx.fillText('n→∞', canvas.width/2 - 20, canvas.height/2 - 15);
                    ctx.font = '24px Arial';
                    ctx.fillText('xₙ = a', canvas.width/2 + 20, canvas.height/2);
                    break;
                case 3:
                    // Show epsilon-N promise
                    ctx.font = '30px Arial';
                    ctx.fillText('📐', canvas.width/2, canvas.height/2);
                    ctx.font = '16px Arial';
                    ctx.fillText('ε-N 承诺：给我时间，控制误差', canvas.width/2, canvas.height/2 + 50);
                    break;
            }
        }

        function initStepStacks() {
            // Initialize all step stacks to show first step
            const stacks = document.querySelectorAll('.step-stack');
            stacks.forEach(stack => {
                const firstStep = stack.querySelector('[data-step="1"]');
                if (firstStep) {
                    firstStep.classList.add('active');
                }
            });
        }

        function drawDefaultAnimation(ctx, canvas) {
            drawCoordinateSystem(ctx, canvas);
            ctx.fillStyle = '#aaa';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('(可视化区域)', canvas.width / 2, canvas.height / 2);
        }

        // Stage 3：按步骤的渐进式可视化（例1-1 等）
        function drawExample11Step(ctx, canvas, step) {
            drawCoordinateSystem(ctx, canvas, { x_origin: 60, y_origin: canvas.height - 40 });
            const width = canvas.width, height = canvas.height;
            // step 1: 数轴
            if (step >= 1) {
                ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(60, height-40); ctx.lineTo(width-20, height-40); ctx.stroke();
                ctx.fillStyle = '#6b7280'; ctx.font = '14px "Microsoft YaHei"';
                ctx.fillText('0', 56, height-20); ctx.fillText('1', width-40, height-20);
            }
            // step 2: 点列 x_n = n/(n+1)
            if (step >= 2) {
                ctx.fillStyle = 'rgba(99,102,241,0.85)';
                const N = 10;
                for (let n=1; n<=N; n++) {
                    const xn = n/(n+1);
                    const x = 60 + (width-80) * xn;
                    ctx.beginPath(); ctx.arc(x, height-40, 5, 0, 2*Math.PI); ctx.fill();
                }
            }
            // step 3: 极限标注 L=1
            if (step >= 3) {
                ctx.strokeStyle = '#ef4444'; ctx.setLineDash([6,4]);
                ctx.beginPath(); ctx.moveTo(width-40, 20); ctx.lineTo(width-40, height-40); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#ef4444'; ctx.font = '16px "Microsoft YaHei"';
                ctx.fillText('L = 1', width-70, 30);
            }
        }

        const __origDrawAnimation = window.drawAnimation || function(){};
        window.drawAnimation = function(slideIndex, stepCtx) {
            if (!stepCtx) return __origDrawAnimation(slideIndex);
            const { ctx, canvas, step, scene } = stepCtx;
            if (!ctx || !canvas) return;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            if (scene === 'example1_1') {
                drawExample11Step(ctx, canvas, step);
            } else {
                drawDefaultAnimation(ctx, canvas);
            }
        }





        // 隐藏加载指示器
        function hideLoading() {
            const loading = document.getElementById('loadingIndicator');
            if (loading) {
                loading.style.display = 'none';
            }
        }

        // 键盘导航
        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') prevSlide();
            if (e.key === 'ArrowRight') nextSlide();
            if (e.key === ' ') { e.preventDefault(); autoPlay(); }
        });

        // 鼠标滚轮翻页
        let wheelTimeout;
        document.addEventListener('wheel', e => {
            e.preventDefault();

            // 防抖处理，避免过快滚动
            clearTimeout(wheelTimeout);
            wheelTimeout = setTimeout(() => {
                if (e.deltaY > 0) {
                    // 向下滚动 - 下一页（循环到第一页）
                    if (currentSlide >= totalSlides) {
                        showSlide(1);
                    } else {
                        nextSlide();
                    }
                } else if (e.deltaY < 0) {
                    // 向上滚动 - 上一页（循环到最后一页）
                    if (currentSlide <= 1) {
                        showSlide(totalSlides);
                    } else {
                        prevSlide();
                    }
                }
            }, 100);
        }, { passive: false });

        // 交互式按钮功能
        function initInteractiveButtons() {
            // 监听分步按钮点击
            document.addEventListener('click', function(e) {
                // Step-stack: 分步按钮
                if (e.target.classList.contains('step-btn')) {
                    const stack = e.target.closest('.step-stack');
                    if (stack) {
                        const items = Array.from(stack.querySelectorAll('.step-item'));
                        const currentIndex = items.findIndex(el => el.classList.contains('active'));
                        const nextIndex = Math.min(currentIndex + 1, items.length - 1);
                        if (nextIndex !== currentIndex) {
                            // 先移除旧项的活动状态
                            items[currentIndex].classList.remove('active');
                            // 添加新项的活动状态
                            items[nextIndex].classList.add('active');
                            // 使用 scheduleMathRender 重新渲染数学公式
                            window.scheduleMathRender([items[nextIndex]]);
                            const slideEl = e.target.closest('.slide');
                            const canvas = slideEl && slideEl.querySelector('.step-canvas');
                            if (canvas) {
                                const ctx = canvas.getContext('2d');
                                window.drawAnimation(currentSlide, { step: nextIndex + 1, scene: canvas.dataset.scene, ctx, canvas });
                            }
                        }
                    }
                    return;
                }

            });
        }

        // AI悬浮按钮功能
        function initAIFloatButton() {
            const aiBtn = document.getElementById('aiFloatBtn');
            if (!aiBtn) return;

            // 点击跳转到AI数列页面
            aiBtn.addEventListener('click', function() {
                // 获取当前页面的目录路径
                const currentPath = window.location.pathname;
                const currentDir = currentPath.substring(0, currentPath.lastIndexOf('/'));
                const aiPageUrl = currentDir + '/数列ai.html';

                // 在新窗口中打开AI数列页面
                window.open(aiPageUrl, '_blank');
            });

            // 检查当前幻灯片是否与数列相关，控制按钮显示
            function updateAIButtonVisibility() {
                const currentSlideElement = document.querySelector('.slide.active');
                if (!currentSlideElement) return;

                const slideContent = currentSlideElement.innerHTML.toLowerCase();
                const isSequenceRelated = slideContent.includes('数列') ||
                                        slideContent.includes('sequence') ||
                                        slideContent.includes('x_n') ||
                                        slideContent.includes('x_{n}') ||
                                        slideContent.includes('通项') ||
                                        slideContent.includes('项数') ||
                                        slideContent.includes('斐波那契') ||
                                        currentSlide >= 2 && currentSlide <= 8; // 数列相关的幻灯片范围

                if (isSequenceRelated) {
                    aiBtn.classList.add('show');
                } else {
                    aiBtn.classList.remove('show');
                }
            }

            // 初始检查
            setTimeout(updateAIButtonVisibility, 500);

            // 监听幻灯片切换
            const originalShowSlide = window.showSlide;
            window.showSlide = function(n) {
                originalShowSlide(n);
                setTimeout(updateAIButtonVisibility, 300);
            };
        }

        // 提供一个安全的、带防抖的全局方法供其他脚本调用以触发 MathJax 渲染
        // 这样 lab-math-enhancer 等动态插入内容的脚本可以调用 window.scheduleMathRender()
        window.scheduleMathRender = (function() {
            let __mj_timer = null;
            return function(rootElements) {
                if (!window.MathJax || !window.MathJax.typesetPromise) {
                    return Promise.resolve();
                }
                if (__mj_timer) clearTimeout(__mj_timer);
                return new Promise((resolve) => {
                    __mj_timer = setTimeout(() => {
                        try {
                            queueMathTypeset(rootElements).then((success) => resolve(success));
                        } catch (e) {
                            resolve();
                        }
                        __mj_timer = null;
                    }, 50);
                });
            };
        })();

        // 初始化
        window.onload = () => {
            try {
                // 确保 MathJax 已加载
                const ensureMathJax = () => {
                    return waitForMathJaxReady().catch((err) => {
                        console.warn('MathJax readiness timeout:', err);
                    });
                };

                ensureMathJax().then(() => {
                    // 初始化所有功能
                    initSlides();
                    initInteractiveButtons();
                    initAIFloatButton();
                    initStepStacks();
                    
                    // 强制重新渲染所有公式
                    setTimeout(() => {
                        if (window.MathJax && window.MathJax.typesetPromise) {
                            resetMathJaxState();

                            queueMathTypeset().then((success) => {
                                if (!success) {
                                    console.warn('所有公式重新渲染时发生错误');
                                } else {
                                    console.log('所有公式渲染完成');
                                }
                            });
                        }
                    }, 2000);

                    // 监听幻灯片切换事件
                    const originalShowSlide = window.showSlide;
                    window.showSlide = function(n) {
                        originalShowSlide(n);
                        if (window.MathJax && window.MathJax.typesetPromise) {
                            const currentSlide = document.querySelector('.slide.active');
                            if (currentSlide) {
                                queueMathTypeset(currentSlide).then((success) => {
                                    if (!success) {
                                        console.warn('幻灯片切换时的公式渲染未成功');
                                    }
                                });
                            }
                        }
                    };
                });
            } catch (error) {
                console.error('Failed to initialize slides:', error);
                hideLoading();
                const container = document.getElementById('slidesContainer');
                if (container) {
                    container.innerHTML = '<div class="error-message">课件加载失败，请刷新页面重试。</div>';
                }
            }
        };

        // 强制重新渲染所有公式的函数
        function forceRerenderMath() {
            console.log('开始强制重新渲染公式...');
            if (window.MathJax && window.MathJax.typesetPromise) {
                resetMathJaxState();

                queueMathTypeset().then((success) => {
                    if (success) {
                        console.log('强制重新渲染完成');
                        alert('公式重新渲染完成！');
                    } else {
                        console.log('强制重新渲染过程中出现错误');
                        alert('重新渲染失败，请检查控制台错误信息');
                    }
                });
            } else {
                alert('MathJax未加载，请刷新页面');
            }
        }

        // 添加全局函数供调试使用
        window.forceRerenderMath = forceRerenderMath;

        // Lab Menu Toggle Function
        function toggleLabMenu() {
            const labMenu = document.getElementById('labMenu');
            labMenu.classList.toggle('show');
        }

        // Close lab menu when clicking outside
        document.addEventListener('click', function(event) {
            const labMenu = document.getElementById('labMenu');
            const labButton = document.querySelector('.lab-menu-button');

            if (!labMenu.contains(event.target) && !labButton.contains(event.target)) {
                labMenu.classList.remove('show');
            }
        });
    </script>
</body>
</html>
