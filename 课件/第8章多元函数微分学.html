<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第八章：多元函数微分学 (交互式课件)</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <script src="../common-assets/js/three-r128.min.js"></script>
    <!-- 使用统一的MathJax配置文件 -->
    <script src="../common-assets/js/mathjax-config.js"></script>
      <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready!');
                    });
                }
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
            src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js">
    </script>


    <style>
        @import url('../common-assets/css/fonts.css');

        :root {
            --background-gradient-start: #f8fafc;
            --background-gradient-end: #eef2ff;
            --surface-color: #ffffff;
            --surface-muted: #f6f7fb;
            --divider-color: #e2e8f0;
            --primary-color: #2563eb;
            --accent-color: #f97316;
            --success-color: #16a34a;
            --danger-color: #ef4444;
            --warning-color: #facc15;
            --info-color: #6366f1;
            --text-color: #1f2937;
            --muted-text: #475569;
            --heading-font: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            --handwriting-font: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            --chalkboard-bg: #ffffff;
            --chalk-text: #1f2937;
            --visualization-bg: #f8fafc;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: var(--heading-font);
            background: linear-gradient(180deg, var(--background-gradient-start) 0%, var(--background-gradient-end) 100%);
            color: var(--text-color);
            overflow: hidden;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        #presentation-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            padding: 32px 40px 96px;
            background: transparent;
        }

        .slide {
            position: absolute;
            top: 32px;
            left: 40px;
            right: 40px;
            bottom: 96px;
            display: flex;
            flex-direction: row;
            align-items: stretch;
            background: var(--surface-color);
            border-radius: 26px;
            box-shadow: 0 24px 60px rgba(15, 23, 42, 0.16);
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transform: translateY(24px);
            transition: opacity 0.45s ease, transform 0.45s ease;
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            z-index: 10;
        }

        .chalkboard {
            flex: 0 0 50%;
            max-width: 50%;
            background: var(--surface-color);
            color: var(--text-color);
            padding: 48px 56px;
            border-right: 1px solid var(--divider-color);
            display: flex;
            flex-direction: column;
            gap: 18px;
            overflow-y: auto;
        }

        .chalkboard h1,
        .chalkboard h2,
        .chalkboard h3,
        .chalkboard h4 {
            font-family: var(--heading-font);
            color: var(--text-color);
        }

        .chalkboard h2 {
            font-size: 2.1rem;
            margin: 0;
            padding-bottom: 14px;
            border-bottom: 3px solid rgba(37, 99, 235, 0.15);
            color: var(--primary-color);
        }

        .chalkboard h3 {
            font-size: 1.4rem;
            margin: 0;
            color: var(--muted-text);
        }

        .chalkboard h4 {
            font-size: 1.2rem;
            margin: 0;
            color: var(--muted-text);
        }

        .chalkboard p,
        .chalkboard li {
            font-size: 1.04rem;
            line-height: 1.8;
            color: var(--text-color);
        }

        .chalkboard ul {
            margin: 0;
            padding-left: 20px;
        }

        .chalkboard ul li {
            margin-bottom: 10px;
        }

        .chalkboard ol {
            margin: 0;
            padding-left: 22px;
        }

        .chalkboard::-webkit-scrollbar {
            width: 6px;
        }

        .chalkboard::-webkit-scrollbar-thumb {
            background: rgba(37, 99, 235, 0.35);
            border-radius: 4px;
        }

        .chalkboard::-webkit-scrollbar-track {
            background: rgba(226, 232, 240, 0.6);
        }

        .visualization {
            flex: 1;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            padding: 24px;
        }

        .visualization.full-width {
            flex-basis: 100%;
            max-width: 100%;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.14), rgba(99, 102, 241, 0.14));
        }

        .visualization.white-bg {
            background: var(--surface-color);
        }

        canvas, svg {
            max-width: 100%;
            height: 100%;
        }

        .math-formula {
            background: var(--surface-muted);
            border: 1px solid rgba(37, 99, 235, 0.1);
            border-radius: 16px;
            padding: 18px 22px;
            color: var(--text-color);
            font-size: 1.1rem;
            line-height: 1.6;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
        }

        .highlight {
            color: var(--accent-color);
            font-weight: 600;
        }

        .note-card,
        .example-card,
        .warning-card,
        .definition-card {
            border-radius: 16px;
            padding: 18px 22px;
            background: var(--surface-muted);
            border-left: 4px solid rgba(37, 99, 235, 0.35);
        }

        .example-card {
            border-left-color: rgba(16, 185, 129, 0.35);
        }

        .warning-card {
            border-left-color: rgba(249, 115, 22, 0.35);
        }

        .nav-buttons {
            position: fixed;
            right: 32px;
            bottom: 26px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 999px;
            box-shadow: 0 18px 35px rgba(15, 23, 42, 0.14);
            backdrop-filter: blur(14px);
            z-index: 1000;
        }

        .nav-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--primary-color), #4f46e5);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 20px rgba(79, 70, 229, 0.25);
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .page-indicator {
            position: fixed;
            right: 42px;
            bottom: 88px;
            padding: 10px 18px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.7);
            color: #f8fafc;
            font-size: 0.9rem;
            letter-spacing: 0.04em;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
            backdrop-filter: blur(8px);
            z-index: 900;
        }

        .global-animation-controls {
            position: fixed;
            left: 40px;
            bottom: 32px;
            display: flex;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 16px;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
            backdrop-filter: blur(12px);
            z-index: 900;
        }

        .global-control-btn {
            border: none;
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary-color);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .global-control-btn:hover {
            background: rgba(37, 99, 235, 0.2);
        }

        .global-control-btn.pause {
            background: rgba(239, 68, 68, 0.12);
            color: var(--danger-color);
        }

        .value-display {
            position: absolute;
            top: 32px;
            left: 32px;
            min-width: 220px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.92);
            border-radius: 18px;
            box-shadow: 0 15px 30px rgba(15, 23, 42, 0.18);
            backdrop-filter: blur(10px);
            color: var(--text-color);
        }

        .value-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 0.95rem;
        }

        .value-item:last-child {
            margin-bottom: 0;
        }

        .value-label {
            color: var(--muted-text);
        }

        .value-number {
            font-weight: 600;
            color: var(--primary-color);
        }

        .control-panel {
            position: absolute;
            left: 50%;
            bottom: 32px;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 999px;
            box-shadow: 0 15px 30px rgba(15, 23, 42, 0.16);
            backdrop-filter: blur(10px);
        }

        .control-btn {
            border: none;
            padding: 8px 18px;
            border-radius: 999px;
            background: linear-gradient(135deg, var(--primary-color), #4f46e5);
            color: #fff;
            cursor: pointer;
            font-size: 0.95rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 20px rgba(79, 70, 229, 0.3);
        }

        .slider {
            accent-color: var(--primary-color);
        }

        .home-nav-buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 40px;
        }

        .home-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 130px;
            padding: 16px 18px;
            border-radius: 18px;
            background: rgba(37, 99, 235, 0.08);
            color: var(--text-color);
            text-decoration: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .home-nav-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 14px 25px rgba(37, 99, 235, 0.2);
            background: rgba(37, 99, 235, 0.12);
        }

        .btn-icon {
            font-size: 0.85rem;
            letter-spacing: 0.12em;
            color: var(--muted-text);
        }

        .btn-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color);
        }

        .return-home-panel {
            position: absolute;
            top: 32px;
            left: 40px;
            display: flex;
            gap: 12px;
        }

        .return-home-panel .return-link {
            padding: 8px 16px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.08);
            color: var(--text-color);
            font-size: 0.9rem;
            transition: background 0.2s ease;
        }

        .return-home-panel .return-link:hover {
            background: rgba(37, 99, 235, 0.18);
        }

        .return-home-panel .return-link.return-main {
            background: var(--primary-color);
            color: #fff;
        }

        .return-home-panel .return-link.return-main:hover {
            background: #1d4ed8;
        }

        #floating-menu {
            position: fixed;
            bottom: 120px;
            right: 40px;
            z-index: 950;
            font-family: var(--heading-font);
        }

        .slide.title-slide .chalkboard {
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 12px;
        }

        .slide.title-slide .chalkboard h2 {
            border-bottom: none;
            font-size: 3.4rem;
            color: var(--primary-color);
        }

        .slide.title-slide .chalkboard p {
            margin: 0;
            color: var(--muted-text);
        }

        .menu-toggle {
            padding: 10px 16px;
            border-radius: 999px;
            border: none;
            background: rgba(37, 99, 235, 0.9);
            color: #fff;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(37, 99, 235, 0.25);
            transition: transform 0.2s ease;
        }

        .menu-toggle:hover {
            transform: translateY(-2px);
        }

        .menu-content {
            position: absolute;
            bottom: 60px;
            right: 0;
            width: 260px;
            max-height: 360px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 18px;
            box-shadow: 0 16px 45px rgba(15, 23, 42, 0.18);
            padding: 14px 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(12px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            backdrop-filter: blur(12px);
        }

        .menu-content.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .menu-item {
            padding: 10px 20px;
            color: var(--text-color);
            font-size: 0.95rem;
            transition: background 0.2s ease;
        }

        .menu-item:hover {
            background: rgba(37, 99, 235, 0.12);
        }

        .menu-item.active {
            background: rgba(37, 99, 235, 0.18);
            color: var(--primary-color);
            font-weight: 600;
        }

        @media (max-width: 1200px) {
            #presentation-container {
                padding: 24px 24px 112px;
            }

            .slide {
                top: 24px;
                left: 24px;
                right: 24px;
                bottom: 112px;
            }

            .chalkboard {
                padding: 32px;
            }
        }

        @media (max-width: 960px) {
            body {
                overflow: auto;
            }

            .slide {
                position: relative;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                flex-direction: column;
                min-height: 100vh;
                border-radius: 0;
            }

            #presentation-container {
                padding: 0;
                height: auto;
                min-height: 100vh;
            }

            .chalkboard, .visualization {
                max-width: 100%;
                flex: none;
                border-right: none;
            }

            .visualization {
                min-height: 320px;
            }

            .nav-buttons, .page-indicator, .global-animation-controls, #floating-menu {
                position: static;
                margin: 16px auto;
            }
        }
</style>
    
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link return-sub" href="index.html">← 返回目录</a>
        <a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
    </div>

<div id="presentation-container">
    
    <!-- 第1页：封面 -->
    <div class="slide active title-slide">
        <div class="chalkboard" style="flex: 1;">
            <h2>第八章</h2>
            <p style="font-size: 2.3rem;">多元函数微分学</p>
            <p style="font-size: 1.25rem; margin-top: 32px;">从平面走向空间的数学之旅</p>
            <div style="margin-top: 48px;">
                <p style="font-size: 1.05rem; color: var(--muted-text);">
                    🎯 学习目标：理解二元函数、掌握偏导数、学会求极值
                </p>
            </div>
        </div>
    </div>

    <!-- 第2页：为什么需要多元函数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>生活中的多元函数</h2>
            <p>现实中很多事情<span class="highlight">不只由一个因素决定</span></p>
            
            <div class="example-box">
                <h4>📱 手机信号强度</h4>
                <p>信号 = f(距离, 障碍物, 天气)</p>
            </div>
            
            <div class="example-box">
                <h4>🍕 披萨价格</h4>
                <p>价格 = f(尺寸, 配料数量, 送餐距离)</p>
            </div>
            
            <div class="example-box">
                <h4>📊 考试成绩</h4>
                <p>成绩 = f(学习时间, 理解程度, 考试技巧)</p>
            </div>
            
            <div class="tip-text">
                💡 这就是为什么我们需要学习多元函数！
            </div>
        </div>
        <div class="visualization" id="vis-intro"></div>
    </div>

    <!-- 第3页：二元函数基本概念 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>什么是二元函数？</h2>
            <p>最简单的多元函数：<span class="highlight">两个输入，一个输出</span></p>
            
            <div class="math-formula">
                $z = f(x, y)$
            </div>
            
            <h3>通俗理解</h3>
            <p>想象一个<span class="highlight">函数机器</span>：</p>
            <ul>
                <li>投入两个数字 x 和 y</li>
                <li>机器按照规则 f 处理</li>
                <li>输出一个结果 z</li>
            </ul>
            
            <div class="example-box">
                <h4>例子：计算长方形面积</h4>
                <p>面积 = 长 × 宽</p>
                <p>$S = f(x, y) = x \cdot y$</p>
            </div>
        </div>
        <div class="visualization" id="vis-binary-function"></div>
    </div>

    <!-- 第4页：定义域 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>定义域</h2>
            <p>让函数<span class="highlight">有意义</span>的所有(x,y)点的集合</p>
            
            <h3>三个常见限制</h3>
            <ol>
                <li><span class="highlight">分母不能为零</span>
                    <p>例：$z = \frac{1}{x-y}$，要求 $x \neq y$</p>
                </li>
                <li><span class="highlight">根号下不能为负</span>
                    <p>例：$z = \sqrt{x+y}$，要求 $x+y \geq 0$</p>
                </li>
                <li><span class="highlight">对数真数必须为正</span>
                    <p>例：$z = \ln(xy)$，要求 $xy > 0$</p>
                </li>
            </ol>
            
            <div class="tip-text">
                💡 定义域就像是函数的"活动范围"
            </div>
        </div>
        <div class="visualization" id="vis-domain"></div>
    </div>

    <!-- 第5页：二元函数的图像 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>二元函数的图像</h2>
            <p>二元函数的图像是<span class="highlight">三维空间中的曲面</span></p>
            
            <h3>生活中的例子</h3>
            <ul>
                <li>🏔️ 山地地形图</li>
                <li>🌊 水波纹</li>
                <li>🎪 帐篷顶部</li>
                <li>🥣 碗的形状</li>
            </ul>
            
            <div class="example-box">
                <h4>右边展示：抛物面</h4>
                <p>$z = x^2 + y^2$</p>
                <p>像一个倒扣的碗</p>
            </div>
            
            <p>🖱️ <span class="highlight">拖动鼠标旋转查看</span></p>
        </div>
        <div class="visualization" id="vis-3d-surface"></div>
    </div>

    <!-- 第6页：等高线 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>等高线</h2>
            <p>把3D曲面<span class="highlight">投影到平面</span>的方法</p>
            
            <h3>什么是等高线？</h3>
            <p>高度相同的点连成的线</p>
            
            <h3>生活中的等高线</h3>
            <ul>
                <li>🗺️ 地形图的等高线</li>
                <li>🌡️ 天气图的等温线</li>
                <li>🌪️ 气压图的等压线</li>
            </ul>
            
            <div class="tip-text">
                💡 等高线密集 = 坡度陡
                <br>等高线稀疏 = 坡度缓
            </div>
        </div>
        <div class="visualization" id="vis-contour"></div>
    </div>

    <!-- 第7页：极限概念（简化版） -->
    <div class="slide">
        <div class="chalkboard">
            <h2>二元函数的极限</h2>
            <p>从<span class="highlight">各个方向</span>接近一个点时的趋势</p>
            
            <div class="math-formula">
                $\lim\limits_{(x,y) \to (x_0,y_0)} f(x,y) = L$
            </div>
            
            <h3>通俗理解</h3>
            <p>不管从哪条路走向目标点，函数值都趋向同一个数</p>
            
            <div class="example-box">
                <h4>⚠️ 注意</h4>
                <p>必须从<span class="highlight">所有方向</span>接近都得到相同结果</p>
                <p>否则极限不存在！</p>
            </div>
        </div>
        <div class="visualization" id="vis-limit"></div>
    </div>

    <!-- 第8页：偏导数引入 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>偏导数的引入</h2>
            <p>问题：曲面怎么描述<span class="highlight">变化率</span>？</p>
            
            <h3>思路</h3>
            <p>一次只让一个变量变化，其他保持不变</p>
            
            <div class="example-box">
                <h4>🚗 开车爬山</h4>
                <ul>
                    <li>向东的坡度？（x方向）</li>
                    <li>向北的坡度？（y方向）</li>
                </ul>
            </div>
            
            <p>偏导数 = <span class="highlight">沿坐标轴方向的变化率</span></p>
        </div>
        <div class="visualization" id="vis-partial-intro"></div>
    </div>

    <!-- 第9页：偏导数定义 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>偏导数</h2>
            
            <h3>对x的偏导数</h3>
            <div class="math-formula">
                $\frac{\partial f}{\partial x}$
            </div>
            <p>把y当<span class="highlight">常数</span>，对x求导</p>
            
            <h3>对y的偏导数</h3>
            <div class="math-formula">
                $\frac{\partial f}{\partial y}$
            </div>
            <p>把x当<span class="highlight">常数</span>，对y求导</p>
            
            <div class="tip-text">
                💡 记忆技巧：偏导数就是"偏心"，只关注一个变量
            </div>
        </div>
        <div class="visualization" id="vis-partial-def"></div>
    </div>

    <!-- 第10页：偏导数计算实例 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>偏导数计算</h2>
            
            <div class="example-box">
                <h4>例题：$z = x^2y + 3xy^2$</h4>
            </div>
            
            <h3>求 $\frac{\partial z}{\partial x}$</h3>
            <p>把y当常数：</p>
            <p>$\frac{\partial z}{\partial x} = 2xy + 3y^2$</p>
            
            <h3>求 $\frac{\partial z}{\partial y}$</h3>
            <p>把x当常数：</p>
            <p>$\frac{\partial z}{\partial y} = x^2 + 6xy$</p>
            
            <div class="tip-text">
                💡 就像一元函数求导，只是把另一个变量当常数
            </div>
        </div>
        <div class="visualization" id="vis-partial-calc"></div>
    </div>

    <!-- 继续后续页面... -->
    
    <!-- 导航按钮 -->
    <div class="nav-buttons">
        <button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">‹</button>
        <button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">›</button>
    </div>

    <div class="page-indicator" id="page-indicator">1 / 10</div>

</div>

<script>
    let slides, totalSlides, currentSlide = 0;
    let scene, camera, renderer, mesh, controls;
    let animationFrameId;

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        showSlide(0);

        // 键盘导航
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') nextSlide();
            else if (e.key === 'ArrowLeft') previousSlide();
        });

        // 鼠标滚轮导航
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY > 0) nextSlide();
            else previousSlide();
        }, { passive: false });
    });

    function nextSlide() {
        if (currentSlide < totalSlides - 1) {
            currentSlide++;
            showSlide(currentSlide);
        }
    }

    function previousSlide() {
        if (currentSlide > 0) {
            currentSlide--;
            showSlide(currentSlide);
        }
    }

    function showSlide(index) {
        // 清理之前的Three.js场景
        cleanupThreeJS();
        
        slides.forEach(slide => slide.classList.remove('active'));
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        document.getElementById('page-indicator').textContent = `${currentSlide + 1} / ${totalSlides}`;
        document.getElementById('prev-btn').disabled = currentSlide === 0;
        document.getElementById('next-btn').disabled = currentSlide === totalSlides - 1;
        
        // 运行对应的可视化
        runVisualization(currentSlide);
        
        // 渲染数学公式
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([slides[currentSlide]]).catch(err => {
                console.warn('MathJax rendering failed:', err);
            });
        }
    }

    function cleanupThreeJS() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        if (renderer) {
            renderer.dispose();
            renderer = null;
        }
        if (scene) {
            // 清理场景中的所有对象
            while(scene.children.length > 0) { 
                const child = scene.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
                scene.remove(child); 
            }
            scene = null;
        }
        if (camera) {
            camera = null;
        }
        if (controls) {
            controls = null;
        }
    }

    // D3.js辅助函数
    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 40, left: 40}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) return null;
        
        container.html('');
        const bounds = container.node().getBoundingClientRect();
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;
        
        const svg = container.append('svg')
            .attr('width', bounds.width)
            .attr('height', bounds.height);
            
        const g = svg.append('g')
            .attr('transform', `translate(${margins.left}, ${margins.top})`);
            
        return { container, svg, g, width, height, bounds };
    }

    // 运行可视化
    function runVisualization(slideIndex) {
        switch(slideIndex) {
            case 1: visualizeIntro(); break;
            case 2: visualizeBinaryFunction(); break;
            case 3: visualizeDomain(); break;
            case 4: visualize3DSurface(); break;
            case 5: visualizeContour(); break;
            case 6: visualizeLimit(); break;
            case 7: visualizePartialIntro(); break;
            case 8: visualizePartialDef(); break;
            case 9: visualizePartialCalc(); break;
        }
    }

    // 可视化函数实现

    // 第2页：引入动画 - 多因素影响的动态展示
    function visualizeIntro() {
        const setup = setupD3('vis-intro');
        if (!setup) return;
        const { g, width, height } = setup;

        // 中心的结果圆
        const centerX = width/2;
        const centerY = height/2;
        
        const resultCircle = g.append('circle')
            .attr('cx', centerX)
            .attr('cy', centerY)
            .attr('r', 60)
            .attr('fill', '#f39c12')
            .attr('stroke', '#d68910')
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(0 0 10px rgba(243, 156, 18, 0.5))');

        g.append('text')
            .attr('x', centerX)
            .attr('y', centerY)
            .attr('text-anchor', 'middle')
            .attr('dy', '0.3em')
            .attr('fill', 'white')
            .style('font-size', '20px')
            .style('font-weight', 'bold')
            .text('结果');

        // 输入因素
        const factors = [
            { name: '因素1', angle: 0, color: '#3498db' },
            { name: '因素2', angle: 120, color: '#e74c3c' },
            { name: '因素3', angle: 240, color: '#2ecc71' }
        ];

        const radius = 150;
        
        factors.forEach((factor, i) => {
            const angle = factor.angle * Math.PI / 180;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);

            // 因素圆圈
            const factorCircle = g.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 0)
                .attr('fill', factor.color)
                .attr('stroke', d3.color(factor.color).darker())
                .attr('stroke-width', 2);

            factorCircle.transition()
                .delay(i * 300)
                .duration(800)
                .attr('r', 40)
                .ease(d3.easeBounceOut);

            // 因素文字
            g.append('text')
                .attr('x', x)
                .attr('y', y)
                .attr('text-anchor', 'middle')
                .attr('dy', '0.3em')
                .attr('fill', 'white')
                .style('font-size', '14px')
                .style('opacity', 0)
                .text(factor.name)
                .transition()
                .delay(i * 300 + 400)
                .duration(500)
                .style('opacity', 1);

            // 连线动画
            const line = g.append('line')
                .attr('x1', x)
                .attr('y1', y)
                .attr('x2', x)
                .attr('y2', y)
                .attr('stroke', factor.color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .style('opacity', 0.6);

            line.transition()
                .delay(i * 300 + 800)
                .duration(1000)
                .attr('x2', centerX)
                .attr('y2', centerY);

            // 粒子流动效果
            function createParticle() {
                const particle = g.append('circle')
                    .attr('cx', x)
                    .attr('cy', y)
                    .attr('r', 4)
                    .attr('fill', factor.color);

                particle.transition()
                    .duration(2000)
                    .ease(d3.easeLinear)
                    .attr('cx', centerX)
                    .attr('cy', centerY)
                    .style('opacity', 0)
                    .remove();
            }

            setInterval(createParticle, 1000);
        });
    }

    // 第3页：二元函数机器
    function visualizeBinaryFunction() {
        const setup = setupD3('vis-binary-function');
        if (!setup) return;
        const { g, width, height } = setup;

        // 函数机器
        const machineX = width/2;
        const machineY = height/2;
        
        const machine = g.append('rect')
            .attr('x', machineX - 80)
            .attr('y', machineY - 50)
            .attr('width', 160)
            .attr('height', 100)
            .attr('fill', '#34495e')
            .attr('rx', 10)
            .style('filter', 'drop-shadow(0 5px 10px rgba(0,0,0,0.3))');

        g.append('text')
            .attr('x', machineX)
            .attr('y', machineY)
            .attr('text-anchor', 'middle')
            .attr('fill', 'white')
            .style('font-size', '24px')
            .style('font-weight', 'bold')
            .text('f(x,y)');

        // 输入漏斗
        const funnel = g.append('path')
            .attr('d', `M ${machineX-60} ${machineY-100} 
                       L ${machineX-40} ${machineY-50} 
                       L ${machineX+40} ${machineY-50} 
                       L ${machineX+60} ${machineY-100} Z`)
            .attr('fill', '#95a5a6')
            .attr('stroke', '#7f8c8d')
            .attr('stroke-width', 2);

        // 输出管道
        const pipe = g.append('rect')
            .attr('x', machineX - 20)
            .attr('y', machineY + 50)
            .attr('width', 40)
            .attr('height', 60)
            .attr('fill', '#95a5a6')
            .attr('stroke', '#7f8c8d')
            .attr('stroke-width', 2);

        // 动画输入输出
        function animateFunction() {
            // 输入 x
            const xBall = g.append('circle')
                .attr('cx', machineX - 30)
                .attr('cy', machineY - 150)
                .attr('r', 15)
                .attr('fill', '#3498db');

            g.append('text')
                .attr('x', machineX - 30)
                .attr('y', machineY - 150)
                .attr('text-anchor', 'middle')
                .attr('dy', '0.3em')
                .attr('fill', 'white')
                .style('font-size', '12px')
                .text('x');

            xBall.transition()
                .duration(1000)
                .attr('cy', machineY - 75)
                .transition()
                .duration(500)
                .attr('cy', machineY)
                .style('opacity', 0);

            // 输入 y
            setTimeout(() => {
                const yBall = g.append('circle')
                    .attr('cx', machineX + 30)
                    .attr('cy', machineY - 150)
                    .attr('r', 15)
                    .attr('fill', '#e74c3c');

                g.append('text')
                    .attr('x', machineX + 30)
                    .attr('y', machineY - 150)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.3em')
                    .attr('fill', 'white')
                    .style('font-size', '12px')
                    .text('y');

                yBall.transition()
                    .duration(1000)
                    .attr('cy', machineY - 75)
                    .transition()
                    .duration(500)
                    .attr('cy', machineY)
                    .style('opacity', 0);
            }, 500);

            // 输出 z
            setTimeout(() => {
                const zBall = g.append('circle')
                    .attr('cx', machineX)
                    .attr('cy', machineY + 80)
                    .attr('r', 0)
                    .attr('fill', '#f39c12');

                zBall.transition()
                    .duration(500)
                    .attr('r', 20)
                    .transition()
                    .duration(1000)
                    .attr('cy', machineY + 150);

                g.append('text')
                    .attr('x', machineX)
                    .attr('y', machineY + 150)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.3em')
                    .attr('fill', '#f39c12')
                    .style('font-size', '16px')
                    .style('opacity', 0)
                    .text('z = f(x,y)')
                    .transition()
                    .delay(1500)
                    .duration(500)
                    .style('opacity', 1);
            }, 2000);
        }

        animateFunction();
        setInterval(animateFunction, 4000);
    }

    // 第4页：定义域可视化
    function visualizeDomain() {
        const setup = setupD3('vis-domain');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${height/2})`)
            .call(d3.axisBottom(xScale).ticks(7))
            .style('color', '#7f8c8d');

        g.append('g')
            .attr('transform', `translate(${width/2}, 0)`)
            .call(d3.axisLeft(yScale).ticks(7))
            .style('color', '#7f8c8d');

        // 轴标签
        g.append('text')
            .attr('x', width - 10)
            .attr('y', height/2 - 10)
            .style('font-size', '14px')
            .text('x');

        g.append('text')
            .attr('x', width/2 + 10)
            .attr('y', 15)
            .style('font-size', '14px')
            .text('y');

        // 圆形定义域动画
        const circle = g.append('circle')
            .attr('cx', xScale(0))
            .attr('cy', yScale(0))
            .attr('r', 0)
            .attr('fill', '#3498db')
            .attr('fill-opacity', 0.3)
            .attr('stroke', '#2980b9')
            .attr('stroke-width', 3);

        circle.transition()
            .duration(1500)
            .ease(d3.easeBounceOut)
            .attr('r', xScale(2) - xScale(0));

        // 添加说明文字
        g.append('text')
            .attr('x', width/2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .text('x² + y² ≤ 4 (圆盘区域)')
            .transition()
            .delay(1000)
            .duration(500)
            .style('opacity', 1);

        // 添加动画点
        function addRandomPoint() {
            const angle = Math.random() * 2 * Math.PI;
            const r = Math.random() * 2;
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);

            const point = g.append('circle')
                .attr('cx', xScale(x))
                .attr('cy', yScale(y))
                .attr('r', 3)
                .attr('fill', '#e74c3c')
                .style('opacity', 0);

            point.transition()
                .duration(500)
                .style('opacity', 1)
                .transition()
                .delay(1000)
                .duration(500)
                .style('opacity', 0)
                .remove();
        }

        setInterval(addRandomPoint, 500);
    }

    // 第5页：3D曲面（使用Three.js）
    function visualize3DSurface() {
        const container = document.getElementById('vis-3d-surface');
        if (!container) return;

        const width = container.clientWidth;
        const height = container.clientHeight;

        // 初始化Three.js场景
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        container.innerHTML = '';
        container.appendChild(renderer.domElement);

        // 添加光源
        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(5, 5, 5);
        scene.add(light1);

        const light2 = new THREE.AmbientLight(0x404040);
        scene.add(light2);

        // 创建抛物面
        const geometry = new THREE.ParametricGeometry((u, v, target) => {
            const x = (u - 0.5) * 4;
            const y = (v - 0.5) * 4;
            const z = x * x + y * y;
            target.set(x, z/2, y);
        }, 50, 50);

        // 彩虹渐变材质
        const material = new THREE.MeshPhongMaterial({
            color: 0x3498db,
            specular: 0x222222,
            shininess: 100,
            side: THREE.DoubleSide,
            vertexColors: true
        });

        // 设置顶点颜色
        const colors = [];
        const color = new THREE.Color();
        const positions = geometry.attributes.position.array;
        
        for (let i = 0; i < positions.length; i += 3) {
            const y = positions[i + 1];
            color.setHSL(y / 4, 1, 0.5);
            colors.push(color.r, color.g, color.b);
        }
        
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // 添加坐标轴
        const axesHelper = new THREE.AxesHelper(3);
        scene.add(axesHelper);

        // 添加网格
        const gridHelper = new THREE.GridHelper(6, 10, 0x888888, 0xcccccc);
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);

        // 鼠标控制
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        container.addEventListener('mousedown', () => isMouseDown = true);
        container.addEventListener('mouseup', () => isMouseDown = false);
        container.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                mouseX = (e.offsetX / width) * 2 - 1;
                mouseY = -(e.offsetY / height) * 2 + 1;
            }
        });

        // 动画
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            if (isMouseDown) {
                mesh.rotation.z += mouseX * 0.05;
                mesh.rotation.x += mouseY * 0.05;
            } else {
                mesh.rotation.z += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        animate();

        // 添加信息面板
        const infoPanel = document.createElement('div');
        infoPanel.className = 'info-panel';
        infoPanel.innerHTML = `
            <h4>抛物面</h4>
            <div class="formula-display">z = x² + y²</div>
            <p>拖动鼠标旋转查看</p>
        `;
        container.appendChild(infoPanel);
    }

    // 第6页：等高线可视化
    function visualizeContour() {
        const setup = setupD3('vis-contour');
        if (!setup) return;
        const { svg, g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);

        // 生成等高线数据
        const levels = [0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4];
        const colors = d3.scaleSequential(d3.interpolateRainbow)
            .domain([0, levels.length]);

        levels.forEach((level, i) => {
            const points = [];
            for (let angle = 0; angle <= 2 * Math.PI; angle += 0.05) {
                const r = Math.sqrt(level);
                points.push([
                    r * Math.cos(angle),
                    r * Math.sin(angle)
                ]);
            }

            const line = d3.line()
                .x(d => xScale(d[0]))
                .y(d => yScale(d[1]))
                .curve(d3.curveCardinalClosed);

            const path = g.append('path')
                .datum(points)
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', colors(i))
                .attr('stroke-width', 2)
                .style('opacity', 0);

            path.transition()
                .delay(i * 200)
                .duration(1000)
                .style('opacity', 1);

            // 标注高度值
            g.append('text')
                .attr('x', xScale(Math.sqrt(level)))
                .attr('y', yScale(0))
                .text(`h=${level}`)
                .style('font-size', '12px')
                .style('fill', colors(i))
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .delay(i * 200 + 500)
                .duration(500)
                .style('opacity', 1);
        });

        // 添加标题
        g.append('text')
            .attr('x', width/2)
            .attr('y', -20)
            .attr('text-anchor', 'middle')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .text('z = x² + y² 的等高线');

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${height/2})`)
            .call(d3.axisBottom(xScale).ticks(5))
            .style('opacity', 0.5);

        g.append('g')
            .attr('transform', `translate(${width/2}, 0)`)
            .call(d3.axisLeft(yScale).ticks(5))
            .style('opacity', 0.5);
    }

    // 第7页：极限概念
    function visualizeLimit() {
        const setup = setupD3('vis-limit');
        if (!setup) return;
        const { g, width, height } = setup;

        const centerX = width/2;
        const centerY = height/2;

        // 目标点
        const targetPoint = g.append('circle')
            .attr('cx', centerX)
            .attr('cy', centerY)
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .style('filter', 'drop-shadow(0 0 10px rgba(231, 76, 60, 0.8))');

        g.append('text')
            .attr('x', centerX)
            .attr('y', centerY - 20)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .text('(x₀, y₀)');

        // 从不同方向接近的动画路径
        const directions = [
            { angle: 0, color: '#3498db', label: '从右' },
            { angle: 90, color: '#2ecc71', label: '从上' },
            { angle: 180, color: '#f39c12', label: '从左' },
            { angle: 270, color: '#9b59b6', label: '从下' },
            { angle: 45, color: '#1abc9c', label: '从右上' },
            { angle: 135, color: '#e67e22', label: '从左上' }
        ];

        directions.forEach((dir, i) => {
            const angle = dir.angle * Math.PI / 180;
            const startX = centerX + 150 * Math.cos(angle);
            const startY = centerY - 150 * Math.sin(angle);

            // 创建移动的点
            const movingPoint = g.append('circle')
                .attr('cx', startX)
                .attr('cy', startY)
                .attr('r', 5)
                .attr('fill', dir.color)
                .style('opacity', 0);

            // 路径线
            const path = g.append('line')
                .attr('x1', startX)
                .attr('y1', startY)
                .attr('x2', startX)
                .attr('y2', startY)
                .attr('stroke', dir.color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,3')
                .style('opacity', 0.3);

            // 标签
            g.append('text')
                .attr('x', startX + 20 * Math.cos(angle))
                .attr('y', startY - 20 * Math.sin(angle))
                .style('font-size', '12px')
                .style('fill', dir.color)
                .text(dir.label)
                .style('opacity', 0)
                .transition()
                .delay(i * 200)
                .duration(500)
                .style('opacity', 1);

            // 动画
            movingPoint.transition()
                .delay(i * 300)
                .duration(200)
                .style('opacity', 1)
                .transition()
                .duration(2000)
                .ease(d3.easeQuadIn)
                .attr('cx', centerX)
                .attr('cy', centerY)
                .style('opacity', 0);

            path.transition()
                .delay(i * 300)
                .duration(2200)
                .attr('x2', centerX)
                .attr('y2', centerY);
        });

        // 结果显示
        setTimeout(() => {
            g.append('text')
                .attr('x', width/2)
                .attr('y', height - 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('fill', '#2ecc71')
                .style('opacity', 0)
                .text('所有方向都趋向于同一个值 L')
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 3000);
    }

    // 第8页：偏导数引入 - 3D曲面上的切线
    function visualizePartialIntro() {
        const container = document.getElementById('vis-partial-intro');
        if (!container) return;

        const width = container.clientWidth;
        const height = container.clientHeight;

        // 创建Three.js场景
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);

        camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(4, 3, 4);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        container.innerHTML = '';
        container.appendChild(renderer.domElement);

        // 光源
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 创建曲面
        const geometry = new THREE.ParametricGeometry((u, v, target) => {
            const x = (u - 0.5) * 4;
            const y = (v - 0.5) * 4;
            const z = Math.sin(x) * Math.cos(y);
            target.set(x, z, y);
        }, 30, 30);

        const material = new THREE.MeshPhongMaterial({
            color: 0x3498db,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // 添加切线（沿x方向）
        const xLineGeometry = new THREE.BufferGeometry();
        const xLinePoints = [];
        for (let t = -2; t <= 2; t += 0.1) {
            xLinePoints.push(new THREE.Vector3(t, Math.sin(t), 0));
        }
        xLineGeometry.setFromPoints(xLinePoints);
        const xLineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
        const xLine = new THREE.Line(xLineGeometry, xLineMaterial);
        scene.add(xLine);

        // 添加切线（沿y方向）
        const yLineGeometry = new THREE.BufferGeometry();
        const yLinePoints = [];
        for (let t = -2; t <= 2; t += 0.1) {
            yLinePoints.push(new THREE.Vector3(0, Math.cos(t), t));
        }
        yLineGeometry.setFromPoints(yLinePoints);
        const yLineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
        const yLine = new THREE.Line(yLineGeometry, yLineMaterial);
        scene.add(yLine);

        // 坐标轴
        const axes = new THREE.AxesHelper(3);
        scene.add(axes);

        // 动画
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            mesh.rotation.z += 0.003;
            renderer.render(scene, camera);
        }
        animate();

        // 添加说明
        const infoPanel = document.createElement('div');
        infoPanel.className = 'info-panel';
        infoPanel.innerHTML = `
            <h4>偏导数的几何意义</h4>
            <p style="color: #ff0000;">红线：沿x方向的切线</p>
            <p style="color: #00ff00;">绿线：沿y方向的切线</p>
        `;
        container.appendChild(infoPanel);
    }

    // 第9页：偏导数定义
    function visualizePartialDef() {
        const setup = setupD3('vis-partial-def');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建两个子图
        const leftG = g.append('g').attr('transform', `translate(0, 0)`);
        const rightG = g.append('g').attr('transform', `translate(${width/2}, 0)`);

        // 左图：对x的偏导
        leftG.append('text')
            .attr('x', width/4)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('fill', '#e74c3c')
            .text('∂f/∂x (y固定)');

        // 绘制曲线
        const xScale = d3.scaleLinear().domain([-2, 2]).range([20, width/2 - 20]);
        const yScale = d3.scaleLinear().domain([-1, 3]).range([height - 40, 60]);

        const data = d3.range(-2, 2.1, 0.1).map(x => ({
            x: x,
            y: x * x
        }));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveBasis);

        leftG.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        // 坐标轴
        leftG.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(5));

        leftG.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale).ticks(5));

        // 切线动画
        const x0 = 1;
        const y0 = 1;
        const slope = 2 * x0;

        const tangentLine = leftG.append('line')
            .attr('x1', xScale(x0 - 0.5))
            .attr('y1', yScale(y0 - 0.5 * slope))
            .attr('x2', xScale(x0 + 0.5))
            .attr('y2', yScale(y0 + 0.5 * slope))
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .style('opacity', 0);

        tangentLine.transition()
            .delay(1000)
            .duration(1000)
            .style('opacity', 1);

        // 切点
        leftG.append('circle')
            .attr('cx', xScale(x0))
            .attr('cy', yScale(y0))
            .attr('r', 0)
            .attr('fill', '#e74c3c')
            .transition()
            .delay(500)
            .duration(500)
            .attr('r', 5);

        // 右图：对y的偏导
        rightG.append('text')
            .attr('x', width/4)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('fill', '#2ecc71')
            .text('∂f/∂y (x固定)');

        const data2 = d3.range(-2, 2.1, 0.1).map(y => ({
            x: y,
            y: Math.sin(y) + 1
        }));

        rightG.append('path')
            .datum(data2)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3);

        // 坐标轴
        rightG.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(5));

        rightG.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale).ticks(5));
    }

    // 第10页：偏导数计算示例
    function visualizePartialCalc() {
        const setup = setupD3('vis-partial-calc');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建计算步骤动画
        const steps = [
            { text: 'z = x²y + 3xy²', y: 80, delay: 0, size: '28px' },
            { text: '计算 ∂z/∂x：', y: 140, delay: 1000, size: '20px', color: '#e74c3c' },
            { text: '把y当常数', y: 180, delay: 1500, size: '16px' },
            { text: '∂z/∂x = 2xy + 3y²', y: 220, delay: 2500, size: '24px', color: '#e74c3c' },
            { text: '计算 ∂z/∂y：', y: 280, delay: 3500, size: '20px', color: '#2ecc71' },
            { text: '把x当常数', y: 320, delay: 4000, size: '16px' },
            { text: '∂z/∂y = x² + 6xy', y: 360, delay: 5000, size: '24px', color: '#2ecc71' }
        ];

        steps.forEach(step => {
            const text = g.append('text')
                .attr('x', width/2)
                .attr('y', step.y)
                .attr('text-anchor', 'middle')
                .style('font-size', step.size || '18px')
                .style('fill', step.color || '#34495e')
                .style('opacity', 0)
                .text(step.text);

            text.transition()
                .delay(step.delay)
                .duration(500)
                .style('opacity', 1);

            // 添加下划线强调
            if (step.color) {
                g.append('line')
                    .attr('x1', width/2 - 80)
                    .attr('x2', width/2 - 80)
                    .attr('y1', step.y + 5)
                    .attr('y2', step.y + 5)
                    .attr('stroke', step.color)
                    .attr('stroke-width', 2)
                    .transition()
                    .delay(step.delay + 200)
                    .duration(800)
                    .attr('x2', width/2 + 80);
            }
        });

        // 添加示意动画
        setTimeout(() => {
            const particle = g.append('circle')
                .attr('cx', width/2 - 100)
                .attr('cy', 220)
                .attr('r', 8)
                .attr('fill', '#f39c12')
                .attr('class', 'pulse');

            particle.transition()
                .duration(1000)
                .attr('cx', width/2 + 100)
                .transition()
                .duration(1000)
                .attr('cy', 360);
        }, 5500);
    }
</script>

</body>
</html>
