<!DOCTYPE html>

<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>第12章：向量代数与空间解析几何 (互动式课件)</title>
<script src="../common-assets/js/d3-7.8.5.min.js"></script>
<script src="../common-assets/js/three-r128.min.js"></script>
<script src="../common-assets/js/mathjax-config.js"></script>
<script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready!');
                    });
                }
            }
        };
    </script>
<script async="" id="MathJax-script" src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js" type="text/javascript">
</script>
<style>
        :root {
            --page-bg: #f0f4f8;
            --card-bg: #ffffff;
            --text-color: #1f2937;
            --primary-color: #2563eb;
            --accent-color: #f97316;
            --muted-color: #64748b;
            --axis-color: #475569;
            --border-color: #e2e8f0;
            --code-bg: #f8fafc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            background: var(--page-bg);
            color: var(--text-color);
            overflow: hidden;
        }

        .slide {
            display: none;
            animation: fadeIn 0.6s ease-in-out;
        }

        .slide.active {
            display: block;
        }

        .slide-container {
            width: 100%;
            height: 100vh;
            display: flex;
            position: relative;
        }

        .slide-container.single-column {
            justify-content: center;
        }

        .left-content {
            width: 50%;
            height: 100vh;
            padding: 48px 56px;
            background: var(--card-bg);
            overflow-y: auto;
            font-size: 17px;
            line-height: 1.9;
            color: var(--text-color);
            border-right: 1px solid var(--border-color);
        }

        .slide-container.single-column .left-content {
            width: 100%;
            max-width: 960px;
            border-right: none;
        }

        .left-content h2 {
            font-size: 2.4rem;
            margin-bottom: 1.2rem;
            color: var(--primary-color);
        }

        .left-content h3 {
            font-size: 1.6rem;
            margin: 1.2rem 0 0.6rem;
            color: var(--axis-color);
        }

        .left-content p {
            margin-bottom: 1rem;
        }

        .left-content ul,
        .left-content ol {
            margin: 1rem 0 1rem 1.25rem;
        }

        .left-content li {
            margin-bottom: 0.6rem;
        }

        .math-formula {
            background: var(--code-bg);
            border-left: 4px solid var(--primary-color);
            padding: 14px 18px;
            margin: 1.2rem 0;
            border-radius: 10px;
            font-size: 1.05rem;
        }

        .highlight {
            color: var(--primary-color);
            font-weight: 600;
        }

        .right-visual {
            width: 50%;
            height: 100vh;
            background: var(--code-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: 1px solid var(--border-color);
            padding: 32px;
        }

        .slide-container.single-column .right-visual {
            display: none;
        }

        .right-visual > div {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--card-bg);
            border-radius: 24px;
            box-shadow: 0 24px 60px rgba(15, 23, 42, 0.12);
            padding: 24px;
        }

        .right-visual > div > * {
            width: 100%;
            height: 100%;
        }

        .right-visual canvas,
        .right-visual svg {
            max-width: 100%;
            max-height: 100%;
        }

        .right-visual svg text {
            fill: var(--text-color);
        }

        .right-visual svg .domain,
        .right-visual svg .tick line {
            stroke: var(--axis-color);
        }

        .nav-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
            backdrop-filter: blur(12px);
            z-index: 1100;
        }

        .nav-btn {
            border: none;
            background: var(--primary-color);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 999px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(37, 99, 235, 0.25);
        }

        .nav-btn:disabled {
            background: #e2e8f0;
            color: var(--muted-color);
            cursor: not-allowed;
            box-shadow: none;
        }

        #page-indicator {
            font-size: 0.95rem;
            color: var(--axis-color);
            min-width: 80px;
            text-align: center;
            font-weight: 600;
        }

        .directory-toggle {
            border: none;
            background: var(--card-bg);
            color: var(--axis-color);
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(15, 23, 42, 0.08);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .directory-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.12);
        }

        .directory-menu {
            position: fixed;
            bottom: 90px;
            right: 24px;
            width: 320px;
            max-height: 60vh;
            overflow-y: auto;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.18);
            display: none;
            z-index: 1200;
        }

        .directory-menu.active {
            display: block;
        }

        .directory-menu h3 {
            margin-bottom: 16px;
            font-size: 1.1rem;
            color: var(--axis-color);
        }

        .directory-item {
            margin-bottom: 12px;
            color: var(--text-color);
            text-decoration: none;
            display: block;
            padding: 10px 12px;
            border-radius: 12px;
            transition: background 0.2s ease;
        }

        .directory-item:hover {
            background: rgba(37, 99, 235, 0.08);
        }

        .global-animation-controls {
            position: fixed;
            bottom: 24px;
            left: 24px;
            display: flex;
            gap: 12px;
            padding: 12px 18px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
            backdrop-filter: blur(12px);
            z-index: 1100;
        }

        .global-control-btn {
            background: transparent;
            border: none;
            color: var(--axis-color);
            padding: 6px 12px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: color 0.2s ease;
        }

        .global-control-btn:hover {
            color: var(--primary-color);
        }

        .global-control-btn.pause {
            color: #dc2626;
        }

        .slide-note {
            font-size: 0.95rem;
            color: var(--muted-color);
            margin-top: 12px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 1200px) {
            .slide-container {
                flex-direction: column;
            }

            .left-content,
            .right-visual {
                width: 100%;
                height: auto;
                min-height: 50vh;
            }

            .right-visual {
                border-left: none;
                border-top: 1px solid var(--border-color);
            }
        }

        @media print {
            body {
                overflow: visible;
            }
            .slide {
                display: block !important;
                page-break-after: always;
            }
            .nav-container,
            .global-animation-controls,
            .directory-menu,
            .directory-toggle {
                display: none !important;
            }
        }
    </style>
<link href="../common-assets/css/chapter-light-overrides.css" rel="stylesheet"/>
<style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
<div id="slidesContainer">
<!-- 第1页：标题页 -->
<div class="slide active"><div class="slide-container single-column"></div></div>
<!-- 第2页：生活中的向量 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>生活中的向量</h2>
<h3>什么时候需要向量？</h3>
<div class="example-card">
<h4>🚗 开车导航</h4>
<p>不仅要知道"距离多远"（10公里），还要知道"往哪个方向"（东北方向）</p>
</div>
<div class="example-card">
<h4>⚽ 踢足球</h4>
<p>踢球的"力度"和"方向"决定了球的轨迹</p>
</div>
<div class="example-card">
<h4>🎮 游戏角色移动</h4>
<p>角色的"速度"和"朝向"控制移动</p>
</div>
<div class="math-formula">
                向量 = 大小 + 方向
            </div>
<p><span class="highlight">记住：</span>向量就像是带箭头的线段，箭头指向告诉我们方向，长度告诉我们大小。</p>
</div><div class="right-visual"><div id="vis-intro"></div></div></div></div>
<!-- 第3页：向量的表示 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>向量的表示方法</h2>
<h3>怎么写出一个向量？</h3>
<p>在平面上（2D）：</p>
<div class="math-formula">
                $\vec{a} = (3, 4)$
            </div>
<p>意思是：向右3个单位，向上4个单位</p>
<p>在空间中（3D）：</p>
<div class="math-formula">
                $\vec{b} = (2, 3, 5)$
            </div>
<p>意思是：向右2个单位，向前3个单位，向上5个单位</p>
<div class="example-card">
<h4>💡 小技巧</h4>
<p>把向量想象成从原点出发的箭头，坐标就是箭头尖端的位置！</p>
</div>
</div><div class="right-visual"><div id="vis-vector-representation"></div></div></div></div>
<!-- 第4页：向量加法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>向量加法</h2>
<h3>向量相加 = 接力赛</h3>
<div class="example-card">
<h4>🏃 接力赛原理</h4>
<p>第一个人跑完后，第二个人从他停下的地方继续跑</p>
</div>
<p>数学表示：</p>
<div class="math-formula">
                $\vec{a} + \vec{b} = (a_x + b_x, a_y + b_y)$
            </div>
<p>实例：</p>
<p>$\vec{a} = (3, 2)$，$\vec{b} = (1, 4)$</p>
<p>$\vec{a} + \vec{b} = (3+1, 2+4) = (4, 6)$</p>
<p><span class="highlight">记忆方法：</span>对应坐标相加即可！</p>
</div><div class="right-visual"><div id="vis-vector-addition"></div></div></div></div>
<!-- 第5页：向量减法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>向量减法</h2>
<h3>向量相减 = 求位移</h3>
<div class="example-card">
<h4>🎯 从A点到B点</h4>
<p>向量减法告诉我们：从一个位置到另一个位置要怎么走</p>
</div>
<div class="math-formula">
                $\vec{a} - \vec{b} = (a_x - b_x, a_y - b_y)$
            </div>
<p>实例：</p>
<p>小明在$(5, 3)$，小红在$(2, 1)$</p>
<p>从小红走到小明：$(5-2, 3-1) = (3, 2)$</p>
<p>意思是：向右走3步，向前走2步</p>
<p><span class="highlight">技巧：</span>终点坐标 - 起点坐标 = 位移向量</p>
</div><div class="right-visual"><div id="vis-vector-subtraction"></div></div></div></div>
<!-- 第6页：向量数乘 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>向量的数乘</h2>
<h3>数乘 = 缩放向量</h3>
<div class="math-formula">
                $k \cdot \vec{a} = (k \cdot a_x, k \cdot a_y)$
            </div>
<div class="example-card">
<h4>不同k值的效果：</h4>
<ul>
<li>$k = 2$：向量变为2倍长</li>
<li>$k = 0.5$：向量变为一半长</li>
<li>$k = -1$：向量反向</li>
<li>$k = 0$：变成零向量</li>
</ul>
</div>
<p>实例：速度加倍</p>
<p>原速度：$\vec{v} = (3, 4)$ km/h</p>
<p>加速2倍：$2\vec{v} = (6, 8)$ km/h</p>
<p><span class="highlight">形象理解：</span>像调节音量一样调节向量的"强度"</p>
</div><div class="right-visual"><div id="vis-scalar-multiplication"></div></div></div></div>
<!-- 第7页：点积 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>向量的点积</h2>
<h3>点积 = 投影 × 长度</h3>
<div class="math-formula">
                $\vec{a} \cdot \vec{b} = a_x b_x + a_y b_y + a_z b_z$
            </div>
<div class="example-card">
<h4>🔦 手电筒照墙</h4>
<p>点积就像手电筒光束在墙上的投影长度</p>
</div>
<p>点积的含义：</p>
<ul>
<li>结果 &gt; 0：两向量夹角 &lt; 90°（同向）</li>
<li>结果 = 0：两向量垂直</li>
<li>结果 &lt; 0：两向量夹角 &gt; 90°（反向）</li>
</ul>
<p><span class="highlight">应用：</span>计算功、判断垂直、求夹角</p>
</div><div class="right-visual"><div id="vis-dot-product"></div></div></div></div>
<!-- 第8页：叉积 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>向量的叉积</h2>
<h3>叉积 = 垂直新向量</h3>
<div class="math-formula">
                $\vec{a} \times \vec{b} = $ 垂直于$\vec{a}$和$\vec{b}$的新向量
            </div>
<div class="example-card">
<h4>🔩 螺丝钉原理</h4>
<p>右手握住螺丝，四指从$\vec{a}$转向$\vec{b}$，大拇指指向就是叉积方向</p>
</div>
<p>叉积的特点：</p>
<ul>
<li>结果是一个<span class="highlight">新向量</span></li>
<li>垂直于原来两个向量</li>
<li>大小等于平行四边形面积</li>
</ul>
<p><span class="highlight">应用：</span>计算法向量、力矩、面积</p>
</div><div class="right-visual"><div id="vis-cross-product"></div></div></div></div>
<!-- 第9页：空间坐标系 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>空间直角坐标系</h2>
<h3>三维定位系统</h3>
<div class="example-card">
<h4>🏢 楼层定位</h4>
<p>X轴：东西方向（左右）</p>
<p>Y轴：南北方向（前后）</p>
<p>Z轴：上下方向（楼层）</p>
</div>
<p>空间中任意一点：</p>
<div class="math-formula">
                $P(x, y, z)$
            </div>
<p>例如：$P(3, 4, 5)$表示：</p>
<ul>
<li>向东3米</li>
<li>向北4米</li>
<li>向上5米（5楼）</li>
</ul>
<p><span class="highlight">记忆技巧：</span>伸出右手，拇指X、食指Y、中指Z</p>
</div><div class="right-visual"><div id="vis-3d-coordinate"></div></div></div></div>
<!-- 第10页：总结 -->
<div class="slide"><div class="slide-container single-column"><div class="left-content tex2jax_process">
<h2 style="font-size: 3rem; margin-bottom: 30px">本章小结</h2>
<div style="display: grid; gap: 20px; text-align: left">
<div class="example-card">
<h4>向量基础</h4>
<ul>
<li>向量 = 大小 + 方向</li>
<li>用坐标表示：(x, y, z)</li>
<li>可以相加、相减、数乘</li>
</ul>
</div>
<div class="example-card">
<h4>向量运算</h4>
<ul>
<li>点积：判断夹角关系</li>
<li>叉积：得到垂直向量</li>
<li>应用于力学、图形学</li>
</ul>
</div>
<div class="example-card">
<h4>空间几何</h4>
<ul>
<li>三维坐标系定位</li>
<li>点、线、面的描述</li>
<li>距离和角度计算</li>
</ul>
</div>
<div class="example-card">
<h4>实际应用</h4>
<ul>
<li>游戏开发中的移动</li>
<li>工程中的力分析</li>
<li>导航中的方向计算</li>
</ul>
</div>
</div>
<p style="margin-top: 30px; font-size: 1.2rem">
                恭喜你！现在你已经掌握了向量的基本知识！
            </p>
</div></div></div>
</div>
<!-- 页码指示器 -->
<!-- 翻页按钮 -->
<!-- 全局动画控制面板 -->
<div class="nav-container">
<button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">上一页</button>
<span id="page-indicator">1 / 9</span>
<button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">下一页</button>
</div>
<div class="global-animation-controls" id="globalAnimationControls">
<button class="global-control-btn" id="globalPlayPauseBtn">暂停</button>
<button class="global-control-btn" id="globalSpeedBtn">1.0x</button>
</div>
<script>
    // 全局变量
    let currentSlide = 0;
    let slides = null;
    let totalSlides = 0;
    let threeScenes = {};
    let globalAnimationPlaying = true;
    let globalAnimationSpeed = 1.0;
    let animationFrames = [];

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        
        // 显示第一张幻灯片
        showSlide(0);
        
        // 键盘导航
        document.addEventListener('keydown', handleKeyNavigation);
        
        // 初始化全局动画控制
        initGlobalAnimationControls();
        
        // 初始化浮动菜单
        initFloatingMenu();
    });

    // 显示指定幻灯片
    function showSlide(index) {
        // 清理之前的动画
        cleanupAnimations();
        
        // 隐藏所有幻灯片
        slides.forEach(slide => slide.classList.remove('active'));
        
        // 显示当前幻灯片
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        // 更新页码
        updatePageIndicator();
        
        // 更新按钮状态
        updateNavigationButtons();
        
        // 运行当前幻灯片的可视化
        runVisualization(currentSlide);
    }

    // 下一页
    function nextSlide() {
        if (currentSlide < totalSlides - 1) {
            showSlide(currentSlide + 1);
        }
    }

    // 上一页
    function previousSlide() {
        if (currentSlide > 0) {
            showSlide(currentSlide - 1);
        }
    }

    // 更新页码指示器
    function updatePageIndicator() {
        const indicator = document.getElementById('page-indicator');
        indicator.textContent = `${currentSlide + 1} / ${totalSlides}`;
    }

    // 更新导航按钮状态
    function updateNavigationButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        prevBtn.disabled = currentSlide === 0;
        nextBtn.disabled = currentSlide === totalSlides - 1;
    }

    // 键盘导航
    function handleKeyNavigation(e) {
        if (e.key === 'ArrowRight' || e.key === ' ') {
            e.preventDefault();
            nextSlide();
        } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            previousSlide();
        }
    }

    // 初始化全局动画控制
    function initGlobalAnimationControls() {
        const playPauseBtn = document.getElementById('globalPlayPauseBtn');
        const speedBtn = document.getElementById('globalSpeedBtn');
        
        const speedOptions = [0.5, 1, 1.5, 2, 3];
        let currentSpeedIndex = 1;
        
        playPauseBtn.addEventListener('click', () => {
            globalAnimationPlaying = !globalAnimationPlaying;
            playPauseBtn.textContent = globalAnimationPlaying ? '暂停' : '播放';
        });
        
        speedBtn.addEventListener('click', () => {
            currentSpeedIndex = (currentSpeedIndex + 1) % speedOptions.length;
            globalAnimationSpeed = speedOptions[currentSpeedIndex];
            speedBtn.textContent = globalAnimationSpeed.toFixed(1) + 'x';
        });
    }

    // 初始化浮动菜单
    function initFloatingMenu() {
        const menuToggle = document.getElementById('menu-toggle');
        const menuContent = document.getElementById('menu-content');
        
        if (menuToggle && menuContent) {
            menuToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                menuToggle.classList.toggle('active');
                menuContent.classList.toggle('active');
            });
            
            document.addEventListener('click', function(e) {
                if (!menuToggle.contains(e.target) && !menuContent.contains(e.target)) {
                    menuToggle.classList.remove('active');
                    menuContent.classList.remove('active');
                }
            });
        }
    }

    // 清理动画
    function cleanupAnimations() {
        animationFrames.forEach(frame => cancelAnimationFrame(frame));
        animationFrames = [];
        
        // 清理Three.js场景
        Object.values(threeScenes).forEach(scene => {
            if (scene && scene.renderer) {
                scene.renderer.dispose();
                if (scene.container && scene.container.firstChild) {
                    scene.container.removeChild(scene.container.firstChild);
                }
            }
        });
        threeScenes = {};
    }

    // 运行可视化
    function runVisualization(slideIndex) {
        switch(slideIndex) {
            case 1:
                visualizeIntro();
                break;
            case 2:
                visualizeVectorRepresentation();
                break;
            case 3:
                visualizeVectorAddition();
                break;
            case 4:
                visualizeVectorSubtraction();
                break;
            case 5:
                visualizeScalarMultiplication();
                break;
            case 6:
                visualizeDotProduct();
                break;
            case 7:
                visualizeCrossProduct();
                break;
            case 8:
                visualize3DCoordinate();
                break;
        }
    }

    // 可视化函数：生活中的向量
    function visualizeIntro() {
        const container = document.getElementById('vis-intro');
        if (!container) return;
        container.innerHTML = '';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // 创建多个生活实例动画
        const examples = [
            {
                x: width * 0.25,
                y: height * 0.3,
                icon: '🚗',
                dx: 100,
                dy: -60,
                label: '导航：向东北10公里',
                color: '#3498db'
            },
            {
                x: width * 0.75,
                y: height * 0.3,
                icon: '⚽',
                dx: -80,
                dy: 80,
                label: '踢球：45度角，20米/秒',
                color: '#2ecc71'
            },
            {
                x: width * 0.5,
                y: height * 0.7,
                icon: '✈️',
                dx: 120,
                dy: -40,
                label: '飞机：爬升角30度',
                color: '#e74c3c'
            }
        ];
        
        examples.forEach((ex, i) => {
            const g = svg.append('g');
            
            // 图标
            g.append('text')
                .attr('x', ex.x)
                .attr('y', ex.y)
                .attr('font-size', '40px')
                .attr('text-anchor', 'middle')
                .text(ex.icon)
                .style('opacity', 0)
                .transition()
                .delay(i * 500)
                .duration(500)
                .style('opacity', 1);
            
            // 定义箭头标记
            svg.append('defs')
                .append('marker')
                .attr('id', `arrow-${i}`)
                .attr('viewBox', '0 0 10 10')
                .attr('refX', 8)
                .attr('refY', 5)
                .attr('markerWidth', 8)
                .attr('markerHeight', 8)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M 0 0 L 10 5 L 0 10 z')
                .attr('fill', ex.color);
            
            // 向量箭头
            g.append('line')
                .attr('x1', ex.x)
                .attr('y1', ex.y + 20)
                .attr('x2', ex.x)
                .attr('y2', ex.y + 20)
                .attr('stroke', ex.color)
                .attr('stroke-width', 3)
                .attr('marker-end', `url(#arrow-${i})`)
                .transition()
                .delay(i * 500 + 500)
                .duration(1000)
                .attr('x2', ex.x + ex.dx)
                .attr('y2', ex.y + 20 + ex.dy);
            
            // 标签
            g.append('text')
                .attr('x', ex.x + ex.dx / 2)
                .attr('y', ex.y + 20 + ex.dy / 2 - 10)
                .attr('text-anchor', 'middle')
                .attr('fill', themeColors.text)
                .style('font-size', '14px')
                .text(ex.label)
                .style('opacity', 0)
                .transition()
                .delay(i * 500 + 1500)
                .duration(500)
                .style('opacity', 1);
        });
    }

    // 可视化函数：向量表示（3D）
    function visualizeVectorRepresentation() {
        const container = document.getElementById('vis-vector-representation');
        if (!container) return;
        container.innerHTML = '';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // 创建Three.js场景
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);
        
        // 相机位置
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);
        
        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // 创建坐标轴
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        
        // 创建网格平面
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // 创建向量
        const origin = new THREE.Vector3(0, 0, 0);
        const vector = new THREE.Vector3(3, 4, 2);
        
        // 向量箭头
        const arrowHelper = new THREE.ArrowHelper(
            vector.clone().normalize(),
            origin,
            vector.length(),
            0x00ffff,
            1,
            1
        );
        scene.add(arrowHelper);
        
        // 创建坐标点
        const pointGeometry = new THREE.SphereGeometry(0.2);
        const pointMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.5
        });
        const point = new THREE.Mesh(pointGeometry, pointMaterial);
        point.position.copy(vector);
        scene.add(point);
        
        // 添加信息面板
        const infoPanel = document.createElement('div');
        infoPanel.className = 'info-panel';
        infoPanel.innerHTML = `
            <h4>向量坐标</h4>
            <p>X = 3（向右）</p>
            <p>Y = 4（向上）</p>
            <p>Z = 2（向前）</p>
            <p>长度 = ${vector.length().toFixed(2)}</p>
        `;
        container.appendChild(infoPanel);
        
        // 动画
        function animate() {
            const frame = requestAnimationFrame(animate);
            animationFrames.push(frame);
            
            if (globalAnimationPlaying) {
                scene.rotation.y += 0.005 * globalAnimationSpeed;
            }
            
            renderer.render(scene, camera);
        }
        animate();
        
        // 保存场景引用
        threeScenes['vector-representation'] = { 
            scene, 
            camera, 
            renderer,
            container
        };
    }

    // 可视化函数：向量加法
    function visualizeVectorAddition() {
        const container = document.getElementById('vis-vector-addition');
        if (!container) return;
        container.innerHTML = '';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // 坐标系
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 40;
        
        // 绘制坐标轴
        drawCoordinateSystem(svg, centerX, centerY, scale);
        
        const v1 = {x: 3, y: 2};
        const v2 = {x: 1, y: 4};
        const sum = {x: v1.x + v2.x, y: v1.y + v2.y};
        
        const g = svg.append('g');
        
        // 动画序列
        setTimeout(() => {
            drawAnimatedVector(g, centerX, centerY, 
                v1.x * scale, -v1.y * scale, '#3498db', 0, 'v₁');
        }, 0);
        
        setTimeout(() => {
            drawAnimatedVector(g, 
                centerX + v1.x * scale, 
                centerY - v1.y * scale, 
                v2.x * scale, 
                -v2.y * scale, 
                '#2ecc71', 
                0,
                'v₂'
            );
        }, 1500);
        
        setTimeout(() => {
            drawAnimatedVector(g, centerX, centerY, 
                sum.x * scale, -sum.y * scale, '#e74c3c', 0, 'v₁ + v₂');
            
            // 添加说明文字
            g.append('text')
                .attr('x', centerX)
                .attr('y', height - 50)
                .attr('text-anchor', 'middle')
                .attr('fill', themeColors.text)
                .style('font-size', '16px')
                .text('向量加法：首尾相接法则');
        }, 3000);
    }

    // 可视化函数：向量减法
    function visualizeVectorSubtraction() {
        const container = document.getElementById('vis-vector-subtraction');
        if (!container) return;
        container.innerHTML = '';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 40;
        
        drawCoordinateSystem(svg, centerX, centerY, scale);
        
        const v1 = {x: 4, y: 3};
        const v2 = {x: 2, y: 1};
        const diff = {x: v1.x - v2.x, y: v1.y - v2.y};
        
        const g = svg.append('g');
        
        // 画出两个向量
        setTimeout(() => {
            drawAnimatedVector(g, centerX, centerY, 
                v1.x * scale, -v1.y * scale, '#3498db', 0, 'v₁');
            drawAnimatedVector(g, centerX, centerY, 
                v2.x * scale, -v2.y * scale, '#2ecc71', 500, 'v₂');
        }, 0);
        
        // 画出差向量
        setTimeout(() => {
            drawAnimatedVector(g, 
                centerX + v2.x * scale, 
                centerY - v2.y * scale, 
                diff.x * scale, 
                -diff.y * scale, 
                '#e74c3c', 
                0, 
                'v₁ - v₂'
            );
            
            g.append('text')
                .attr('x', centerX)
                .attr('y', height - 50)
                .attr('text-anchor', 'middle')
                .attr('fill', themeColors.text)
                .style('font-size', '16px')
                .text('向量减法：从v₂指向v₁');
        }, 2000);
    }

    // 可视化函数：数乘
    function visualizeScalarMultiplication() {
        const container = document.getElementById('vis-scalar-multiplication');
        if (!container) return;
        container.innerHTML = '';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 30;
        
        drawCoordinateSystem(svg, centerX, centerY, scale);
        
        const v = {x: 2, y: 1.5};
        const scalars = [0.5, 1, 2, -1];
        const colors = ['#f39c12', '#3498db', '#2ecc71', '#e74c3c'];
        
        const g = svg.append('g');
        
        scalars.forEach((k, i) => {
            setTimeout(() => {
                drawAnimatedVector(g, centerX, centerY, 
                    v.x * k * scale, -v.y * k * scale, 
                    colors[i], 0, `${k}v`);
            }, i * 1000);
        });
        
        setTimeout(() => {
            g.append('text')
                .attr('x', centerX)
                .attr('y', height - 50)
                .attr('text-anchor', 'middle')
                .attr('fill', themeColors.text)
                .style('font-size', '16px')
                .text('数乘：改变向量长度和方向');
        }, 4000);
    }

    // 可视化函数：点积
    function visualizeDotProduct() {
        const container = document.getElementById('vis-dot-product');
        if (!container) return;
        container.innerHTML = '';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const centerX = width / 2;
        const centerY = height / 2;
        const scale = 50;
        
        drawCoordinateSystem(svg, centerX, centerY, scale);
        
        const v1 = {x: 3, y: 1};
        const v2 = {x: 2, y: 2};
        
        const g = svg.append('g');
        
        // 画向量
        drawAnimatedVector(g, centerX, centerY, 
            v1.x * scale, -v1.y * scale, '#3498db', 0, 'a');
        drawAnimatedVector(g, centerX, centerY, 
            v2.x * scale, -v2.y * scale, '#2ecc71', 500, 'b');
        
        // 计算点积
        const dotProduct = v1.x * v2.x + v1.y * v2.y;
        const angle = Math.acos(dotProduct / 
            (Math.sqrt(v1.x*v1.x + v1.y*v1.y) * 
             Math.sqrt(v2.x*v2.x + v2.y*v2.y)));
        
        // 画投影线
        setTimeout(() => {
            const projLength = Math.sqrt(v1.x*v1.x + v1.y*v1.y) * Math.cos(angle);
            const projX = projLength * v2.x / Math.sqrt(v2.x*v2.x + v2.y*v2.y);
            const projY = projLength * v2.y / Math.sqrt(v2.x*v2.x + v2.y*v2.y);
            
            g.append('line')
                .attr('x1', centerX + v1.x * scale)
                .attr('y1', centerY - v1.y * scale)
                .attr('x2', centerX + projX * scale)
                .attr('y2', centerY - projY * scale)
                .attr('stroke', '#f39c12')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
            
            // 显示结果
            g.append('text')
                .attr('x', centerX)
                .attr('y', 50)
                .attr('text-anchor', 'middle')
                .attr('fill', themeColors.text)
                .style('font-size', '18px')
                .text(`a·b = ${dotProduct.toFixed(1)}`);
            
            g.append('text')
                .attr('x', centerX)
                .attr('y', height - 50)
                .attr('text-anchor', 'middle')
                .attr('fill', themeColors.text)
                .style('font-size', '16px')
                .text(`夹角 = ${(angle * 180 / Math.PI).toFixed(1)}°`);
        }, 1500);
    }

    // 可视化函数：叉积（3D）
    function visualizeCrossProduct() {
        const container = document.getElementById('vis-cross-product');
        if (!container) return;
        container.innerHTML = '';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // 创建Three.js场景
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);
        
        camera.position.set(8, 8, 8);
        camera.lookAt(0, 0, 0);
        
        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // 坐标轴
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        
        // 创建向量
        const v1 = new THREE.Vector3(3, 0, 0);
        const v2 = new THREE.Vector3(0, 3, 0);
        const cross = new THREE.Vector3();
        cross.crossVectors(v1, v2);
        
        // 向量箭头
        const arrow1 = new THREE.ArrowHelper(v1.clone().normalize(), 
            new THREE.Vector3(0, 0, 0), v1.length(), 0x3498db, 1, 1);
        const arrow2 = new THREE.ArrowHelper(v2.clone().normalize(), 
            new THREE.Vector3(0, 0, 0), v2.length(), 0x2ecc71, 1, 1);
        const arrow3 = new THREE.ArrowHelper(cross.clone().normalize(), 
            new THREE.Vector3(0, 0, 0), cross.length(), 0xe74c3c, 1, 1);
        
        scene.add(arrow1);
        scene.add(arrow2);
        
        // 延迟添加叉积向量
        setTimeout(() => {
            scene.add(arrow3);
        }, 1500);
        
        // 添加平面表示
        const planeGeometry = new THREE.PlaneGeometry(3, 3);
        const planeMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.2
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.set(1.5, 1.5, 0);
        scene.add(plane);
        
        // 信息面板
        const infoPanel = document.createElement('div');
        infoPanel.className = 'info-panel';
        infoPanel.innerHTML = `
            <h4>向量叉积</h4>
            <p>蓝色 × 绿色 = 红色</p>
            <p>红色向量垂直于蓝绿平面</p>
            <p>大小 = 平行四边形面积</p>
        `;
        container.appendChild(infoPanel);
        
        // 动画
        function animate() {
            const frame = requestAnimationFrame(animate);
            animationFrames.push(frame);
            
            if (globalAnimationPlaying) {
                scene.rotation.y += 0.005 * globalAnimationSpeed;
            }
            
            renderer.render(scene, camera);
        }
        animate();
        
        threeScenes['cross-product'] = { scene, camera, renderer, container };
    }

    // 可视化函数：3D坐标系
    function visualize3DCoordinate() {
        const container = document.getElementById('vis-3d-coordinate');
        if (!container) return;
        container.innerHTML = '';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // 创建Three.js场景
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);
        
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);
        
        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // 创建更大的坐标轴
        const axesHelper = new THREE.AxesHelper(6);
        scene.add(axesHelper);
        
        // 创建网格
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // 创建一个示例点 P(3, 4, 5)
        const pointGeometry = new THREE.SphereGeometry(0.3);
        const pointMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.5
        });
        const point = new THREE.Mesh(pointGeometry, pointMaterial);
        point.position.set(3, 5, 4); // 注意Three.js中Y是向上的
        scene.add(point);
        
        // 从原点到点的向量
        const arrowHelper = new THREE.ArrowHelper(
            new THREE.Vector3(3, 5, 4).normalize(),
            new THREE.Vector3(0, 0, 0),
            Math.sqrt(3*3 + 5*5 + 4*4),
            0x00ffff,
            1,
            1
        );
        scene.add(arrowHelper);
        
        // 添加投影线
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffff00,
            linewidth: 2,
            transparent: true,
            opacity: 0.5
        });
        
        // XY平面投影
        const xyProjection = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(3, 0, 0),
            new THREE.Vector3(3, 0, 4),
            new THREE.Vector3(0, 0, 4),
            new THREE.Vector3(0, 0, 0)
        ]);
        const xyLine = new THREE.Line(xyProjection, lineMaterial);
        scene.add(xyLine);
        
        // 垂直线
        const verticalLine = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(3, 0, 4),
            new THREE.Vector3(3, 5, 4)
        ]);
        const vLine = new THREE.Line(verticalLine, lineMaterial);
        scene.add(vLine);
        
        // 信息面板
        const infoPanel = document.createElement('div');
        infoPanel.className = 'info-panel';
        infoPanel.innerHTML = `
            <h4>空间点 P(3, 4, 5)</h4>
            <p>X = 3（向右）</p>
            <p>Y = 4（向前）</p>
            <p>Z = 5（向上）</p>
            <p>距离 = ${Math.sqrt(3*3 + 4*4 + 5*5).toFixed(2)}</p>
        `;
        container.appendChild(infoPanel);
        
        // 控制面板
        const controlPanel = document.createElement('div');
        controlPanel.className = 'control-panel';
        controlPanel.innerHTML = `
            <button class="control-btn" onclick="resetView()">重置视角</button>
            <button class="control-btn" onclick="toggleRotation()">旋转开关</button>
        `;
        container.appendChild(controlPanel);
        
        let isRotating = true;
        
        window.resetView = function() {
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
        };
        
        window.toggleRotation = function() {
            isRotating = !isRotating;
        };
        
        // 动画
        function animate() {
            const frame = requestAnimationFrame(animate);
            animationFrames.push(frame);
            
            if (globalAnimationPlaying && isRotating) {
                scene.rotation.y += 0.005 * globalAnimationSpeed;
            }
            
            renderer.render(scene, camera);
        }
        animate();
        
        threeScenes['3d-coordinate'] = { scene, camera, renderer, container };
    }

    // 辅助函数：绘制坐标系
    function drawCoordinateSystem(svg, centerX, centerY, scale) {
        const g = svg.append('g');
        
        // X轴
        g.append('line')
            .attr('x1', 0)
            .attr('y1', centerY)
            .attr('x2', svg.attr('width') || centerX * 2)
            .attr('y2', centerY)
            .attr('stroke', 'rgba(255, 255, 255, 0.3)')
            .attr('stroke-width', 1);
        
        // Y轴
        g.append('line')
            .attr('x1', centerX)
            .attr('y1', 0)
            .attr('x2', centerX)
            .attr('y2', svg.attr('height') || centerY * 2)
            .attr('stroke', 'rgba(255, 255, 255, 0.3)')
            .attr('stroke-width', 1);
        
        // 网格线
        for (let i = -10; i <= 10; i++) {
            if (i !== 0) {
                // 竖线
                g.append('line')
                    .attr('x1', centerX + i * scale)
                    .attr('y1', 0)
                    .attr('x2', centerX + i * scale)
                    .attr('y2', centerY * 2)
                    .attr('stroke', 'rgba(255, 255, 255, 0.1)')
                    .attr('stroke-width', 0.5);
                
                // 横线
                g.append('line')
                    .attr('x1', 0)
                    .attr('y1', centerY + i * scale)
                    .attr('x2', centerX * 2)
                    .attr('y2', centerY + i * scale)
                    .attr('stroke', 'rgba(255, 255, 255, 0.1)')
                    .attr('stroke-width', 0.5);
            }
        }
        
        // 坐标轴标签
        g.append('text')
            .attr('x', centerX * 2 - 20)
            .attr('y', centerY - 10)
            .attr('fill', 'rgba(255, 255, 255, 0.7)')
            .style('font-size', '14px')
            .text('X');
        
        g.append('text')
            .attr('x', centerX + 10)
            .attr('y', 20)
            .attr('fill', 'rgba(255, 255, 255, 0.7)')
            .style('font-size', '14px')
            .text('Y');
    }

    // 辅助函数：绘制动画向量
    function drawAnimatedVector(g, x1, y1, dx, dy, color, delay, label) {
        const group = g.append('g');
        
        // 向量主体
        const line = group.append('line')
            .attr('x1', x1)
            .attr('y1', y1)
            .attr('x2', x1)
            .attr('y2', y1)
            .attr('stroke', color)
            .attr('stroke-width', 3)
            .style('filter', `drop-shadow(0 0 10px ${color})`);
        
        line.transition()
            .delay(delay)
            .duration(1000 / globalAnimationSpeed)
            .attr('x2', x1 + dx)
            .attr('y2', y1 + dy);
        
        // 箭头
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        const arrow = group.append('polygon')
            .attr('points', '0,0 -15,-5 -15,5')
            .attr('fill', color)
            .attr('transform', `translate(${x1 + dx}, ${y1 + dy}) rotate(${angle})`)
            .style('opacity', 0);
        
        arrow.transition()
            .delay(delay + 1000)
            .duration(500)
            .style('opacity', 1);
        
        // 标签
        if (label) {
            group.append('text')
                .attr('x', x1 + dx / 2)
                .attr('y', y1 + dy / 2 - 10)
                .attr('text-anchor', 'middle')
                .attr('fill', color)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .text(label)
                .style('opacity', 0)
                .transition()
                .delay(delay + 1200)
                .duration(500)
                .style('opacity', 1);
        }
    }

    // 渲染MathJax公式
    if (window.MathJax) {
        window.MathJax.startup.defaultReady();
    }
</script>
</body>
</html>
