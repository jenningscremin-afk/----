<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多元函数积分学 (交互式课件)</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <script src="../common-assets/js/three-r128.min.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready');
                    });
                }
            }
        };
    </script>
    <script src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js"></script>
    <style>
        @import url('../common-assets/css/google-fonts.css');

        :root {
            --chalkboard-bg: transparent;
            --chalk-text: #ecf0f1;
            --visualization-bg: #fdfdfd00;
            --primary-color: #3498db;
            --accent-color: #e67e22;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #9b59b6;
            --text-color: #34495e;
            --heading-font: 'Noto Serif SC', serif;
            --handwriting-font: 'Noto Serif SC', serif;
        }

        body {
            font-family: var(--heading-font);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: auto;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
        }

        #presentation-container {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            aspect-ratio: 16 / 9;
            position: relative;
            background: rgba(255, 255, 255, 0);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: auto;
        }

        .slide {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            display: flex;
            transition: opacity 0.6s ease-in-out;
            background-color: var(--visualization-bg);
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            z-index: 10;
        }

        .chalkboard {
            flex: 0 0 35%;
            background-color: transparent !important;
            background: transparent !important;
            color: var(--chalk-text);
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border-right: 5px solid #bdc3c7;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .chalkboard h2 {
            font-family: var(--handwriting-font);
            font-size: 2.8rem;
            color: #f1c40f;
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .chalkboard h3 {
            font-family: var(--handwriting-font);
            font-size: 1.8rem;
            color: var(--primary-color);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .chalkboard p, .chalkboard li {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 15px;
        }

        .chalkboard ol {
            padding-left: 25px;
        }

        .chalkboard ul {
            list-style-type: '→ ';
            padding-left: 20px;
        }

        .math-formula {
            font-size: 1.3rem;
            color: #1abc9c;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin: 15px 0;
            line-height: 1.5;
        }

        .highlight {
            color: var(--warning-color);
            font-weight: bold;
        }

        .visualization {
            flex: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            background: linear-gradient(135deg, #f5f7fa 10%, #c3cfe2 100%);
            position: relative;
            box-sizing: border-box;
        }

        .visualization.full-width {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }

        .visualization.white-bg {
            background: white;
        }

        .value-display {
            position: absolute;
            top: 150px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            min-width: 150px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .value-item {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .value-item:last-child {
            margin-bottom: 0;
        }

        .value-label {
            font-size: 12px;
            color: #ccc;
            margin-right: 10px;
        }

        .value-number {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-align: right;
        }

        .vis-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .vis-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .formula-rule {
            font-size: 1.2rem;
            color: #16a085;
            background: rgba(0,0,0,0.15);
            padding: 12px;
            border-radius: 5px;
            margin: 10px 0;
        }

        /* 导航按钮样式 */
        .nav-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            user-select: none;
            min-width: 40px;
            text-align: center;
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
        }

        .nav-btn:active {
            transform: translateY(0);
            background: rgba(0, 0, 0, 0.9);
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .nav-btn:disabled:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: rgba(255, 255, 255, 0.3);
            transform: none;
        }

        .page-indicator {
            position: absolute;
            top: 20px;
            right: 90px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .nav-hint {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            z-index: 100;
            opacity: 0.8;
            backdrop-filter: blur(10px);
        }

        /* 动画控制面板 */
        .animation-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            z-index: 101;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
        }

        .animation-controls.active { 
            display: flex; 
        }

        .control-btn { 
            width: 35px; 
            height: 35px; 
            border: none; 
            border-radius: 50%; 
            background: #3498db; 
            color: white; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 14px; 
            transition: all 0.3s ease; 
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3); 
        }

        .control-btn:hover { 
            background: #2980b9; 
            transform: translateY(-2px); 
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.5); 
        }

        .control-btn.play-pause { 
            width: 45px; 
            height: 45px; 
            background: #e74c3c; 
            font-size: 16px; 
        }

        .control-btn.play-pause:hover { 
            background: #c0392b; 
        }

        .control-btn.paused { 
            background: #27ae60; 
        }

        .control-btn.paused:hover { 
            background: #229954; 
        }

        .speed-indicator { 
            font-size: 14px; 
            font-weight: bold; 
            color: #2c3e50; 
            min-width: 40px; 
            text-align: center; 
        }

        /* 3D可视化容器 */
        #three-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* 滑块样式 */
        .slider-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 30px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .slider {
            width: 200px;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }

        .slider-label {
            font-size: 14px;
            font-weight: bold;
            color: var(--text-color);
        }

        /* 网格样式 */
        .grid-lines {
            stroke: #e0e0e0;
            stroke-width: 0.5;
            opacity: 0.5;
        }

        .axis-line {
            stroke: #333;
            stroke-width: 2;
        }

        .axis-label {
            font-size: 14px;
            fill: #333;
        }

        /* 积分区域高亮 */
        .integration-region {
            fill: var(--primary-color);
            opacity: 0.3;
            stroke: var(--primary-color);
            stroke-width: 2;
        }

        /* 曲面样式 */
        .surface-mesh {
            stroke: #999;
            stroke-width: 0.5;
            fill: none;
        }

        .surface-fill {
            fill: url(#surface-gradient);
            opacity: 0.7;
        }

        /* 坐标点标记 */
        .coordinate-point {
            fill: var(--danger-color);
            stroke: white;
            stroke-width: 2;
        }

        .coordinate-label {
            font-size: 12px;
            fill: var(--danger-color);
            font-weight: bold;
        }

        /* 积分路径动画 */
        @keyframes integralPath {
            0% { stroke-dashoffset: 1000; }
            100% { stroke-dashoffset: 0; }
        }

        .integral-path {
            stroke: var(--success-color);
            stroke-width: 3;
            fill: none;
            stroke-dasharray: 5, 5;
            animation: integralPath 2s linear infinite;
        }

        /* 数值显示面板 */
        .result-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .result-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .result-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
        }

        /* 图例 */
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        /* 交互提示 */
        .interaction-hint {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            opacity: 0;
            animation: fadeInOut 3s ease-in-out infinite;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.9; }
        }

        /* 加载动画 */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: var(--primary-color);
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        @keyframes twinkle { 
            0%, 100% { opacity: 0.3; } 
            50% { opacity: 1; } 
        }
        
        .pulse { 
            animation: pulse 2s ease-in-out infinite; 
        }
        
        @keyframes pulse { 
            0%, 100% { transform: scale(1); } 
            50% { transform: scale(1.05); } 
        }
    </style>

    <style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link return-sub" href="index.html">← 返回目录</a>
        <a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
    </div>

<div id="presentation-container">

    <!-- 第1页：标题页 -->
    <div class="slide active">
        <div class="chalkboard" style="flex: 1; text-align: center; border: none;">
            <h2 style="font-size: 4rem; border: none;">多元函数积分学</h2>
            <p style="font-size: 2rem; color: white;">二重积分与三重积分</p>
            <p style="font-size: 1.5rem; color: #bdc3c7; margin-top: 30px;">从平面到空间的积分之旅</p>
        </div>
    </div>

    <!-- 第2页：为什么需要多元积分 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>为什么需要多元积分？</h2>
            <h3>实际问题</h3>
            <ul>
                <li>求<span class="highlight">曲顶柱体</span>的体积</li>
                <li>计算<span class="highlight">不规则平面</span>的面积</li>
                <li>求<span class="highlight">平面薄片</span>的质量</li>
                <li>计算<span class="highlight">重心</span>和<span class="highlight">转动惯量</span></li>
            </ul>
            <h3>核心思想</h3>
            <p>将复杂区域<span class="highlight">分割</span>成小块，每块近似计算，最后<span class="highlight">求和取极限</span>。</p>
        </div>
        <div class="visualization" id="vis-why-double-integral"></div>
    </div>

    <!-- 第3页：二重积分的概念 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>二重积分</h2>
            <h3>定义</h3>
            <p>设函数 $z = f(x,y)$ 在有界闭区域 $D$ 上有定义。</p>
            <div class="math-formula">
                $$\iint_D f(x,y) \, dA = \lim\limits_{\Delta A \to 0} \sum f(x_i, y_i) \Delta A_i$$
            </div>
            <h3>几何意义</h3>
            <p>当 $f(x,y) \geq 0$ 时，二重积分表示以 $D$ 为底，以曲面 $z = f(x,y)$ 为顶的<span class="highlight">曲顶柱体的体积</span>。</p>
        </div>
        <div class="visualization" id="vis-double-integral-concept"></div>
    </div>

    <!-- 第4页：二重积分的性质 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>二重积分的性质</h2>
            <h3>1. 线性性质</h3>
            <div class="formula-rule">
                $$\iint_D [af(x,y) + bg(x,y)] \, dA = a\iint_D f \, dA + b\iint_D g \, dA$$
            </div>
            <h3>2. 区域可加性</h3>
            <p>若 $D = D_1 \cup D_2$，且 $D_1 \cap D_2 = \emptyset$，则：</p>
            <div class="formula-rule">
                $$\iint_D f \, dA = \iint_{D_1} f \, dA + \iint_{D_2} f \, dA$$
            </div>
            <h3>3. 比较性质</h3>
            <p>若在 $D$ 上 $f(x,y) \leq g(x,y)$，则 $\iint_D f \, dA \leq \iint_D g \, dA$</p>
        </div>
        <div class="visualization" id="vis-properties"></div>
    </div>

    <!-- 第5页：直角坐标系下的计算 - X型区域 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>直角坐标系计算</h2>
            <h3>X型区域</h3>
            <p>积分区域：$D = \{(x,y) | a \leq x \leq b, \varphi_1(x) \leq y \leq \varphi_2(x)\}$</p>
            <div class="math-formula">
                $$\iint_D f(x,y) \, dA = \int_a^b \left[ \int_{\varphi_1(x)}^{\varphi_2(x)} f(x,y) \, dy \right] dx$$
            </div>
            <p><span class="highlight">计算步骤：</span></p>
            <ol>
                <li>先对 $y$ 积分（内层）</li>
                <li>再对 $x$ 积分（外层）</li>
            </ol>
        </div>
        <div class="visualization" id="vis-x-type-region"></div>
    </div>

    <!-- 第6页：直角坐标系下的计算 - Y型区域 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>Y型区域</h2>
            <p>积分区域：$D = \{(x,y) | c \leq y \leq d, \psi_1(y) \leq x \leq \psi_2(y)\}$</p>
            <div class="math-formula">
                $$\iint_D f(x,y) \, dA = \int_c^d \left[ \int_{\psi_1(y)}^{\psi_2(y)} f(x,y) \, dx \right] dy$$
            </div>
            <p><span class="highlight">选择技巧：</span></p>
            <ul>
                <li>观察积分区域的形状</li>
                <li>选择使计算更简单的积分次序</li>
                <li>有时需要分割区域</li>
            </ul>
        </div>
        <div class="visualization" id="vis-y-type-region"></div>
    </div>

    <!-- 第7页：极坐标系下的计算 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>极坐标系</h2>
            <h3>坐标变换</h3>
            <p>$x = r\cos\theta$，$y = r\sin\theta$</p>
            <p>面积元素：$dA = r \, dr \, d\theta$</p>
            <div class="math-formula">
                $$\iint_D f(x,y) \, dA = \iint_{D'} f(r\cos\theta, r\sin\theta) \cdot r \, dr \, d\theta$$
            </div>
            <h3>适用情况</h3>
            <ul>
                <li>圆形或扇形区域</li>
                <li>被积函数含 $x^2 + y^2$</li>
                <li>旋转对称的问题</li>
            </ul>
        </div>
        <div class="visualization" id="vis-polar-coordinates"></div>
    </div>

    <!-- 第8页：二重积分应用 - 体积 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>应用：求体积</h2>
            <h3>曲顶柱体体积</h3>
            <p>上曲面：$z = f(x,y)$</p>
            <p>下曲面：$z = g(x,y)$</p>
            <div class="math-formula">
                $$V = \iint_D [f(x,y) - g(x,y)] \, dA$$
            </div>
            <h3>例：半球体积</h3>
            <p>求半径为 $R$ 的半球体积。</p>
            <p>曲面：$z = \sqrt{R^2 - x^2 - y^2}$</p>
            <p>底面：$x^2 + y^2 \leq R^2$</p>
        </div>
        <div class="visualization" id="vis-volume-application"></div>
    </div>

    <!-- 第9页：二重积分应用 - 面积 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>应用：求面积</h2>
            <h3>平面区域面积</h3>
            <p>区域 $D$ 的面积：</p>
            <div class="math-formula">
                $$A = \iint_D 1 \, dA = \iint_D dx \, dy$$
            </div>
            <h3>曲面面积</h3>
            <p>曲面 $z = f(x,y)$ 在区域 $D$ 上的面积：</p>
            <div class="math-formula">
                $$S = \iint_D \sqrt{1 + \left(\frac{\partial f}{\partial x}\right)^2 + \left(\frac{\partial f}{\partial y}\right)^2} \, dA$$
            </div>
        </div>
        <div class="visualization" id="vis-area-application"></div>
    </div>

    <!-- 第10页：二重积分应用 - 质量与重心 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>应用：质量与重心</h2>
            <h3>平面薄片的质量</h3>
            <p>密度函数：$\rho(x,y)$</p>
            <div class="formula-rule">
                $$M = \iint_D \rho(x,y) \, dA$$
            </div>
            <h3>重心坐标</h3>
            <p>质心坐标 $(\bar{x}, \bar{y})$：</p>
            <div class="formula-rule">
                $$\bar{x} = \frac{1}{M}\iint_D x\rho(x,y) \, dA, \quad \bar{y} = \frac{1}{M}\iint_D y\rho(x,y) \, dA$$
            </div>
        </div>
        <div class="visualization" id="vis-mass-center"></div>
    </div>

    <!-- 第11页：计算实例1 - 简单区域 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>计算实例</h2>
            <h3>例1：矩形区域</h3>
            <p>计算 $\iint_D xy \, dA$，其中 $D = [0,1] \times [0,2]$</p>
            <p><span class="highlight">解：</span></p>
            <div class="math-formula">
                $$\iint_D xy \, dA = \int_0^1 \int_0^2 xy \, dy \, dx$$
            </div>
            <p>先对 $y$ 积分：$\int_0^2 xy \, dy = x \cdot \frac{y^2}{2}\Big|_0^2 = 2x$</p>
            <p>再对 $x$ 积分：$\int_0^1 2x \, dx = x^2\Big|_0^1 = 1$</p>
        </div>
        <div class="visualization" id="vis-example1"></div>
    </div>

    <!-- 第12页：计算实例2 - 三角形区域 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>例2：三角形区域</h2>
            <p>计算 $\iint_D (x+y) \, dA$</p>
            <p>其中 $D$ 是顶点为 $(0,0)$, $(1,0)$, $(0,1)$ 的三角形。</p>
            <p><span class="highlight">解：</span>X型区域描述</p>
            <p>$D: 0 \leq x \leq 1, 0 \leq y \leq 1-x$</p>
            <div class="math-formula">
                $$\int_0^1 \int_0^{1-x} (x+y) \, dy \, dx = \frac{1}{3}$$
            </div>
        </div>
        <div class="visualization" id="vis-example2"></div>
    </div>

    <!-- 第13页：计算实例3 - 圆形区域（极坐标） -->
    <div class="slide">
        <div class="chalkboard">
            <h2>例3：圆形区域</h2>
            <p>计算 $\iint_D e^{-(x^2+y^2)} \, dA$</p>
            <p>其中 $D: x^2 + y^2 \leq R^2$</p>
            <p><span class="highlight">解：</span>使用极坐标</p>
            <p>$x = r\cos\theta$, $y = r\sin\theta$</p>
            <div class="math-formula">
                $$\int_0^{2\pi} \int_0^R e^{-r^2} \cdot r \, dr \, d\theta = \pi(1-e^{-R^2})$$
            </div>
        </div>
        <div class="visualization" id="vis-example3"></div>
    </div>

    <!-- 第14页：对称性的应用 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>对称性的应用</h2>
            <h3>关于坐标轴对称</h3>
            <p>若 $D$ 关于 $y$ 轴对称：</p>
            <ul>
                <li>$f(-x,y) = -f(x,y)$ （奇函数）→ 积分为0</li>
                <li>$f(-x,y) = f(x,y)$ （偶函数）→ 积分为右半部分的2倍</li>
            </ul>
            <h3>关于原点对称</h3>
            <p>若 $f(-x,-y) = -f(x,y)$，则 $\iint_D f \, dA = 0$</p>
        </div>
        <div class="visualization" id="vis-symmetry"></div>
    </div>

    <!-- 第15页：三重积分概念 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>三重积分</h2>
            <h3>定义</h3>
            <p>函数 $f(x,y,z)$ 在空间区域 $\Omega$ 上的三重积分：</p>
            <div class="math-formula">
                $$\iiint_\Omega f(x,y,z) \, dV = \lim\limits_{\Delta V \to 0} \sum f(x_i,y_i,z_i) \Delta V_i$$
            </div>
            <h3>物理意义</h3>
            <p>当 $f(x,y,z) = \rho(x,y,z)$ 表示密度时，三重积分表示<span class="highlight">空间物体的质量</span>。</p>
        </div>
        <div class="visualization" id="vis-triple-integral"></div>
    </div>

    <!-- 第16页：三重积分的计算 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>三重积分计算</h2>
            <h3>直角坐标系</h3>
            <div class="formula-rule">
                $$\iiint_\Omega f \, dV = \int_a^b \int_{y_1(x)}^{y_2(x)} \int_{z_1(x,y)}^{z_2(x,y)} f \, dz \, dy \, dx$$
            </div>
            <h3>计算步骤</h3>
            <ol>
                <li>确定积分区域的投影</li>
                <li>确定积分限</li>
                <li>从内到外依次积分</li>
            </ol>
        </div>
        <div class="visualization" id="vis-triple-calculation"></div>
    </div>

    <!-- 第17页：柱坐标系 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>柱坐标系</h2>
            <h3>坐标变换</h3>
            <p>$x = r\cos\theta$，$y = r\sin\theta$，$z = z$</p>
            <p>体积元素：$dV = r \, dr \, d\theta \, dz$</p>
            <div class="math-formula">
                $$\iiint_\Omega f \, dV = \iiint_{\Omega'} f(r\cos\theta, r\sin\theta, z) \cdot r \, dr \, d\theta \, dz$$
            </div>
            <h3>适用于</h3>
            <p>圆柱、圆锥等具有轴对称性的区域</p>
        </div>
        <div class="visualization" id="vis-cylindrical"></div>
    </div>

    <!-- 第18页：球坐标系 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>球坐标系</h2>
            <h3>坐标变换</h3>
            <p>$x = \rho\sin\phi\cos\theta$</p>
            <p>$y = \rho\sin\phi\sin\theta$</p>
            <p>$z = \rho\cos\phi$</p>
            <p>体积元素：$dV = \rho^2\sin\phi \, d\rho \, d\phi \, d\theta$</p>
            <h3>适用于</h3>
            <p>球体、球壳等球对称区域</p>
        </div>
        <div class="visualization" id="vis-spherical"></div>
    </div>

    <!-- 第19页：三重积分应用 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>三重积分应用</h2>
            <h3>体积</h3>
            <div class="formula-rule">
                $$V = \iiint_\Omega 1 \, dV$$
            </div>
            <h3>质量</h3>
            <div class="formula-rule">
                $$M = \iiint_\Omega \rho(x,y,z) \, dV$$
            </div>
            <h3>质心</h3>
            <p>$\bar{x} = \frac{1}{M}\iiint_\Omega x\rho \, dV$</p>
            <p>$\bar{y}$, $\bar{z}$ 类似</p>
        </div>
        <div class="visualization" id="vis-triple-applications"></div>
    </div>

    <!-- 第20页：积分换序 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>积分换序</h2>
            <h3>为什么要换序？</h3>
            <ul>
                <li>简化计算</li>
                <li>某些函数只能按特定顺序积分</li>
                <li>利用对称性</li>
            </ul>
            <h3>换序步骤</h3>
            <ol>
                <li>画出积分区域</li>
                <li>用新的积分变量重新描述区域</li>
                <li>确定新的积分限</li>
            </ol>
        </div>
        <div class="visualization" id="vis-change-order"></div>
    </div>

    <!-- 第21页：常见错误与注意事项 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>常见错误</h2>
            <h3>❌ 错误1：积分限弄反</h3>
            <p>内层积分限应该是外层变量的函数</p>
            <h3>❌ 错误2：忘记雅可比行列式</h3>
            <p>极坐标要乘以 $r$，球坐标要乘以 $\rho^2\sin\phi$</p>
            <h3>❌ 错误3：区域描述不完整</h3>
            <p>确保积分区域被完全覆盖，不重不漏</p>
            <h3>✅ 技巧</h3>
            <p>画图！画图！画图！</p>
        </div>
        <div class="visualization" id="vis-common-mistakes"></div>
    </div>

    <!-- 第22页：总结 -->
    <div class="slide">
        <div class="chalkboard" style="flex: 1; text-align: center; border: none;">
            <h2>知识总结</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 40px;">
                <div>
                    <h3 style="color: var(--primary-color);">二重积分</h3>
                    <ul style="text-align: left;">
                        <li>几何意义：曲顶柱体体积</li>
                        <li>直角坐标：X型/Y型区域</li>
                        <li>极坐标：圆形区域</li>
                        <li>应用：面积、质量、重心</li>
                    </ul>
                </div>
                <div>
                    <h3 style="color: var(--accent-color);">三重积分</h3>
                    <ul style="text-align: left;">
                        <li>物理意义：空间物体质量</li>
                        <li>直角坐标系</li>
                        <li>柱坐标系、球坐标系</li>
                        <li>应用：体积、质心、转动惯量</li>
                    </ul>
                </div>
            </div>
            <p style="margin-top: 40px; font-size: 1.5rem; color: var(--warning-color);">
                核心思想：分割 → 近似 → 求和 → 取极限
            </p>
        </div>
    </div>

    <!-- 导航按钮 -->
    <div class="nav-buttons">
        <button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">‹</button>
        <button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">›</button>
    </div>

    <div class="page-indicator" id="page-indicator">1 / 22</div>

</div>

<script>
    let slides, totalSlides, currentSlide = 0;
    let animationState = {
        isPaused: false,
        speed: 1
    };

    // 页面加载完成后初始化
    document.addEventListener('DOMContentLoaded', function() {
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        
        showSlide(0);
        
        // 键盘导航
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') nextSlide();
            else if (e.key === 'ArrowLeft') previousSlide();
            else if (e.key === 'Home') showSlide(0);
            else if (e.key === 'End') showSlide(totalSlides - 1);
        });
    });

    function showSlide(index) {
        if (index < 0 || index >= totalSlides) return;
        
        slides.forEach(slide => slide.classList.remove('active'));
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        document.getElementById('page-indicator').textContent = `${currentSlide + 1} / ${totalSlides}`;
        updateNavButtons();
        
        // 运行当前页的可视化
        runVisualization(currentSlide);
    }

    function nextSlide() {
        if (currentSlide < totalSlides - 1) {
            showSlide(currentSlide + 1);
        }
    }

    function previousSlide() {
        if (currentSlide > 0) {
            showSlide(currentSlide - 1);
        }
    }

    function updateNavButtons() {
        document.getElementById('prev-btn').disabled = (currentSlide === 0);
        document.getElementById('next-btn').disabled = (currentSlide === totalSlides - 1);
    }

    // 运行可视化
    function runVisualization(slideIndex) {
        switch(slideIndex) {
            case 1: visualizeWhyDoubleIntegral(); break;
            case 2: visualizeDoubleIntegralConcept(); break;
            case 3: visualizeProperties(); break;
            case 4: visualizeXTypeRegion(); break;
            case 5: visualizeYTypeRegion(); break;
            case 6: visualizePolarCoordinates(); break;
            case 7: visualizeVolumeApplication(); break;
            case 8: visualizeAreaApplication(); break;
            case 9: visualizeMassCenter(); break;
            case 10: visualizeExample1(); break;
            case 11: visualizeExample2(); break;
            case 12: visualizeExample3(); break;
            case 13: visualizeSymmetry(); break;
            case 14: visualizeTripleIntegral(); break;
            case 15: visualizeTripleCalculation(); break;
            case 16: visualizeCylindrical(); break;
            case 17: visualizeSpherical(); break;
            case 18: visualizeTripleApplications(); break;
            case 19: visualizeChangeOrder(); break;
            case 20: visualizeCommonMistakes(); break;
        }
    }

    // 第2页：为什么需要二重积分
    function visualizeWhyDoubleIntegral() {
        const container = d3.select('#vis-why-double-integral');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // 创建一个不规则形状
        const points = [
            [width*0.3, height*0.3],
            [width*0.7, height*0.2],
            [width*0.8, height*0.5],
            [width*0.6, height*0.7],
            [width*0.2, height*0.6]
        ];
        
        // 绘制不规则区域
        const lineGenerator = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .curve(d3.curveCardinalClosed);
        
        const region = svg.append('path')
            .datum(points)
            .attr('d', lineGenerator)
            .attr('fill', 'rgba(52, 152, 219, 0.3)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2);
        
        // 动画：分割成小块
        const gridSize = 20;
        const grid = svg.append('g').attr('class', 'grid');
        
        for(let x = width*0.2; x < width*0.8; x += gridSize) {
            for(let y = height*0.2; y < height*0.7; y += gridSize) {
                grid.append('rect')
                    .attr('x', x)
                    .attr('y', y)
                    .attr('width', gridSize)
                    .attr('height', gridSize)
                    .attr('fill', 'none')
                    .attr('stroke', '#95a5a6')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0)
                    .transition()
                    .delay(Math.random() * 1000)
                    .duration(500)
                    .attr('opacity', 1);
            }
        }
        
        // 添加标签
        svg.append('text')
            .attr('x', width/2)
            .attr('y', height*0.9)
            .attr('text-anchor', 'middle')
            .style('font-size', '18px')
            .style('fill', '#2c3e50')
            .text('将复杂区域分割成小矩形');
    }

    // 第3页：二重积分概念可视化
    function visualizeDoubleIntegralConcept() {
        const container = document.getElementById('vis-double-integral-concept');
        container.innerHTML = '<div id="three-container"></div>';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // 创建Three.js场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        document.getElementById('three-container').appendChild(renderer.domElement);
        
        // 添加光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // 创建曲面 z = x^2 + y^2
        const geometry = new THREE.ParametricGeometry(
            function(u, v, target) {
                const x = (u - 0.5) * 4;
                const y = (v - 0.5) * 4;
                const z = Math.max(0, 2 - (x*x + y*y) * 0.2);
                target.set(x, z, y);
            },
            50, 50
        );
        
        const material = new THREE.MeshPhongMaterial({
            color: 0x3498db,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7,
            wireframe: false
        });
        
        const surface = new THREE.Mesh(geometry, material);
        scene.add(surface);
        
        // 添加底面网格
        const gridHelper = new THREE.GridHelper(4, 20, 0x888888, 0xcccccc);
        gridHelper.rotation.x = Math.PI / 2;
        scene.add(gridHelper);
        
        // 添加坐标轴
        const axesHelper = new THREE.AxesHelper(3);
        scene.add(axesHelper);
        
        // 动画
        function animate() {
            requestAnimationFrame(animate);
            surface.rotation.z += 0.005;
            renderer.render(scene, camera);
        }
        animate();
    }

    // 第4页：二重积分性质
    function visualizeProperties() {
        const container = d3.select('#vis-properties');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // 可加性演示
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 区域D1
        g.append('rect')
            .attr('x', -150)
            .attr('y', -100)
            .attr('width', 140)
            .attr('height', 200)
            .attr('fill', 'rgba(52, 152, 219, 0.3)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2);
        
        g.append('text')
            .attr('x', -80)
            .attr('y', 0)
            .attr('text-anchor', 'middle')
            .style('font-size', '20px')
            .text('D₁');
        
        // 区域D2
        g.append('rect')
            .attr('x', 10)
            .attr('y', -100)
            .attr('width', 140)
            .attr('height', 200)
            .attr('fill', 'rgba(231, 76, 60, 0.3)')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2);
        
        g.append('text')
            .attr('x', 80)
            .attr('y', 0)
            .attr('text-anchor', 'middle')
            .style('font-size', '20px')
            .text('D₂');
        
        // 等号
        g.append('text')
            .attr('x', 0)
            .attr('y', -150)
            .attr('text-anchor', 'middle')
            .style('font-size', '24px')
            .text('D = D₁ ∪ D₂');
    }

    // 第5页：X型区域
    function visualizeXTypeRegion() {
        const container = d3.select('#vis-x-type-region');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 创建坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 4])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 4])
            .range([innerHeight, 0]);
        
        // 添加坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 定义区域边界函数
        const phi1 = x => x * 0.5;
        const phi2 = x => 3 - x * 0.5;
        
        // 创建区域路径
        const areaData = [];
        for(let x = 0.5; x <= 3.5; x += 0.1) {
            areaData.push({x: x, y0: phi1(x), y1: phi2(x)});
        }
        
        const area = d3.area()
            .x(d => xScale(d.x))
            .y0(d => yScale(d.y0))
            .y1(d => yScale(d.y1));
        
        // 绘制区域
        g.append('path')
            .datum(areaData)
            .attr('d', area)
            .attr('fill', 'rgba(52, 152, 219, 0.3)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2);
        
        // 添加边界曲线标签
        g.append('text')
            .attr('x', xScale(3))
            .attr('y', yScale(phi1(3)) + 20)
            .style('font-size', '14px')
            .text('y = φ₁(x)');
        
        g.append('text')
            .attr('x', xScale(3))
            .attr('y', yScale(phi2(3)) - 10)
            .style('font-size', '14px')
            .text('y = φ₂(x)');
        
        // 动画：扫描线
        const scanLine = g.append('line')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        function animateScan() {
            let x = 0.5;
            const timer = d3.interval(() => {
                if (x > 3.5) {
                    x = 0.5;
                }
                scanLine
                    .attr('x1', xScale(x))
                    .attr('y1', yScale(phi1(x)))
                    .attr('x2', xScale(x))
                    .attr('y2', yScale(phi2(x)));
                x += 0.05;
            }, 50);
        }
        animateScan();
    }

    // 第6页：Y型区域
    function visualizeYTypeRegion() {
        const container = d3.select('#vis-y-type-region');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 创建坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 4])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 4])
            .range([innerHeight, 0]);
        
        // 添加坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 定义区域边界函数
        const psi1 = y => y * 0.5;
        const psi2 = y => 3 - y * 0.5;
        
        // 创建区域
        const path = d3.path();
        path.moveTo(xScale(psi1(0.5)), yScale(0.5));
        for(let y = 0.5; y <= 3.5; y += 0.1) {
            path.lineTo(xScale(psi1(y)), yScale(y));
        }
        for(let y = 3.5; y >= 0.5; y -= 0.1) {
            path.lineTo(xScale(psi2(y)), yScale(y));
        }
        path.closePath();
        
        g.append('path')
            .attr('d', path.toString())
            .attr('fill', 'rgba(46, 204, 113, 0.3)')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 2);
        
        // 动画：水平扫描线
        const scanLine = g.append('line')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        function animateScan() {
            let y = 0.5;
            const timer = d3.interval(() => {
                if (y > 3.5) {
                    y = 0.5;
                }
                scanLine
                    .attr('x1', xScale(psi1(y)))
                    .attr('y1', yScale(y))
                    .attr('x2', xScale(psi2(y)))
                    .attr('y2', yScale(y));
                y += 0.05;
            }, 50);
        }
        animateScan();
    }

    // 第7页：极坐标系
    function visualizePolarCoordinates() {
        const container = d3.select('#vis-polar-coordinates');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const radius = Math.min(width, height) / 2 - 40;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 绘制极坐标网格
        const radialScale = d3.scaleLinear()
            .domain([0, 3])
            .range([0, radius]);
        
        // 同心圆
        for(let r = 0.5; r <= 3; r += 0.5) {
            g.append('circle')
                .attr('r', radialScale(r))
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);
        }
        
        // 角度线
        const angles = d3.range(0, 360, 30);
        angles.forEach(angle => {
            const radian = angle * Math.PI / 180;
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', radius * Math.cos(radian))
                .attr('y2', radius * Math.sin(radian))
                .attr('stroke', '#ddd')
                .attr('stroke-width', 1);
        });
        
        // 绘制一个扇形区域
        const arc = d3.arc()
            .innerRadius(radialScale(1))
            .outerRadius(radialScale(2.5))
            .startAngle(Math.PI / 6)
            .endAngle(Math.PI / 2);
        
        g.append('path')
            .attr('d', arc)
            .attr('fill', 'rgba(155, 89, 182, 0.3)')
            .attr('stroke', '#9b59b6')
            .attr('stroke-width', 2);
        
        // 添加标签
        g.append('text')
            .attr('x', 0)
            .attr('y', -radius - 20)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('极坐标系: dA = r dr dθ');
        
        // 动画点
        const point = g.append('circle')
            .attr('r', 5)
            .attr('fill', '#e74c3c');
        
        let theta = 0;
        const r = 2;
        d3.timer(() => {
            theta += 0.01;
            const x = radialScale(r) * Math.cos(theta);
            const y = radialScale(r) * Math.sin(theta);
            point.attr('cx', x).attr('cy', y);
        });
    }

    // 第8页：体积应用
    function visualizeVolumeApplication() {
        const container = document.getElementById('vis-volume-application');
        container.innerHTML = '<div id="three-container"></div>';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Three.js场景设置
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        
        const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
        camera.position.set(3, 3, 3);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        document.getElementById('three-container').appendChild(renderer.domElement);
        
        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // 创建半球
        const geometry = new THREE.SphereGeometry(1, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const material = new THREE.MeshPhongMaterial({
            color: 0x3498db,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });
        
        const hemisphere = new THREE.Mesh(geometry, material);
        scene.add(hemisphere);
        
        // 添加底面圆
        const circleGeometry = new THREE.CircleGeometry(1, 32);
        const circleMaterial = new THREE.MeshBasicMaterial({
            color: 0x2ecc71,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        circle.rotation.x = -Math.PI / 2;
        scene.add(circle);
        
        // 添加网格辅助
        const gridHelper = new THREE.GridHelper(2, 20);
        scene.add(gridHelper);
        
        // 动画
        function animate() {
            requestAnimationFrame(animate);
            hemisphere.rotation.y += 0.01;
            circle.rotation.z += 0.01;
            renderer.render(scene, camera);
        }
        animate();
    }

    // 第9页：面积应用
    function visualizeAreaApplication() {
        const container = d3.select('#vis-area-application');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 创建一个参数曲线区域
        const t = d3.range(0, 2 * Math.PI, 0.01);
        const points = t.map(angle => {
            const r = 100 * (1 + 0.5 * Math.cos(3 * angle));
            return [r * Math.cos(angle), r * Math.sin(angle)];
        });
        
        const line = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .curve(d3.curveCardinalClosed);
        
        // 绘制区域
        const path = g.append('path')
            .datum(points)
            .attr('d', line)
            .attr('fill', 'rgba(52, 152, 219, 0.2)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2);
        
        // 添加网格线动画
        const numLines = 20;
        for(let i = 0; i < numLines; i++) {
            const angle = (i / numLines) * 2 * Math.PI;
            const endR = 100 * (1 + 0.5 * Math.cos(3 * angle));
            
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 0)
                .attr('y2', 0)
                .attr('stroke', '#95a5a6')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0.5)
                .transition()
                .delay(i * 50)
                .duration(500)
                .attr('x2', endR * Math.cos(angle))
                .attr('y2', endR * Math.sin(angle));
        }
        
        // 添加标签
        g.append('text')
            .attr('y', -180)
            .attr('text-anchor', 'middle')
            .style('font-size', '18px')
            .text('面积 = ∬_D 1 dA');
    }

    // 第10页：质量与重心
    function visualizeMassCenter() {
        const container = d3.select('#vis-mass-center');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 创建一个不规则形状表示薄片
        const points = [
            [-100, -50],
            [50, -80],
            [120, 0],
            [80, 100],
            [-60, 90],
            [-120, 20]
        ];
        
        const line = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .curve(d3.curveCardinalClosed);
        
        // 绘制薄片
        g.append('path')
            .datum(points)
            .attr('d', line)
            .attr('fill', 'url(#density-gradient)')
            .attr('stroke', '#34495e')
            .attr('stroke-width', 2);
        
        // 创建密度渐变
        const gradient = svg.append('defs')
            .append('radialGradient')
            .attr('id', 'density-gradient');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#e74c3c')
            .attr('stop-opacity', 0.8);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#f39c12')
            .attr('stop-opacity', 0.3);
        
        // 标记重心
        const centerX = 10;
        const centerY = 20;
        
        const center = g.append('g');
        
        center.append('circle')
            .attr('cx', centerX)
            .attr('cy', centerY)
            .attr('r', 0)
            .attr('fill', '#2ecc71')
            .attr('stroke', '#27ae60')
            .attr('stroke-width', 2)
            .transition()
            .delay(1000)
            .duration(500)
            .attr('r', 8);
        
        center.append('text')
            .attr('x', centerX + 15)
            .attr('y', centerY - 10)
            .style('font-size', '14px')
            .style('opacity', 0)
            .text('重心')
            .transition()
            .delay(1500)
            .duration(500)
            .style('opacity', 1);
        
        // 添加坐标轴
        g.append('line')
            .attr('x1', -width/2 + 50)
            .attr('x2', width/2 - 50)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', '#95a5a6')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '2,2');
        
        g.append('line')
            .attr('x1', 0)
            .attr('x2', 0)
            .attr('y1', -height/2 + 50)
            .attr('y2', height/2 - 50)
            .attr('stroke', '#95a5a6')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '2,2');
    }

    // 第11页：计算实例1
    function visualizeExample1() {
        const container = d3.select('#vis-example1');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 创建坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 1.5])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 2.5])
            .range([innerHeight, 0]);
        
        g.append('g')
            .attr('transform', `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 绘制矩形区域
        const rect = g.append('rect')
            .attr('x', xScale(0))
            .attr('y', yScale(2))
            .attr('width', xScale(1) - xScale(0))
            .attr('height', yScale(0) - yScale(2))
            .attr('fill', 'rgba(52, 152, 219, 0.3)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2);
        
        // 添加标签
        g.append('text')
            .attr('x', xScale(0.5))
            .attr('y', yScale(1))
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('D = [0,1] × [0,2]');
        
        // 动画：积分路径
        const numLines = 20;
        for(let i = 0; i <= numLines; i++) {
            const x = i / numLines;
            g.append('line')
                .attr('x1', xScale(x))
                .attr('y1', yScale(0))
                .attr('x2', xScale(x))
                .attr('y2', yScale(0))
                .attr('stroke', '#e74c3c')
                .attr('stroke-width', 1)
                .attr('opacity', 0.5)
                .transition()
                .delay(i * 100)
                .duration(500)
                .attr('y2', yScale(2));
        }
    }

    // 第12页：计算实例2 - 三角形区域
    function visualizeExample2() {
        const container = d3.select('#vis-example2');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 创建坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 1.5])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 1.5])
            .range([innerHeight, 0]);
        
        g.append('g')
            .attr('transform', `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 绘制三角形
        const triangle = [
            [xScale(0), yScale(0)],
            [xScale(1), yScale(0)],
            [xScale(0), yScale(1)]
        ];
        
        g.append('polygon')
            .attr('points', triangle.map(p => p.join(',')).join(' '))
            .attr('fill', 'rgba(46, 204, 113, 0.3)')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 2);
        
        // 标记顶点
        triangle.forEach((point, i) => {
            g.append('circle')
                .attr('cx', point[0])
                .attr('cy', point[1])
                .attr('r', 4)
                .attr('fill', '#e74c3c');
        });
        
        // 添加扫描线动画
        let scanX = 0;
        const scanLine = g.append('line')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('opacity', 0.6);
        
        d3.timer(() => {
            scanX = (scanX + 0.01) % 1;
            scanLine
                .attr('x1', xScale(scanX))
                .attr('y1', yScale(0))
                .attr('x2', xScale(scanX))
                .attr('y2', yScale(1 - scanX));
        });
    }

    // 第13页：计算实例3 - 圆形区域（极坐标）
    function visualizeExample3() {
        const container = d3.select('#vis-example3');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        const radius = Math.min(width, height) / 2 - 40;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 绘制圆形区域
        g.append('circle')
            .attr('r', radius)
            .attr('fill', 'rgba(155, 89, 182, 0.2)')
            .attr('stroke', '#9b59b6')
            .attr('stroke-width', 2);
        
        // 绘制极坐标网格
        for(let r = radius/4; r <= radius; r += radius/4) {
            g.append('circle')
                .attr('r', r)
                .attr('fill', 'none')
                .attr('stroke', '#ddd')
                .attr('stroke-width', 0.5);
        }
        
        for(let angle = 0; angle < 360; angle += 30) {
            const radian = angle * Math.PI / 180;
            g.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', radius * Math.cos(radian))
                .attr('y2', radius * Math.sin(radian))
                .attr('stroke', '#ddd')
                .attr('stroke-width', 0.5);
        }
        
        // 添加高斯函数的等高线
        const contours = [0.9, 0.7, 0.5, 0.3, 0.1];
        contours.forEach(level => {
            const r = radius * Math.sqrt(-Math.log(level));
            if (r <= radius) {
                g.append('circle')
                    .attr('r', r)
                    .attr('fill', 'none')
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 1)
                    .attr('opacity', level);
            }
        });
        
        // 添加标签
        g.append('text')
            .attr('y', -radius - 20)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('e^(-r²) 在圆域上的积分');
    }

    // 第14页：对称性
    function visualizeSymmetry() {
        const container = d3.select('#vis-symmetry');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // 创建两个子图
        const g1 = svg.append('g')
            .attr('transform', `translate(${width/4}, ${height/2})`);
        
        const g2 = svg.append('g')
            .attr('transform', `translate(${width*3/4}, ${height/2})`);
        
        const size = Math.min(width/4, height/2) - 40;
        
        // 左图：关于y轴对称的奇函数
        g1.append('text')
            .attr('y', -size - 20)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('奇函数：积分 = 0');
        
        // 绘制对称区域
        g1.append('rect')
            .attr('x', -size)
            .attr('y', -size)
            .attr('width', size * 2)
            .attr('height', size * 2)
            .attr('fill', 'none')
            .attr('stroke', '#95a5a6')
            .attr('stroke-width', 1);
        
        // 绘制y轴
        g1.append('line')
            .attr('x1', 0)
            .attr('x2', 0)
            .attr('y1', -size)
            .attr('y2', size)
            .attr('stroke', '#333')
            .attr('stroke-width', 2);
        
        // 绘制奇函数示意（正负区域）
        g1.append('rect')
            .attr('x', 0)
            .attr('y', -size/2)
            .attr('width', size)
            .attr('height', size)
            .attr('fill', 'rgba(231, 76, 60, 0.3)');
        
        g1.append('rect')
            .attr('x', -size)
            .attr('y', -size/2)
            .attr('width', size)
            .attr('height', size)
            .attr('fill', 'rgba(52, 152, 219, 0.3)');
        
        g1.append('text')
            .attr('x', size/2)
            .attr('y', 0)
            .attr('text-anchor', 'middle')
            .text('+');
        
        g1.append('text')
            .attr('x', -size/2)
            .attr('y', 0)
            .attr('text-anchor', 'middle')
            .text('−');
        
        // 右图：关于y轴对称的偶函数
        g2.append('text')
            .attr('y', -size - 20)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('偶函数：积分 = 2×右半部分');
        
        // 绘制对称区域
        g2.append('rect')
            .attr('x', -size)
            .attr('y', -size)
            .attr('width', size * 2)
            .attr('height', size * 2)
            .attr('fill', 'none')
            .attr('stroke', '#95a5a6')
            .attr('stroke-width', 1);
        
        // 绘制y轴
        g2.append('line')
            .attr('x1', 0)
            .attr('x2', 0)
            .attr('y1', -size)
            .attr('y2', size)
            .attr('stroke', '#333')
            .attr('stroke-width', 2);
        
        // 绘制偶函数示意（对称正区域）
        g2.append('rect')
            .attr('x', -size)
            .attr('y', -size/2)
            .attr('width', size * 2)
            .attr('height', size)
            .attr('fill', 'rgba(46, 204, 113, 0.3)');
        
        g2.append('text')
            .attr('x', size/2)
            .attr('y', 0)
            .attr('text-anchor', 'middle')
            .text('+');
        
        g2.append('text')
            .attr('x', -size/2)
            .attr('y', 0)
            .attr('text-anchor', 'middle')
            .text('+');
    }

    // 第15页：三重积分概念
    function visualizeTripleIntegral() {
        const container = document.getElementById('vis-triple-integral');
        container.innerHTML = '<div id="three-container"></div>';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Three.js场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
        camera.position.set(4, 4, 4);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        document.getElementById('three-container').appendChild(renderer.domElement);
        
        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // 创建一个立方体区域
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshPhongMaterial({
            color: 0x3498db,
            transparent: true,
            opacity: 0.3,
            wireframe: false
        });
        
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        
        // 添加边框
        const edges = new THREE.EdgesGeometry(geometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const wireframe = new THREE.LineSegments(edges, lineMaterial);
        scene.add(wireframe);
        
        // 添加小立方体表示分割
        const smallCubeGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const smallCubeMaterial = new THREE.MeshPhongMaterial({
            color: 0xe74c3c,
            transparent: true,
            opacity: 0.7
        });
        
        const numDivisions = 5;
        for(let i = 0; i < numDivisions; i++) {
            for(let j = 0; j < numDivisions; j++) {
                for(let k = 0; k < numDivisions; k++) {
                    const smallCube = new THREE.Mesh(smallCubeGeometry, smallCubeMaterial);
                    smallCube.position.set(
                        -0.8 + i * 0.4,
                        -0.8 + j * 0.4,
                        -0.8 + k * 0.4
                    );
                    scene.add(smallCube);
                }
            }
        }
        
        // 动画
        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.y += 0.005;
            wireframe.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
        animate();
    }

    // 第16页：三重积分计算
    function visualizeTripleCalculation() {
        const container = d3.select('#vis-triple-calculation');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 绘制积分顺序示意图
        const levels = [
            { y: -100, text: '∫∫∫ f(x,y,z) dV', color: '#3498db' },
            { y: -40, text: '↓ 先对z积分', color: '#95a5a6' },
            { y: 20, text: '∫∫ F(x,y) dA', color: '#2ecc71' },
            { y: 80, text: '↓ 再对y积分', color: '#95a5a6' },
            { y: 140, text: '∫ G(x) dx', color: '#e74c3c' }
        ];
        
        levels.forEach((level, i) => {
            g.append('text')
                .attr('y', level.y)
                .attr('text-anchor', 'middle')
                .style('font-size', '20px')
                .style('fill', level.color)
                .style('opacity', 0)
                .text(level.text)
                .transition()
                .delay(i * 500)
                .duration(500)
                .style('opacity', 1);
        });
    }

    // 第17页：柱坐标系
    function visualizeCylindrical() {
        const container = document.getElementById('vis-cylindrical');
        container.innerHTML = '<div id="three-container"></div>';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Three.js场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        
        const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
        camera.position.set(3, 3, 3);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        document.getElementById('three-container').appendChild(renderer.domElement);
        
        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // 创建圆柱体
        const geometry = new THREE.CylinderGeometry(1, 1, 2, 32);
        const material = new THREE.MeshPhongMaterial({
            color: 0x9b59b6,
            transparent: true,
            opacity: 0.5
        });
        
        const cylinder = new THREE.Mesh(geometry, material);
        scene.add(cylinder);
        
        // 添加边框
        const edges = new THREE.EdgesGeometry(geometry);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const wireframe = new THREE.LineSegments(edges, lineMaterial);
        scene.add(wireframe);
        
        // 添加坐标轴
        const axesHelper = new THREE.AxesHelper(2);
        scene.add(axesHelper);
        
        // 动画
        function animate() {
            requestAnimationFrame(animate);
            cylinder.rotation.y += 0.01;
            wireframe.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        animate();
    }

    // 第18页：球坐标系
    function visualizeSpherical() {
        const container = document.getElementById('vis-spherical');
        container.innerHTML = '<div id="three-container"></div>';
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Three.js场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        
        const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
        camera.position.set(3, 3, 3);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        document.getElementById('three-container').appendChild(renderer.domElement);
        
        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        // 创建球体
        const geometry = new THREE.SphereGeometry(1, 32, 32);
        const material = new THREE.MeshPhongMaterial({
            color: 0xf39c12,
            transparent: true,
            opacity: 0.5,
            wireframe: false
        });
        
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);
        
        // 添加经纬线
        const wireframeGeometry = new THREE.SphereGeometry(1.01, 16, 8);
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        const wireframeSphere = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
        scene.add(wireframeSphere);
        
        // 添加坐标轴
        const axesHelper = new THREE.AxesHelper(1.5);
        scene.add(axesHelper);
        
        // 动画
        function animate() {
            requestAnimationFrame(animate);
            sphere.rotation.y += 0.01;
            wireframeSphere.rotation.y += 0.01;
            renderer.render(scene, camera);
        }
        animate();
    }

    // 第19页：三重积分应用
    function visualizeTripleApplications() {
        const container = d3.select('#vis-triple-applications');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // 创建三个应用示例
        const examples = [
            { x: width/4, y: height/2, title: '体积', formula: 'V = ∫∫∫ 1 dV', color: '#3498db' },
            { x: width/2, y: height/2, title: '质量', formula: 'M = ∫∫∫ ρ dV', color: '#2ecc71' },
            { x: width*3/4, y: height/2, title: '质心', formula: 'x̄ = (1/M)∫∫∫ xρ dV', color: '#e74c3c' }
        ];
        
        examples.forEach((ex, i) => {
            const g = svg.append('g')
                .attr('transform', `translate(${ex.x}, ${ex.y})`);
            
            // 绘制圆形背景
            g.append('circle')
                .attr('r', 0)
                .attr('fill', ex.color)
                .attr('opacity', 0.2)
                .transition()
                .delay(i * 300)
                .duration(500)
                .attr('r', 60);
            
            // 添加标题
            g.append('text')
                .attr('y', -20)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .text(ex.title)
                .transition()
                .delay(i * 300 + 200)
                .duration(500)
                .style('opacity', 1);
            
            // 添加公式
            g.append('text')
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('opacity', 0)
                .text(ex.formula)
                .transition()
                .delay(i * 300 + 400)
                .duration(500)
                .style('opacity', 1);
        });
    }

    // 第20页：积分换序
    function visualizeChangeOrder() {
        const container = d3.select('#vis-change-order');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // 创建两个坐标系
        const g1 = svg.append('g')
            .attr('transform', `translate(${width/4}, ${height/2})`);
        
        const g2 = svg.append('g')
            .attr('transform', `translate(${width*3/4}, ${height/2})`);
        
        const size = Math.min(width/4, height/2) - 60;
        
        // 左图：dxdy积分顺序
        g1.append('text')
            .attr('y', -size - 30)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('先对y积分，再对x积分');
        
        // 绘制积分区域
        const region1 = [
            [-size/2, -size/2],
            [size/2, -size/2],
            [size/2, size/4],
            [0, size/2],
            [-size/2, size/4]
        ];
        
        const line = d3.line()
            .x(d => d[0])
            .y(d => d[1]);
        
        g1.append('path')
            .datum(region1)
            .attr('d', line)
            .attr('fill', 'rgba(52, 152, 219, 0.3)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2);
        
        // 添加扫描线
        for(let i = 0; i < 10; i++) {
            const x = -size/2 + i * size / 10;
            g1.append('line')
                .attr('x1', x)
                .attr('y1', -size/2)
                .attr('x2', x)
                .attr('y2', size/2)
                .attr('stroke', '#e74c3c')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0)
                .transition()
                .delay(i * 100)
                .duration(300)
                .attr('opacity', 0.5);
        }
        
        // 右图：dydx积分顺序
        g2.append('text')
            .attr('y', -size - 30)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .text('先对x积分，再对y积分');
        
        g2.append('path')
            .datum(region1)
            .attr('d', line)
            .attr('fill', 'rgba(46, 204, 113, 0.3)')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 2);
        
        // 添加水平扫描线
        for(let i = 0; i < 10; i++) {
            const y = -size/2 + i * size / 10;
            g2.append('line')
                .attr('x1', -size/2)
                .attr('y1', y)
                .attr('x2', size/2)
                .attr('y2', y)
                .attr('stroke', '#e74c3c')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0)
                .transition()
                .delay(i * 100)
                .duration(300)
                .attr('opacity', 0.5);
        }
    }

    // 第21页：常见错误
    function visualizeCommonMistakes() {
        const container = d3.select('#vis-common-mistakes');
        container.selectAll("*").remove();
        
        const width = container.node().clientWidth;
        const height = container.node().clientHeight;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 创建错误示例
        const mistakes = [
            { 
                x: -width/3, 
                y: -height/4, 
                text: '积分限错误', 
                example: '∫₀¹∫₀ˣ → ∫₀¹∫ₓ¹', 
                color: '#e74c3c' 
            },
            { 
                x: 0, 
                y: -height/4, 
                text: '忘记雅可比', 
                example: '∬ f(r,θ) drdθ → ∬ f(r,θ) r drdθ', 
                color: '#f39c12' 
            },
            { 
                x: width/3, 
                y: -height/4, 
                text: '区域不完整', 
                example: '遗漏边界条件', 
                color: '#9b59b6' 
            }
        ];
        
        mistakes.forEach((mistake, i) => {
            const group = g.append('g')
                .attr('transform', `translate(${mistake.x}, ${mistake.y})`);
            
            // 错误标记
            group.append('text')
                .attr('y', -20)
                .attr('text-anchor', 'middle')
                .style('font-size', '24px')
                .style('fill', mistake.color)
                .style('opacity', 0)
                .text('❌')
                .transition()
                .delay(i * 500)
                .duration(500)
                .style('opacity', 1);
            
            // 错误描述
            group.append('text')
                .attr('y', 10)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .text(mistake.text)
                .transition()
                .delay(i * 500 + 200)
                .duration(500)
                .style('opacity', 1);
            
            // 示例
            group.append('text')
                .attr('y', 35)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('opacity', 0)
                .text(mistake.example)
                .transition()
                .delay(i * 500 + 400)
                .duration(500)
                .style('opacity', 1);
        });
        
        // 正确做法提示
        g.append('text')
            .attr('y', height/3)
            .attr('text-anchor', 'middle')
            .style('font-size', '20px')
            .style('fill', '#2ecc71')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .text('✅ 解决方法：画图！检查！验证！')
            .transition()
            .delay(2000)
            .duration(1000)
            .style('opacity', 1);
    }
</script>

</body>
</html>