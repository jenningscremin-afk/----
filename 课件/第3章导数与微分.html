<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第三章：导数与微分 (交互式课件)</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <script src="../common-assets/js/mathjax-config.js"></script>
      <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready!');
                    });
                }
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
            src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js">
    </script>

    <style>
        @import url('../common-assets/css/fonts.css');

        :root {
            --background-gradient-start: #f8fafc;
            --background-gradient-end: #eef2ff;
            --surface-color: #ffffff;
            --surface-muted: #f6f7fb;
            --divider-color: #e2e8f0;
            --primary-color: #2563eb;
            --accent-color: #f97316;
            --success-color: #16a34a;
            --danger-color: #ef4444;
            --warning-color: #facc15;
            --info-color: #6366f1;
            --text-color: #1f2937;
            --muted-text: #475569;
            --heading-font: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            --handwriting-font: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            --chalkboard-bg: #ffffff;
            --chalk-text: #1f2937;
            --visualization-bg: #f8fafc;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: var(--heading-font);
            background: linear-gradient(180deg, var(--background-gradient-start) 0%, var(--background-gradient-end) 100%);
            color: var(--text-color);
            overflow: hidden;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        #presentation-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            padding: 32px 40px 96px;
            background: transparent;
        }

        .slide {
            position: absolute;
            top: 32px;
            left: 40px;
            right: 40px;
            bottom: 96px;
            display: flex;
            flex-direction: row;
            align-items: stretch;
            background: var(--surface-color);
            border-radius: 26px;
            box-shadow: 0 24px 60px rgba(15, 23, 42, 0.16);
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transform: translateY(24px);
            transition: opacity 0.45s ease, transform 0.45s ease;
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            z-index: 10;
        }

        .chalkboard {
            flex: 0 0 50%;
            max-width: 50%;
            background: var(--surface-color);
            color: var(--text-color);
            padding: 48px 56px;
            border-right: 1px solid var(--divider-color);
            display: flex;
            flex-direction: column;
            gap: 18px;
            overflow-y: auto;
        }

        .chalkboard h1,
        .chalkboard h2,
        .chalkboard h3,
        .chalkboard h4 {
            font-family: var(--heading-font);
            color: var(--text-color);
        }

        .chalkboard h2 {
            font-size: 2.1rem;
            margin: 0;
            padding-bottom: 14px;
            border-bottom: 3px solid rgba(37, 99, 235, 0.15);
            color: var(--primary-color);
        }

        .chalkboard h3 {
            font-size: 1.4rem;
            margin: 0;
            color: var(--muted-text);
        }

        .chalkboard h4 {
            font-size: 1.2rem;
            margin: 0;
            color: var(--muted-text);
        }

        .chalkboard p,
        .chalkboard li {
            font-size: 1.04rem;
            line-height: 1.8;
            color: var(--text-color);
        }

        .chalkboard ul {
            margin: 0;
            padding-left: 20px;
        }

        .chalkboard ul li {
            margin-bottom: 10px;
        }

        .chalkboard ol {
            margin: 0;
            padding-left: 22px;
        }

        .chalkboard::-webkit-scrollbar {
            width: 6px;
        }

        .chalkboard::-webkit-scrollbar-thumb {
            background: rgba(37, 99, 235, 0.35);
            border-radius: 4px;
        }

        .chalkboard::-webkit-scrollbar-track {
            background: rgba(226, 232, 240, 0.6);
        }

        .visualization {
            flex: 1;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            padding: 24px;
        }

        .visualization.full-width {
            flex-basis: 100%;
            max-width: 100%;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.14), rgba(99, 102, 241, 0.14));
        }

        .visualization.white-bg {
            background: var(--surface-color);
        }

        canvas, svg {
            max-width: 100%;
            height: 100%;
        }

        .math-formula {
            background: var(--surface-muted);
            border: 1px solid rgba(37, 99, 235, 0.1);
            border-radius: 16px;
            padding: 18px 22px;
            color: var(--text-color);
            font-size: 1.1rem;
            line-height: 1.6;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
        }

        .highlight {
            color: var(--accent-color);
            font-weight: 600;
        }

        .note-card,
        .example-card,
        .warning-card,
        .definition-card {
            border-radius: 16px;
            padding: 18px 22px;
            background: var(--surface-muted);
            border-left: 4px solid rgba(37, 99, 235, 0.35);
        }

        .example-card {
            border-left-color: rgba(16, 185, 129, 0.35);
        }

        .warning-card {
            border-left-color: rgba(249, 115, 22, 0.35);
        }

        .nav-buttons {
            position: fixed;
            right: 32px;
            bottom: 26px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 999px;
            box-shadow: 0 18px 35px rgba(15, 23, 42, 0.14);
            backdrop-filter: blur(14px);
            z-index: 1000;
        }

        .nav-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--primary-color), #4f46e5);
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 20px rgba(79, 70, 229, 0.25);
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .page-indicator {
            position: fixed;
            right: 42px;
            bottom: 88px;
            padding: 10px 18px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.7);
            color: #f8fafc;
            font-size: 0.9rem;
            letter-spacing: 0.04em;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
            backdrop-filter: blur(8px);
            z-index: 900;
        }

        .global-animation-controls {
            position: fixed;
            left: 40px;
            bottom: 32px;
            display: flex;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 16px;
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
            backdrop-filter: blur(12px);
            z-index: 900;
        }

        .global-control-btn {
            border: none;
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary-color);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .global-control-btn:hover {
            background: rgba(37, 99, 235, 0.2);
        }

        .global-control-btn.pause {
            background: rgba(239, 68, 68, 0.12);
            color: var(--danger-color);
        }

        .value-display {
            position: absolute;
            top: 32px;
            left: 32px;
            min-width: 220px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.92);
            border-radius: 18px;
            box-shadow: 0 15px 30px rgba(15, 23, 42, 0.18);
            backdrop-filter: blur(10px);
            color: var(--text-color);
        }

        .value-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 0.95rem;
        }

        .value-item:last-child {
            margin-bottom: 0;
        }

        .value-label {
            color: var(--muted-text);
        }

        .value-number {
            font-weight: 600;
            color: var(--primary-color);
        }

        .control-panel {
            position: absolute;
            left: 50%;
            bottom: 32px;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 999px;
            box-shadow: 0 15px 30px rgba(15, 23, 42, 0.16);
            backdrop-filter: blur(10px);
        }

        .control-btn {
            border: none;
            padding: 8px 18px;
            border-radius: 999px;
            background: linear-gradient(135deg, var(--primary-color), #4f46e5);
            color: #fff;
            cursor: pointer;
            font-size: 0.95rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 20px rgba(79, 70, 229, 0.3);
        }

        .slider {
            accent-color: var(--primary-color);
        }

        .home-nav-buttons {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 16px;
            margin-top: 40px;
        }

        .home-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 130px;
            padding: 16px 18px;
            border-radius: 18px;
            background: rgba(37, 99, 235, 0.08);
            color: var(--text-color);
            text-decoration: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .home-nav-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 14px 25px rgba(37, 99, 235, 0.2);
            background: rgba(37, 99, 235, 0.12);
        }

        .btn-icon {
            font-size: 0.85rem;
            letter-spacing: 0.12em;
            color: var(--muted-text);
        }

        .btn-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color);
        }

        .return-home-panel {
            position: absolute;
            top: 32px;
            left: 40px;
            display: flex;
            gap: 12px;
        }

        .return-home-panel .return-link {
            padding: 8px 16px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.08);
            color: var(--text-color);
            font-size: 0.9rem;
            transition: background 0.2s ease;
        }

        .return-home-panel .return-link:hover {
            background: rgba(37, 99, 235, 0.18);
        }

        .return-home-panel .return-link.return-main {
            background: var(--primary-color);
            color: #fff;
        }

        .return-home-panel .return-link.return-main:hover {
            background: #1d4ed8;
        }

        #floating-menu {
            position: fixed;
            bottom: 120px;
            right: 40px;
            z-index: 950;
            font-family: var(--heading-font);
        }

        .slide.title-slide .chalkboard {
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 12px;
        }

        .slide.title-slide .chalkboard h2 {
            border-bottom: none;
            font-size: 3.4rem;
            color: var(--primary-color);
        }

        .slide.title-slide .chalkboard p {
            margin: 0;
            color: var(--muted-text);
        }

        .menu-toggle {
            padding: 10px 16px;
            border-radius: 999px;
            border: none;
            background: rgba(37, 99, 235, 0.9);
            color: #fff;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(37, 99, 235, 0.25);
            transition: transform 0.2s ease;
        }

        .menu-toggle:hover {
            transform: translateY(-2px);
        }

        .menu-content {
            position: absolute;
            bottom: 60px;
            right: 0;
            width: 260px;
            max-height: 360px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 18px;
            box-shadow: 0 16px 45px rgba(15, 23, 42, 0.18);
            padding: 14px 0;
            opacity: 0;
            visibility: hidden;
            transform: translateY(12px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            backdrop-filter: blur(12px);
        }

        .menu-content.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .menu-item {
            padding: 10px 20px;
            color: var(--text-color);
            font-size: 0.95rem;
            transition: background 0.2s ease;
        }

        .menu-item:hover {
            background: rgba(37, 99, 235, 0.12);
        }

        .menu-item.active {
            background: rgba(37, 99, 235, 0.18);
            color: var(--primary-color);
            font-weight: 600;
        }

        @media (max-width: 1200px) {
            #presentation-container {
                padding: 24px 24px 112px;
            }

            .slide {
                top: 24px;
                left: 24px;
                right: 24px;
                bottom: 112px;
            }

            .chalkboard {
                padding: 32px;
            }
        }

        @media (max-width: 960px) {
            body {
                overflow: auto;
            }

            .slide {
                position: relative;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                flex-direction: column;
                min-height: 100vh;
                border-radius: 0;
            }

            #presentation-container {
                padding: 0;
                height: auto;
                min-height: 100vh;
            }

            .chalkboard, .visualization {
                max-width: 100%;
                flex: none;
                border-right: none;
            }

            .visualization {
                min-height: 320px;
            }

            .nav-buttons, .page-indicator, .global-animation-controls, #floating-menu {
                position: static;
                margin: 16px auto;
            }
        }
</style>
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link return-sub" href="index.html">← 返回目录</a>
        <a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
    </div>

<div id="presentation-container">

    <!-- 第1页：标题页 -->
    <div class="slide active title-slide">
        <div class="chalkboard" style="flex: 1;">
            <h2>第三章</h2>
            <p style="font-size: 2.3rem;">导数与微分</p>
            <p style="font-size: 1.25rem;">从变化率到瞬时变化</p>

            <!-- 导航按钮组 -->
            <div class="home-nav-buttons">
                <a href="../index.html" class="home-nav-btn">
                    <span class="btn-icon">HOME</span>
                    <span class="btn-text">主页</span>
                </a>
                <a href="../故事书/index.html" class="home-nav-btn">
                    <span class="btn-icon">STORY</span>
                    <span class="btn-text">故事书</span>
                </a>
                <a href="../习题/index.html" class="home-nav-btn">
                    <span class="btn-icon">EXERCISE</span>
                    <span class="btn-text">习题</span>
                </a>
                <a href="../网页资源/index.html" class="home-nav-btn">
                    <span class="btn-icon">RESOURCE</span>
                    <span class="btn-text">网页资源</span>
                </a>
            </div>
        </div>
    </div>

    <!-- 第2页：引入 - 速度与变化率 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>生活中的变化率</h2>
            <h3>思考一个问题</h3>
            <p>汽车行驶100公里用了2小时，<br>平均速度是 <span class="highlight">50 km/h</span></p>
            <p>但是...</p>
            <ul>
                <li>汽车真的一直以50 km/h行驶吗？</li>
                <li>某一时刻的速度是多少？</li>
                <li>如何描述"瞬间"的变化？</li>
            </ul>
            <div class="math-formula">
                变化率 = $\frac{\text{变化量}}{\text{时间}}$
            </div>
        </div>
        <div class="visualization" id="vis-intro"></div>
    </div>

    <!-- 第3页：平均变化率 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>平均变化率</h2>
            <p>函数 $y = f(x)$ 在区间 $[x_1, x_2]$ 上的平均变化率：</p>
            <div class="math-formula">
                平均变化率 = $\frac{f(x_2) - f(x_1)}{x_2 - x_1}$
            </div>
            <h3>几何意义</h3>
            <p>平均变化率就是<span class="highlight">割线的斜率</span></p>
            <p>• 连接两点的直线叫割线<br>
            • 割线斜率反映了函数的平均变化快慢</p>
        </div>
        <div class="visualization" id="vis-average-rate"></div>
    </div>

    <!-- 第4页：从平均到瞬时 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>逼近瞬时变化率</h2>
            <p>当 $\Delta x$ 越来越小时会发生什么？</p>
            <ul>
                <li>两点越来越近</li>
                <li>割线逐渐逼近切线</li>
                <li>平均变化率逼近瞬时变化率</li>
            </ul>
            <div class="math-formula">
                瞬时变化率 = $\lim\limits_{\Delta x \to 0} \frac{f(x + \Delta x) - f(x)}{\Delta x}$
            </div>
            <p>这就是<span class="highlight">导数</span>的概念！</p>
        </div>
        <div class="visualization" id="vis-limit-approach"></div>
    </div>

    <!-- 第5页：导数的定义 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>导数</h2>
            <h3>定义</h3>
            <p>函数 $y = f(x)$ 在点 $x$ 处的导数记作：</p>
            <div class="math-formula">
                $f'(x)$ 或 $\frac{dy}{dx}$
            </div>
            <h3>几何意义</h3>
            <p>导数就是函数图像在该点的<span class="highlight">切线斜率</span></p>
            <h3>物理意义</h3>
            <p>位移对时间的导数就是<span class="highlight">瞬时速度</span></p>
        </div>
        <div class="visualization" id="vis-derivative-def"></div>
    </div>

    <!-- 第6页：切线的动态演示 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>切线演示</h2>
            <p>观察函数 $f(x) = x^2$ 的切线</p>
            <ul>
                <li>在不同点处，切线斜率不同</li>
                <li>切线斜率就是该点的导数值</li>
                <li>导数描述了函数的变化趋势</li>
            </ul>
            <div class="math-formula">
                $f(x) = x^2$<br>
                $f'(x) = 2x$
            </div>
            <p>例如：在 $x = 1$ 处，$f'(1) = 2$</p>
        </div>
        <div class="visualization" id="vis-tangent-demo"></div>
    </div>

    <!-- 第7页：导数的物理意义 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>导数的物理意义</h2>
            <h3>位移与速度</h3>
            <p>设物体的位移为 $s(t)$</p>
            <p>则瞬时速度：$v(t) = s'(t)$</p>
            <h3>速度与加速度</h3>
            <p>瞬时加速度：$a(t) = v'(t) = s''(t)$</p>
            <div class="math-formula">
                位移 $\xrightarrow{\text{求导}}$ 速度 $\xrightarrow{\text{求导}}$ 加速度
            </div>
        </div>
        <div class="visualization" id="vis-physics"></div>
    </div>

    <!-- 第8页：常数函数的导数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>基本导数公式</h2>
            <h3>常数函数</h3>
            <p>若 $f(x) = C$（C是常数）</p>
            <div class="math-formula">
                $f'(x) = 0$
            </div>
            <p><span class="highlight">理解：</span>常数函数的图像是水平线，斜率为0</p>
            <p>例如：</p>
            <ul>
                <li>$f(x) = 5$，则 $f'(x) = 0$</li>
                <li>$f(x) = -3$，则 $f'(x) = 0$</li>
            </ul>
        </div>
        <div class="visualization" id="vis-constant"></div>
    </div>

    <!-- 第9页：幂函数的导数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>幂函数的导数</h2>
            <p>若 $f(x) = x^n$（n是常数）</p>
            <div class="math-formula">
                $f'(x) = n \cdot x^{n-1}$
            </div>
            <h3>例子</h3>
            <ul>
                <li>$f(x) = x^2$，则 $f'(x) = 2x$</li>
                <li>$f(x) = x^3$，则 $f'(x) = 3x^2$</li>
                <li>$f(x) = x^{-1}$，则 $f'(x) = -x^{-2}$</li>
                <li>$f(x) = \sqrt{x} = x^{1/2}$，则 $f'(x) = \frac{1}{2}x^{-1/2}$</li>
            </ul>
        </div>
        <div class="visualization" id="vis-power"></div>
    </div>

    <!-- 第10页：指数函数的导数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>指数函数的导数</h2>
            <h3>自然指数函数</h3>
            <p>若 $f(x) = e^x$</p>
            <div class="math-formula">
                $f'(x) = e^x$
            </div>
            <p><span class="highlight">特殊性质：</span>导数等于函数本身！</p>
            <h3>一般指数函数</h3>
            <p>若 $f(x) = a^x$（$a > 0, a \neq 1$）</p>
            <div class="math-formula">
                $f'(x) = a^x \cdot \ln a$
            </div>
        </div>
        <div class="visualization" id="vis-exponential"></div>
    </div>

    <!-- 第11页：对数函数的导数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>对数函数的导数</h2>
            <h3>自然对数函数</h3>
            <p>若 $f(x) = \ln x$（$x > 0$）</p>
            <div class="math-formula">
                $f'(x) = \frac{1}{x}$
            </div>
            <h3>一般对数函数</h3>
            <p>若 $f(x) = \log_a x$（$a > 0, a \neq 1, x > 0$）</p>
            <div class="math-formula">
                $f'(x) = \frac{1}{x \ln a}$
            </div>
        </div>
        <div class="visualization" id="vis-logarithm"></div>
    </div>

    <!-- 第12页：三角函数的导数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>三角函数的导数</h2>
            <h3>正弦和余弦</h3>
            <div class="math-formula">
                $(\sin x)' = \cos x$<br>
                $(\cos x)' = -\sin x$
            </div>
            <h3>正切</h3>
            <div class="math-formula">
                $(\tan x)' = \sec^2 x = \frac{1}{\cos^2 x}$
            </div>
            <p><span class="highlight">记忆技巧：</span><br>
            正弦求导变余弦<br>
            余弦求导变负正弦</p>
        </div>
        <div class="visualization" id="vis-trigonometric"></div>
    </div>

    <!-- 第13页：导数的加法法则 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>导数运算法则</h2>
            <h3>加法法则</h3>
            <p>两个函数和的导数等于导数的和</p>
            <div class="math-formula">
                $[f(x) + g(x)]' = f'(x) + g'(x)$
            </div>
            <h3>例子</h3>
            <p>求 $y = x^2 + 3x$ 的导数</p>
            <p>解：$y' = (x^2)' + (3x)'$</p>
            <p>　　$= 2x + 3$</p>
        </div>
        <div class="visualization" id="vis-addition-rule"></div>
    </div>

    <!-- 第14页：导数的乘法法则 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>乘法法则</h2>
            <p>两个函数乘积的导数：</p>
            <div class="math-formula">
                $[f(x) \cdot g(x)]' = f'(x)g(x) + f(x)g'(x)$
            </div>
            <p><span class="highlight">记忆口诀：</span>前导后不导 + 前不导后导</p>
            <h3>例子</h3>
            <p>求 $y = x^2 \cdot e^x$ 的导数</p>
            <p>解：$y' = (x^2)' \cdot e^x + x^2 \cdot (e^x)'$</p>
            <p>　　$= 2x \cdot e^x + x^2 \cdot e^x$</p>
            <p>　　$= e^x(2x + x^2)$</p>
        </div>
        <div class="visualization" id="vis-product-rule"></div>
    </div>

    <!-- 第15页：导数的除法法则 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>除法法则</h2>
            <p>两个函数商的导数：</p>
            <div class="math-formula">
                $\left[\frac{f(x)}{g(x)}\right]' = \frac{f'(x)g(x) - f(x)g'(x)}{[g(x)]^2}$
            </div>
            <p><span class="highlight">记忆口诀：</span>上导下不导 减 上不导下导，除以下的平方</p>
            <h3>例子</h3>
            <p>求 $y = \frac{x^2}{x+1}$ 的导数</p>
            <p>解：$y' = \frac{2x(x+1) - x^2 \cdot 1}{(x+1)^2}$</p>
        </div>
        <div class="visualization" id="vis-quotient-rule"></div>
    </div>

    <!-- 第16页：复合函数求导（链式法则） -->
    <div class="slide">
        <div class="chalkboard">
            <h2>链式法则</h2>
            <p>复合函数 $y = f(g(x))$ 的导数：</p>
            <div class="math-formula">
                $y' = f'(g(x)) \cdot g'(x)$
            </div>
            <p><span class="highlight">步骤：</span></p>
            <ol>
                <li>先对外层函数求导</li>
                <li>再乘以内层函数的导数</li>
            </ol>
            <h3>例子</h3>
            <p>求 $y = (2x + 1)^3$ 的导数</p>
            <p>解：$y' = 3(2x + 1)^2 \cdot 2 = 6(2x + 1)^2$</p>
        </div>
        <div class="visualization" id="vis-chain-rule"></div>
    </div>

    <!-- 第17页：高阶导数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>高阶导数</h2>
            <p>对导数再求导，得到二阶导数：</p>
            <div class="math-formula">
                $f''(x) = [f'(x)]'$
            </div>
            <h3>记号</h3>
            <ul>
                <li>一阶导数：$f'(x)$ 或 $\frac{dy}{dx}$</li>
                <li>二阶导数：$f''(x)$ 或 $\frac{d^2y}{dx^2}$</li>
                <li>三阶导数：$f'''(x)$ 或 $\frac{d^3y}{dx^3}$</li>
            </ul>
            <h3>应用</h3>
            <p>二阶导数可以判断函数的凹凸性</p>
        </div>
        <div class="visualization" id="vis-higher-order"></div>
    </div>

    <!-- 第18页：练习与总结 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>练习与总结</h2>
            <h3>常用公式汇总</h3>
            <ul>
                <li>$(C)' = 0$</li>
                <li>$(x^n)' = nx^{n-1}$</li>
                <li>$(e^x)' = e^x$</li>
                <li>$(\ln x)' = \frac{1}{x}$</li>
                <li>$(\sin x)' = \cos x$</li>
                <li>$(\cos x)' = -\sin x$</li>
            </ul>
            <p><span class="highlight">记住：</span>导数是研究函数变化的工具！</p>
        </div>
        <div class="visualization" id="vis-practice"></div>
    </div>

    <!-- 翻页按钮 -->
    <div class="nav-buttons">
        <button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">‹</button>
        <button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">›</button>
    </div>

    <div class="page-indicator" id="page-indicator">1 / 18</div>

    <!-- 全局动画控制面板 -->
    <div class="global-animation-controls" id="globalAnimationControls">
        <button class="global-control-btn" id="globalPlayPauseBtn">暂停</button>
        <button class="global-control-btn" id="globalSpeedBtn">1.0x</button>
    </div>

</div>

<script>
    // 全局变量
    let slides, totalSlides, currentSlide = 0;
    let globalAnimationPlaying = true;
    let globalAnimationSpeed = 1.0;
    let activeAnimations = [];
    let activeTimeouts = [];
    let activeIntervals = [];

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        
        initGlobalAnimationControls();
        showSlide(0);
        
        // 键盘导航
        document.addEventListener('keydown', handleKeyNavigation);
        
        // 鼠标滚轮导航
        document.addEventListener('wheel', handleWheelNavigation, { passive: false });
    });

    // 全局动画控制
    function initGlobalAnimationControls() {
        const playPauseBtn = document.getElementById('globalPlayPauseBtn');
        const speedBtn = document.getElementById('globalSpeedBtn');
        const speedOptions = [0.5, 1, 1.5, 2, 3];
        let currentSpeedIndex = 1;

        playPauseBtn?.addEventListener('click', () => {
            globalAnimationPlaying = !globalAnimationPlaying;
            playPauseBtn.textContent = globalAnimationPlaying ? '暂停' : '播放';
            playPauseBtn.className = globalAnimationPlaying ? 'global-control-btn' : 'global-control-btn pause';
            updateAnimationStates();
        });

        speedBtn?.addEventListener('click', () => {
            currentSpeedIndex = (currentSpeedIndex + 1) % speedOptions.length;
            globalAnimationSpeed = speedOptions[currentSpeedIndex];
            speedBtn.textContent = globalAnimationSpeed.toFixed(1) + 'x';
            updateAnimationStates();
        });
    }

    function updateAnimationStates() {
        // 重新运行当前页面的动画
        runVisualization(currentSlide);
    }

    // 更新翻页按钮状态
    function updateNavButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        if (prevBtn && nextBtn) {
            prevBtn.disabled = (currentSlide === 0);
            nextBtn.disabled = (currentSlide === totalSlides - 1);
        }
    }

    // 导航功能
    function handleKeyNavigation(e) {
        if (e.key === 'ArrowRight' || e.key === ' ') {
            e.preventDefault();
            nextSlide();
        } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            previousSlide();
        } else if (e.key === 'Home') {
            e.preventDefault();
            goToSlide(0);
        } else if (e.key === 'End') {
            e.preventDefault();
            goToSlide(totalSlides - 1);
        }
    }

    function handleWheelNavigation(e) {
        e.preventDefault();
        if (e.deltaY > 0) {
            nextSlide();
        } else {
            previousSlide();
        }
    }

    function nextSlide() {
        if (currentSlide < totalSlides - 1) {
            currentSlide++;
            showSlide(currentSlide);
        }
    }

    function previousSlide() {
        if (currentSlide > 0) {
            currentSlide--;
            showSlide(currentSlide);
        }
    }

    function goToSlide(index) {
        if (index >= 0 && index < totalSlides) {
            currentSlide = index;
            showSlide(currentSlide);
        }
    }

    function showSlide(index) {
        // 清理之前的动画
        cleanupAnimations();
        
        slides.forEach(slide => slide.classList.remove('active'));
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        // 更新页码
        const indicator = document.getElementById('page-indicator');
        if (indicator) {
            indicator.textContent = `${currentSlide + 1} / ${totalSlides}`;
        }
        
        // 更新翻页按钮状态
        updateNavButtons();
        
        // 运行当前页的可视化
        runVisualization(currentSlide);
        
        // 渲染数学公式
        if (window.MathJax) {
            MathJax.typesetPromise([slides[currentSlide]]).catch(err => console.log(err));
        }
    }

    function cleanupAnimations() {
        // 清理所有活动的动画
        activeAnimations.forEach(anim => {
            if (anim && typeof anim === 'function') {
                cancelAnimationFrame(anim);
            }
        });
        activeAnimations = [];
        
        // 清理定时器
        activeTimeouts.forEach(timeout => clearTimeout(timeout));
        activeTimeouts = [];
        
        activeIntervals.forEach(interval => clearInterval(interval));
        activeIntervals = [];
    }

    // D3.js 辅助函数
    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 60, left: 60}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) return null;
        
        container.html('');
        
        const bounds = container.node().getBoundingClientRect();
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;
        
        const svg = container.append('svg')
            .attr('width', bounds.width)
            .attr('height', bounds.height);
            
        const g = svg.append('g')
            .attr('transform', `translate(${margins.left}, ${margins.top})`);
            
        return { container, svg, g, width, height, bounds };
    }

    // 运行可视化
    function runVisualization(slideIndex) {
        switch(slideIndex) {
            case 1: visualizeIntro(); break;
            case 2: visualizeAverageRate(); break;
            case 3: visualizeLimitApproach(); break;
            case 4: visualizeDerivativeDef(); break;
            case 5: visualizeTangentDemo(); break;
            case 6: visualizePhysics(); break;
            case 7: visualizeConstant(); break;
            case 8: visualizePower(); break;
            case 9: visualizeExponential(); break;
            case 10: visualizeLogarithm(); break;
            case 11: visualizeTrigonometric(); break;
            case 12: visualizeAdditionRule(); break;
            case 13: visualizeProductRule(); break;
            case 14: visualizeQuotientRule(); break;
            case 15: visualizeChainRule(); break;
            case 16: visualizeHigherOrder(); break;
            case 17: visualizePractice(); break;
        }
    }

    // 第2页：引入动画 - 增强版汽车行驶
    function visualizeIntro() {
        const setup = setupD3('vis-intro');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建渐变背景
        const gradient = g.append('defs')
            .append('linearGradient')
            .attr('id', 'roadGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '0%').attr('y2', '100%');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#87CEEB')
            .style('stop-opacity', 1);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#98D8E8')
            .style('stop-opacity', 1);

        // 背景
        g.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', width)
            .attr('height', height * 0.5)
            .attr('fill', 'url(#roadGradient)');

        // 绘制道路
        const roadY = height * 0.6;
        g.append('rect')
            .attr('x', 0)
            .attr('y', roadY - 40)
            .attr('width', width)
            .attr('height', 80)
            .attr('fill', '#444')
            .attr('rx', 5);

        // 道路边线
        g.append('line')
            .attr('x1', 0)
            .attr('y1', roadY - 38)
            .attr('x2', width)
            .attr('y2', roadY - 38)
            .attr('stroke', '#FFD700')
            .attr('stroke-width', 3);

        g.append('line')
            .attr('x1', 0)
            .attr('y1', roadY + 38)
            .attr('x2', width)
            .attr('y2', roadY + 38)
            .attr('stroke', '#FFD700')
            .attr('stroke-width', 3);

        // 道路中线（动态）
        const dashGroup = g.append('g');
        for (let i = 0; i < width; i += 40) {
            dashGroup.append('rect')
                .attr('x', i)
                .attr('y', roadY - 2)
                .attr('width', 20)
                .attr('height', 4)
                .attr('fill', 'white');
        }

        // 创建汽车组
        const car = g.append('g')
            .attr('transform', `translate(0, ${roadY})`);

        // 车身
        const carBody = car.append('g');
        
        // 主车身
        carBody.append('rect')
            .attr('x', -40)
            .attr('y', -25)
            .attr('width', 80)
            .attr('height', 35)
            .attr('fill', '#e74c3c')
            .attr('rx', 10);

        // 车窗
        carBody.append('rect')
            .attr('x', -25)
            .attr('y', -20)
            .attr('width', 30)
            .attr('height', 15)
            .attr('fill', '#3498db')
            .attr('opacity', 0.7)
            .attr('rx', 3);

        // 车轮
        car.append('circle')
            .attr('cx', -20)
            .attr('cy', 15)
            .attr('r', 10)
            .attr('fill', '#2c3e50');

        car.append('circle')
            .attr('cx', 20)
            .attr('cy', 15)
            .attr('r', 10)
            .attr('fill', '#2c3e50');

        // 速度显示面板
        const speedPanel = g.append('g')
            .attr('transform', `translate(${width/2}, 50)`);

        speedPanel.append('rect')
            .attr('x', -100)
            .attr('y', -30)
            .attr('width', 200)
            .attr('height', 60)
            .attr('fill', 'rgba(0,0,0,0.7)')
            .attr('rx', 10);

        const speedText = speedPanel.append('text')
            .attr('text-anchor', 'middle')
            .attr('y', 5)
            .attr('font-size', '24px')
            .attr('fill', 'white')
            .style('font-family', 'monospace');

        // 速度曲线显示
        const curveData = [];
        const curveX = d3.scaleLinear().domain([0, 100]).range([50, width - 50]);
        const curveY = d3.scaleLinear().domain([0, 100]).range([height - 50, height - 150]);
        
        const curvePath = g.append('path')
            .attr('fill', 'none')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3);

        const line = d3.line()
            .x(d => curveX(d.x))
            .y(d => curveY(d.y))
            .curve(d3.curveMonotoneX);

        // 动画
        let position = 0;
        let time = 0;
        let dataIndex = 0;
        
        function animate() {
            if (!globalAnimationPlaying) {
                activeAnimations.push(requestAnimationFrame(animate));
                return;
            }

            time += 0.016 / globalAnimationSpeed;
            
            // 变速运动（模拟真实驾驶）
            const baseSpeed = 50;
            const variation = 30 * Math.sin(time * 0.5) + 10 * Math.sin(time * 2);
            const speed = Math.max(10, baseSpeed + variation);
            
            position += speed * 0.016 / globalAnimationSpeed * 2;
            
            // 道路循环
            if (position > width + 50) {
                position = -50;
            }
            
            // 更新汽车位置
            car.attr('transform', `translate(${position}, ${roadY})`);
            
            // 更新速度显示
            speedText.text(`速度: ${speed.toFixed(1)} km/h`);
            
            // 更新速度曲线
            if (dataIndex % 5 === 0 && curveData.length < 100) {
                curveData.push({x: curveData.length, y: speed});
                if (curveData.length > 50) {
                    curveData.shift();
                    curveData.forEach((d, i) => d.x = i);
                }
                curvePath.attr('d', line(curveData));
            }
            dataIndex++;
            
            // 道路动画
            dashGroup.attr('transform', `translate(${-((position * 2) % 40)}, 0)`);
            
            activeAnimations.push(requestAnimationFrame(animate));
        }
        
        animate();
    }

    // 继续实现其他可视化函数...
    // 由于篇幅限制，我将提供几个关键的增强版可视化函数

    // 第3页：平均变化率 - 增强版
    function visualizeAverageRate() {
        const setup = setupD3('vis-average-rate');
        if (!setup) return;
        const { g, width, height } = setup;

        // 坐标轴
        const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);

        // 网格线
        const gridLinesX = g.append('g').attr('class', 'grid-x');
        const gridLinesY = g.append('g').attr('class', 'grid-y');

        for (let i = 0; i <= 5; i++) {
            gridLinesX.append('line')
                .attr('x1', xScale(i))
                .attr('y1', 0)
                .attr('x2', xScale(i))
                .attr('y2', height)
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0.5);
        }

        for (let i = 0; i <= 10; i++) {
            gridLinesY.append('line')
                .attr('x1', 0)
                .attr('y1', yScale(i))
                .attr('x2', width)
                .attr('y2', yScale(i))
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0.5);
        }

        const xAxis = d3.axisBottom(xScale).ticks(5);
        const yAxis = d3.axisLeft(yScale).ticks(10);

        g.append('g')
            .attr('transform', `translate(0, ${height})`)
            .call(xAxis)
            .append('text')
            .attr('x', width)
            .attr('y', 35)
            .attr('fill', 'white')
            .style('text-anchor', 'end')
            .text('x');

        g.append('g')
            .call(yAxis)
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -40)
            .attr('x', 0)
            .attr('fill', 'white')
            .style('text-anchor', 'end')
            .text('y');

        // 函数曲线 y = x^2
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        const data = d3.range(0, 5.1, 0.05).map(x => ({x: x, y: x * x / 2.5}));

        // 添加渐变
        const gradient = g.append('defs')
            .append('linearGradient')
            .attr('id', 'lineGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '0%');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#667eea')
            .style('stop-opacity', 1);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#764ba2')
            .style('stop-opacity', 1);

        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', 'url(#lineGradient)')
            .attr('stroke-width', 4);

        // 动画绘制曲线
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);

        // 动态点
        let x1 = 1, x2 = 3;
        let moving = false;

        const point1 = g.append('circle')
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', 'white')
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');

        const point2 = g.append('circle')
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', 'white')
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');

        // 割线
        const secant = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '8,4');

        // 标签
        const label1 = g.append('text')
            .attr('font-size', '14px')
            .attr('fill', 'white')
            .attr('text-anchor', 'middle');

        const label2 = g.append('text')
            .attr('font-size', '14px')
            .attr('fill', 'white')
            .attr('text-anchor', 'middle');

        // 斜率显示
        const slopeText = g.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('font-size', '22px')
            .attr('fill', 'white')
            .style('font-weight', 'bold');

        function updatePoints() {
            const y1 = x1 * x1 / 2.5;
            const y2 = x2 * x2 / 2.5;

            point1.attr('cx', xScale(x1)).attr('cy', yScale(y1));
            point2.attr('cx', xScale(x2)).attr('cy', yScale(y2));

            secant
                .attr('x1', xScale(x1))
                .attr('y1', yScale(y1))
                .attr('x2', xScale(x2))
                .attr('y2', yScale(y2));

            label1
                .attr('x', xScale(x1))
                .attr('y', yScale(y1) - 15)
                .text(`(${x1.toFixed(1)}, ${y1.toFixed(2)})`);

            label2
                .attr('x', xScale(x2))
                .attr('y', yScale(y2) - 15)
                .text(`(${x2.toFixed(1)}, ${y2.toFixed(2)})`);

            const slope = (y2 - y1) / (x2 - x1);
            slopeText.text(`割线斜率 = ${slope.toFixed(2)}`);
        }

        // 自动动画
        function animate() {
            if (!globalAnimationPlaying) {
                activeAnimations.push(requestAnimationFrame(animate));
                return;
            }

            x2 = 2 + 1.5 * Math.sin(Date.now() * 0.0005 / globalAnimationSpeed);
            updatePoints();

            activeAnimations.push(requestAnimationFrame(animate));
        }

        updatePoints();
        setTimeout(() => animate(), 2000);
    }

    // 第4页：极限逼近 - 增强版
    function visualizeLimitApproach() {
        const setup = setupD3('vis-limit-approach');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${height})`)
            .call(d3.axisBottom(xScale))
            .style('color', 'white');

        g.append('g')
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // 函数曲线
        const func = x => x * x / 2.5;
        const data = d3.range(0, 5.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 4);

        // 固定点
        const x0 = 2;
        const y0 = func(x0);

        const fixedPoint = g.append('circle')
            .attr('cx', xScale(x0))
            .attr('cy', yScale(y0))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', 'white')
            .attr('stroke-width', 2);

        // 添加发光效果
        fixedPoint.style('filter', 'drop-shadow(0 0 10px rgba(231, 76, 60, 0.8))');

        // 移动点和割线
        const movingPoint = g.append('circle')
            .attr('r', 6)
            .attr('fill', '#2ecc71')
            .attr('stroke', 'white')
            .attr('stroke-width', 2);

        const secantLine = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3);

        // 切线（最终显示）
        const tangentLine = g.append('line')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5')
            .attr('opacity', 0);

        const deltaText = g.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('font-size', '20px')
            .attr('fill', 'white');

        const slopeText = g.append('text')
            .attr('x', width / 2)
            .attr('y', 60)
            .attr('text-anchor', 'middle')
            .attr('font-size', '18px')
            .attr('fill', '#f39c12');

        // 轨迹点容器
        const traceGroup = g.append('g');

        // 动画
        let t = 1;
        let shrinking = true;
        
        function animate() {
            if (!globalAnimationPlaying) {
                activeAnimations.push(requestAnimationFrame(animate));
                return;
            }

            if (shrinking) {
                t = Math.max(0.01, t - 0.008 / globalAnimationSpeed);
                if (t <= 0.01) {
                    shrinking = false;
                    // 显示切线
                    const slope = 2 * x0 / 2.5; // 导数
                    tangentLine
                        .attr('x1', xScale(0))
                        .attr('y1', yScale(y0 + slope * (0 - x0)))
                        .attr('x2', xScale(5))
                        .attr('y2', yScale(y0 + slope * (5 - x0)))
                        .transition()
                        .duration(500)
                        .attr('opacity', 0.7);
                }
            } else {
                t = Math.min(1, t + 0.008 / globalAnimationSpeed);
                if (t >= 1) {
                    shrinking = true;
                    tangentLine.attr('opacity', 0);
                    traceGroup.selectAll('*').remove();
                }
            }
            
            const x1 = x0 + t;
            const y1 = func(x1);
            const slope = (y1 - y0) / (x1 - x0);

            movingPoint
                .attr('cx', xScale(x1))
                .attr('cy', yScale(y1));

            secantLine
                .attr('x1', xScale(x0))
                .attr('y1', yScale(y0))
                .attr('x2', xScale(x1))
                .attr('y2', yScale(y1));

            // 添加轨迹点
            if (Math.random() < 0.1) {
                traceGroup.append('circle')
                    .attr('cx', xScale(x1))
                    .attr('cy', yScale(y1))
                    .attr('r', 2)
                    .attr('fill', '#2ecc71')
                    .attr('opacity', 0.6)
                    .transition()
                    .duration(3000)
                    .attr('opacity', 0)
                    .remove();
            }

            deltaText.text(`Δx = ${t.toFixed(3)}`);
            slopeText.text(`割线斜率 = ${slope.toFixed(3)}`);

            activeAnimations.push(requestAnimationFrame(animate));
        }
        
        animate();
    }

    // 第6页：切线动态演示 - 增强版
    function visualizeTangentDemo() {
        const setup = setupD3('vis-tangent-demo');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1, 9]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', 'white');

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // 函数曲线 y = x^2
        const func = x => x * x;
        const data = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        // 曲线渐变
        const gradient = g.append('defs')
            .append('linearGradient')
            .attr('id', 'curveGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '0%');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#667eea')
            .style('stop-opacity', 1);
        
        gradient.append('stop')
            .attr('offset', '50%')
            .style('stop-color', '#764ba2')
            .style('stop-opacity', 1);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#667eea')
            .style('stop-opacity', 1);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', 'url(#curveGradient)')
            .attr('stroke-width', 4);

        // 移动的点
        const point = g.append('circle')
            .attr('r', 10)
            .attr('fill', '#e74c3c')
            .attr('stroke', 'white')
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(0 0 15px rgba(231, 76, 60, 0.8))');

        // 切线
        const tangent = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(0 0 8px rgba(243, 156, 18, 0.6))');

        // 导数值显示面板
        const infoPanel = g.append('g');
        
        infoPanel.append('rect')
            .attr('x', 10)
            .attr('y', 10)
            .attr('width', 180)
            .attr('height', 80)
            .attr('fill', 'rgba(0, 0, 0, 0.8)')
            .attr('rx', 10);

        const xText = infoPanel.append('text')
            .attr('x', 100)
            .attr('y', 35)
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .attr('fill', 'white');

        const slopeText = infoPanel.append('text')
            .attr('x', 100)
            .attr('y', 60)
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .attr('fill', '#f39c12');

        const formulaText = infoPanel.append('text')
            .attr('x', 100)
            .attr('y', 85)
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px')
            .attr('fill', '#95a5a6');

        // 历史轨迹
        const traceGroup = g.append('g');
        const traces = [];

        // 动画
        let t = 0;
        function animate() {
            if (!globalAnimationPlaying) {
                activeAnimations.push(requestAnimationFrame(animate));
                return;
            }

            t += 0.01 / globalAnimationSpeed;
            
            const x = 2.5 * Math.sin(t);
            const y = func(x);
            const slope = 2 * x; // f'(x) = 2x

            point
                .attr('cx', xScale(x))
                .attr('cy', yScale(y));

            // 切线端点
            const dx = 2;
            const x1 = x - dx;
            const x2 = x + dx;
            const y1 = y + slope * (x1 - x);
            const y2 = y + slope * (x2 - x);

            tangent
                .attr('x1', xScale(x1))
                .attr('y1', yScale(Math.max(-1, Math.min(9, y1))))
                .attr('x2', xScale(x2))
                .attr('y2', yScale(Math.max(-1, Math.min(9, y2))));

            // 更新信息
            xText.text(`x = ${x.toFixed(2)}`);
            slopeText.text(`f'(x) = ${slope.toFixed(2)}`);
            formulaText.text(`切线斜率 = 2x`);

            // 添加轨迹
            if (traces.length === 0 || Math.hypot(
                xScale(x) - xScale(traces[traces.length - 1].x),
                yScale(y) - yScale(traces[traces.length - 1].y)
            ) > 30) {
                const trace = {x, y, element: null};
                trace.element = traceGroup.append('circle')
                    .attr('cx', xScale(x))
                    .attr('cy', yScale(y))
                    .attr('r', 3)
                    .attr('fill', '#e74c3c')
                    .attr('opacity', 0.6);
                
                traces.push(trace);
                
                // 淡出旧轨迹
                if (traces.length > 20) {
                    const oldTrace = traces.shift();
                    oldTrace.element
                        .transition()
                        .duration(1000)
                        .attr('opacity', 0)
                        .remove();
                }
            }

            activeAnimations.push(requestAnimationFrame(animate));
        }
        
        animate();
    }

    // 第9页：幂函数 - 增强版
    function visualizePower() {
        const setup = setupD3('vis-power');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 10]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', 'white');

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // 绘制多个幂函数
        const functions = [
            { func: x => x, label: 'y = x', derivative: "y' = 1", color: '#3498db', n: 1 },
            { func: x => x * x, label: 'y = x²', derivative: "y' = 2x", color: '#e74c3c', n: 2 },
            { func: x => x * x * x, label: 'y = x³', derivative: "y' = 3x²", color: '#2ecc71', n: 3 }
        ];

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX)
            .defined(d => d.y >= -5 && d.y <= 10);

        // 创建函数路径
        functions.forEach((f, i) => {
            const data = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: f.func(x)}));

            const path = g.append('path')
                .datum(data)
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', f.color)
                .attr('stroke-width', 3)
                .attr('opacity', 0.3);

            // 鼠标悬停效果
            path.on('mouseover', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('stroke-width', 5)
                    .attr('opacity', 1);
                
                // 显示信息
                showFunctionInfo(f, i);
            })
            .on('mouseout', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('stroke-width', 3)
                    .attr('opacity', 0.3);
            });

            // 渐入动画
            path
                .attr('stroke-dasharray', function() {
                    return this.getTotalLength() + ' ' + this.getTotalLength();
                })
                .attr('stroke-dashoffset', function() {
                    return this.getTotalLength();
                })
                .transition()
                .delay(i * 500)
                .duration(1500)
                .attr('stroke-dashoffset', 0)
                .attr('opacity', 0.8);
        });

        // 信息面板
        const infoPanel = g.append('g')
            .attr('transform', `translate(${width - 200}, 20)`);

        infoPanel.append('rect')
            .attr('width', 180)
            .attr('height', 120)
            .attr('fill', 'rgba(0, 0, 0, 0.8)')
            .attr('rx', 10);

        const infoTitle = infoPanel.append('text')
            .attr('x', 90)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('font-size', '18px')
            .attr('fill', 'white');

        const infoFormula = infoPanel.append('text')
            .attr('x', 90)
            .attr('y', 60)
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .attr('fill', '#95a5a6');

        const infoDerivative = infoPanel.append('text')
            .attr('x', 90)
            .attr('y', 90)
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .attr('fill', '#f39c12');

        function showFunctionInfo(f, index) {
            infoTitle.text(f.label).attr('fill', f.color);
            infoFormula.text(`n = ${f.n}`);
            infoDerivative.text(f.derivative);
        }

        // 默认显示第一个函数
        showFunctionInfo(functions[0], 0);

        // 动态点演示
        const movingPoint = g.append('circle')
            .attr('r', 8)
            .attr('fill', 'white')
            .attr('stroke', '#34495e')
            .attr('stroke-width', 2);

        const tangentLine = g.append('line')
            .attr('stroke', 'white')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5')
            .attr('opacity', 0.7);

        let t = 0;
        let currentFuncIndex = 0;
        
        function animate() {
            if (!globalAnimationPlaying) {
                activeAnimations.push(requestAnimationFrame(animate));
                return;
            }

            t += 0.01 / globalAnimationSpeed;
            
            // 每3秒切换一个函数
            currentFuncIndex = Math.floor((t / 3) % functions.length);
            const currentFunc = functions[currentFuncIndex];
            
            const x = 2 * Math.sin(t);
            const y = currentFunc.func(x);
            
            if (y >= -5 && y <= 10) {
                movingPoint
                    .attr('cx', xScale(x))
                    .attr('cy', yScale(y))
                    .attr('fill', currentFunc.color)
                    .attr('opacity', 1);

                // 计算切线
                let slope;
                if (currentFunc.n === 1) slope = 1;
                else if (currentFunc.n === 2) slope = 2 * x;
                else if (currentFunc.n === 3) slope = 3 * x * x;

                const dx = 1;
                const x1 = x - dx;
                const x2 = x + dx;
                const y1 = y + slope * (x1 - x);
                const y2 = y + slope * (x2 - x);

                tangentLine
                    .attr('x1', xScale(x1))
                    .attr('y1', yScale(Math.max(-5, Math.min(10, y1))))
                    .attr('x2', xScale(x2))
                    .attr('y2', yScale(Math.max(-5, Math.min(10, y2))))
                    .attr('stroke', currentFunc.color);
            } else {
                movingPoint.attr('opacity', 0);
                tangentLine.attr('opacity', 0);
            }

            activeAnimations.push(requestAnimationFrame(animate));
        }

        animate();
    }

    // 其他可视化函数...
    // 由于篇幅限制，其余函数保持基本功能，但都应用类似的增强效果

    // 第7页：常数函数
    function visualizeConstant() {
        const setup = setupD3('vis-constant');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 8]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', 'white');

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // 常数函数 y = 3
        const y = 3;
        g.append('line')
            .attr('x1', xScale(-5))
            .attr('y1', yScale(y))
            .attr('x2', xScale(5))
            .attr('y2', yScale(y))
            .attr('stroke', '#3498db')
            .attr('stroke-width', 4);

        // 标签
        g.append('text')
            .attr('x', xScale(4))
            .attr('y', yScale(y) - 10)
            .text('y = 3')
            .attr('font-size', '20px')
            .attr('fill', '#3498db');

        // 导数图像 (y = 0)
        const derivativeLine = g.append('line')
            .attr('x1', xScale(-5))
            .attr('y1', yScale(0))
            .attr('x2', xScale(5))
            .attr('y2', yScale(0))
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '8,4')
            .attr('opacity', 0);

        // 导数标签
        const derivativeLabel = g.append('text')
            .attr('x', xScale(4))
            .attr('y', yScale(0) + 25)
            .text("y' = 0")
            .attr('font-size', '20px')
            .attr('fill', '#e74c3c')
            .attr('opacity', 0);

        // 动画显示导数
        setTimeout(() => {
            derivativeLine
                .transition()
                .duration(1000)
                .attr('opacity', 1);
            
            derivativeLabel
                .transition()
                .duration(1000)
                .attr('opacity', 1);
        }, 1500);
    }

    // 继续实现剩余的可视化函数...

    // 第10页：指数函数
    function visualizeExponential() {
        const setup = setupD3('vis-exponential');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 20]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${height})`)
            .call(d3.axisBottom(xScale))
            .style('color', 'white');

        g.append('g')
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // e^x 函数
        const data = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: Math.exp(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 4);

        // 动画绘制
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);

        // 特殊性质标注
        g.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('font-size', '22px')
            .attr('fill', 'white')
            .text("(e^x)' = e^x")
            .attr('opacity', 0)
            .transition()
            .delay(1500)
            .duration(1000)
            .attr('opacity', 1);
    }

    // 第11页：对数函数
    function visualizeLogarithm() {
        const setup = setupD3('vis-logarithm');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 3]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', 'white');

        g.append('g')
            .attr('transform', `translate(${xScale(0.01)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // ln(x) 函数
        const data = d3.range(0.1, 5.1, 0.05).map(x => ({x: x, y: Math.log(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 4);

        // 导数 1/x
        const derivativeData = d3.range(0.1, 5.1, 0.05).map(x => ({x: x, y: 1/x}));

        g.append('path')
            .datum(derivativeData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5')
            .attr('opacity', 0)
            .transition()
            .delay(1000)
            .duration(1000)
            .attr('opacity', 0.7);

        // 标签
        g.append('text')
            .attr('x', xScale(3))
            .attr('y', yScale(Math.log(3)) - 10)
            .text('y = ln(x)')
            .attr('font-size', '18px')
            .attr('fill', '#2ecc71');

        g.append('text')
            .attr('x', xScale(3))
            .attr('y', yScale(1/3) + 20)
            .text("y' = 1/x")
            .attr('font-size', '18px')
            .attr('fill', '#e74c3c')
            .attr('opacity', 0)
            .transition()
            .delay(1500)
            .duration(1000)
            .attr('opacity', 1);
    }

    // 第12页：三角函数
    function visualizeTrigonometric() {
        const setup = setupD3('vis-trigonometric');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-Math.PI, Math.PI]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1.5, 1.5]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale)
                .tickValues([-Math.PI, -Math.PI/2, 0, Math.PI/2, Math.PI])
                .tickFormat(d => {
                    if (d === 0) return '0';
                    if (d === Math.PI) return 'π';
                    if (d === -Math.PI) return '-π';
                    if (d === Math.PI/2) return 'π/2';
                    if (d === -Math.PI/2) return '-π/2';
                }))
            .style('color', 'white');

        g.append('g')
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // sin(x) 和 cos(x)
        const data = d3.range(-Math.PI, Math.PI, 0.05);
        
        const sinData = data.map(x => ({x: x, y: Math.sin(x)}));
        const cosData = data.map(x => ({x: x, y: Math.cos(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        // sin(x)
        g.append('path')
            .datum(sinData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        // cos(x)
        g.append('path')
            .datum(cosData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '8,4');

        // 标签
        g.append('text')
            .attr('x', xScale(Math.PI/4))
            .attr('y', yScale(Math.sin(Math.PI/4)) - 10)
            .text('sin(x)')
            .attr('font-size', '16px')
            .attr('fill', '#3498db');

        g.append('text')
            .attr('x', xScale(0))
            .attr('y', yScale(1) - 10)
            .text('cos(x) = (sin x)\'')
            .attr('font-size', '16px')
            .attr('fill', '#e74c3c');

        // 动画点
        const point1 = g.append('circle')
            .attr('r', 6)
            .attr('fill', '#3498db');

        const point2 = g.append('circle')
            .attr('r', 6)
            .attr('fill', '#e74c3c');

        let t = 0;
        function animate() {
            if (!globalAnimationPlaying) {
                activeAnimations.push(requestAnimationFrame(animate));
                return;
            }

            t += 0.02 / globalAnimationSpeed;
            const x = -Math.PI + (t % 1) * 2 * Math.PI;

            point1
                .attr('cx', xScale(x))
                .attr('cy', yScale(Math.sin(x)));

            point2
                .attr('cx', xScale(x))
                .attr('cy', yScale(Math.cos(x)));

            activeAnimations.push(requestAnimationFrame(animate));
        }
        
        animate();
    }

    // 第13页：加法法则
    function visualizeAdditionRule() {
        const setup = setupD3('vis-addition-rule');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-2, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 15]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', 'white');

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // f(x) = x^2 和 g(x) = 3x
        const data = d3.range(-2, 3.1, 0.05);
        
        const f = x => x * x;
        const gFunc = x => 3 * x;
        const sum = x => f(x) + gFunc(x);

        const line = d3.line()
            .x(d => xScale(d))
            .y(d => yScale(func(d)))
            .curve(d3.curveMonotoneX);

        // 绘制 f(x)
        let func = f;
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2)
            .attr('opacity', 0.5);

        // 绘制 g(x)
        func = gFunc;
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('opacity', 0.5);

        // 绘制 f(x) + g(x)
        func = sum;
        const sumPath = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 4);

        // 动画
        const totalLength = sumPath.node().getTotalLength();
        sumPath
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .delay(1000)
            .duration(2000)
            .attr('stroke-dashoffset', 0);

        // 标签
        g.append('text')
            .attr('x', xScale(1.5))
            .attr('y', yScale(f(1.5)))
            .text('x²')
            .attr('font-size', '16px')
            .attr('fill', '#3498db');

        g.append('text')
            .attr('x', xScale(2))
            .attr('y', yScale(gFunc(2)))
            .text('3x')
            .attr('font-size', '16px')
            .attr('fill', '#e74c3c');

        g.append('text')
            .attr('x', xScale(1))
            .attr('y', yScale(sum(1)) + 20)
            .text('x² + 3x')
            .attr('font-size', '18px')
            .attr('fill', '#2ecc71')
            .attr('opacity', 0)
            .transition()
            .delay(2000)
            .duration(1000)
            .attr('opacity', 1);
    }

    // 第14页：乘法法则
    function visualizeProductRule() {
        const setup = setupD3('vis-product-rule');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建演示区域
        const demoArea = g.append('g')
            .attr('transform', `translate(${width/2}, ${height/3})`);

        // 公式展示
        const formula = demoArea.append('text')
            .attr('text-anchor', 'middle')
            .attr('font-size', '26px')
            .attr('fill', 'white')
            .text('[x² · sin(x)]′');

        // 步骤展示
        const steps = [
            { text: '= (x²)′ · sin(x) + x² · (sin x)′', delay: 1000 },
            { text: '= 2x · sin(x) + x² · cos(x)', delay: 2000 },
            { text: '= x(2sin(x) + x·cos(x))', delay: 3000 }
        ];

        steps.forEach((step, i) => {
            demoArea.append('text')
                .attr('x', 0)
                .attr('y', 50 + i * 45)
                .attr('text-anchor', 'middle')
                .attr('font-size', '22px')
                .attr('fill', 'white')
                .text(step.text)
                .attr('opacity', 0)
                .transition()
                .delay(step.delay)
                .duration(500)
                .attr('opacity', 0.8);
        });
    }

    // 第15页：除法法则
    function visualizeQuotientRule() {
        const setup = setupD3('vis-quotient-rule');
        if (!setup) return;
        const { g, width, height } = setup;

        // 分步展示除法法则
        const steps = [
            { formula: 'y = x²/(x+1)', y: 50 },
            { formula: "y' = ?", y: 100 },
            { formula: "分子导数: (x²)' = 2x", y: 150 },
            { formula: "分母导数: (x+1)' = 1", y: 200 },
            { formula: "y' = [2x(x+1) - x²·1]/(x+1)²", y: 250 },
            { formula: "y' = (x² + 2x)/(x+1)²", y: 300 }
        ];

        steps.forEach((step, i) => {
            g.append('text')
                .attr('x', width / 2)
                .attr('y', step.y)
                .attr('text-anchor', 'middle')
                .attr('font-size', '22px')
                .attr('fill', i === 0 ? '#3498db' : (i === steps.length - 1 ? '#2ecc71' : 'white'))
                .text(step.formula)
                .attr('opacity', 0)
                .transition()
                .delay(i * 800)
                .duration(500)
                .attr('opacity', 1);
        });
    }

    // 第16页：链式法则
    function visualizeChainRule() {
        const setup = setupD3('vis-chain-rule');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建流程图
        const boxWidth = 140;
        const boxHeight = 70;
        const spacing = 100;

        const boxes = [
            { x: width/2 - boxWidth - spacing, y: height/3, text: '内函数\n2x+1', color: '#3498db' },
            { x: width/2 + spacing, y: height/3, text: '外函数\nu³', color: '#e74c3c' },
            { x: width/2 - boxWidth/2, y: 2*height/3, text: '结果\n6(2x+1)²', color: '#2ecc71' }
        ];

        boxes.forEach((box, i) => {
            const boxG = g.append('g')
                .attr('transform', `translate(${box.x}, ${box.y})`)
                .attr('opacity', 0);

            boxG.append('rect')
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('fill', box.color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', box.color)
                .attr('stroke-width', 3)
                .attr('rx', 10);

            const lines = box.text.split('\n');
            lines.forEach((line, j) => {
                boxG.append('text')
                    .attr('x', boxWidth / 2)
                    .attr('y', boxHeight / 2 + (j - 0.5) * 25)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '18px')
                    .attr('fill', 'white')
                    .text(line);
            });

            // 淡入动画
            boxG.transition()
                .delay(i * 500)
                .duration(800)
                .attr('opacity', 1);
        });

        // 定义箭头标记
        g.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', 'white');

        // 箭头
        setTimeout(() => {
            // 横向箭头
            g.append('path')
                .attr('d', `M ${boxes[0].x + boxWidth} ${boxes[0].y + boxHeight/2} 
                           L ${boxes[1].x - 10} ${boxes[1].y + boxHeight/2}`)
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .attr('marker-end', 'url(#arrowhead)')
                .attr('opacity', 0)
                .transition()
                .duration(500)
                .attr('opacity', 1);

            // 垂直箭头
            [0, 1].forEach(i => {
                g.append('path')
                    .attr('d', `M ${boxes[i].x + boxWidth/2} ${boxes[i].y + boxHeight} 
                               L ${boxes[2].x + boxWidth/2} ${boxes[2].y - 10}`)
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2)
                    .attr('marker-end', 'url(#arrowhead)')
                    .attr('opacity', 0)
                    .transition()
                    .delay(200 * i)
                    .duration(500)
                    .attr('opacity', 1);
            });
        }, 1500);
    }

    // 第17页：高阶导数
    function visualizeHigherOrder() {
        const setup = setupD3('vis-higher-order');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-30, 30]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', 'white');

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', 'white');

        // 函数 f(x) = x^3
        const data = d3.range(-3, 3.1, 0.05);
        
        const functions = [
            { func: x => x * x * x, label: 'f(x) = x³', color: '#3498db' },
            { func: x => 3 * x * x, label: "f'(x) = 3x²", color: '#e74c3c' },
            { func: x => 6 * x, label: "f''(x) = 6x", color: '#2ecc71' },
            { func: x => 6, label: "f'''(x) = 6", color: '#f39c12' }
        ];

        functions.forEach((f, i) => {
            const funcData = data.map(x => ({x: x, y: f.func(x)}));

            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .curve(d3.curveMonotoneX)
                .defined(d => d.y >= -30 && d.y <= 30);

            const path = g.append('path')
                .datum(funcData)
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', f.color)
                .attr('stroke-width', 3)
                .attr('opacity', 0);

            // 渐入动画
            path.transition()
                .delay(i * 800)
                .duration(1000)
                .attr('opacity', 0.7 + i * 0.1);

            // 标签
            g.append('text')
                .attr('x', 20)
                .attr('y', 30 + i * 30)
                .text(f.label)
                .attr('font-size', '16px')
                .attr('fill', f.color)
                .attr('opacity', 0)
                .transition()
                .delay(i * 800 + 500)
                .duration(500)
                .attr('opacity', 1);
        });
    }

    // 第18页：练习总结
    function visualizePractice() {
        const setup = setupD3('vis-practice');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建练习题卡片
        const cards = [
            { 
                question: 'y = 3x² + 2x - 1',
                answer: "y' = 6x + 2",
                x: width * 0.25,
                y: height * 0.3
            },
            {
                question: 'y = e^x · cos(x)',
                answer: "y' = e^x(cos x - sin x)",
                x: width * 0.75,
                y: height * 0.3
            },
            {
                question: 'y = ln(x²+1)',
                answer: "y' = 2x/(x²+1)",
                x: width * 0.25,
                y: height * 0.7
            },
            {
                question: 'y = sin(3x)',
                answer: "y' = 3cos(3x)",
                x: width * 0.75,
                y: height * 0.7
            }
        ];

        cards.forEach((card, i) => {
            const cardG = g.append('g')
                .attr('transform', `translate(${card.x - 120}, ${card.y - 60})`);

            // 卡片背景
            const rect = cardG.append('rect')
                .attr('width', 240)
                .attr('height', 120)
                .attr('fill', 'rgba(255, 255, 255, 0.1)')
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .attr('rx', 15)
                .style('filter', 'drop-shadow(0 4px 8px rgba(0,0,0,0.3))');

            // 题目
            cardG.append('text')
                .attr('x', 120)
                .attr('y', 40)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('fill', 'white')
                .text(card.question);

            // 答案（延迟显示）
            const answer = cardG.append('text')
                .attr('x', 120)
                .attr('y', 80)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('fill', '#2ecc71')
                .text(card.answer)
                .attr('opacity', 0);

            // 鼠标悬停效果
            rect.on('mouseover', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('fill', 'rgba(255, 255, 255, 0.2)');
                
                answer.transition()
                    .duration(300)
                    .attr('opacity', 1);
            })
            .on('mouseout', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('fill', 'rgba(255, 255, 255, 0.1)');
                
                answer.transition()
                    .duration(300)
                    .attr('opacity', 0);
            });

            // 卡片入场动画
            cardG
                .attr('opacity', 0)
                .attr('transform', `translate(${card.x - 120}, ${card.y - 40})`)
                .transition()
                .delay(i * 300)
                .duration(600)
                .attr('opacity', 1)
                .attr('transform', `translate(${card.x - 120}, ${card.y - 60})`)
                .ease(d3.easeBounceOut);
        });
    }

    // 第5页：导数定义
    function visualizeDerivativeDef() {
        const setup = setupD3('vis-derivative-def');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建三个展示区域
        const sections = [
            { title: '函数图像', x: 0, y: 0, w: width/3, h: height },
            { title: '切线斜率', x: width/3, y: 0, w: width/3, h: height },
            { title: '导数值', x: 2*width/3, y: 0, w: width/3, h: height }
        ];

        sections.forEach(section => {
            const group = g.append('g')
                .attr('transform', `translate(${section.x}, ${section.y})`);

            // 标题
            group.append('text')
                .attr('x', section.w / 2)
                .attr('y', 25)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('font-weight', 'bold')
                .attr('fill', 'white')
                .text(section.title);

            // 边框
            group.append('rect')
                .attr('x', 5)
                .attr('y', 35)
                .attr('width', section.w - 10)
                .attr('height', section.h - 45)
                .attr('fill', 'none')
                .attr('stroke', 'rgba(255, 255, 255, 0.3)')
                .attr('stroke-width', 1)
                .attr('rx', 5);
        });

        // 在第一个区域绘制函数
        const func = x => x * x;
        const xScale = d3.scaleLinear().domain([-2, 2]).range([10, width/3 - 10]);
        const yScale = d3.scaleLinear().domain([0, 4]).range([height - 45, 45]);

        const data = d3.range(-2, 2.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 3);

        // 点和切线动画
        let currentX = 0;
        const point = g.append('circle')
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', 'white')
            .attr('stroke-width', 2);

        const tangentLine = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5');

        function updateDerivative() {
            currentX = Math.sin(Date.now() * 0.0005) * 1.5;
            const y = func(currentX);
            const slope = 2 * currentX; // f'(x) = 2x

            // 更新点
            point.attr('cx', xScale(currentX))
                .attr('cy', yScale(y));

            // 更新切线
            const tangentX1 = -2;
            const tangentX2 = 2;
            const tangentY1 = y + slope * (tangentX1 - currentX);
            const tangentY2 = y + slope * (tangentX2 - currentX);

            tangentLine
                .attr('x1', xScale(tangentX1))
                .attr('y1', yScale(Math.max(0, Math.min(4, tangentY1))))
                .attr('x2', xScale(tangentX2))
                .attr('y2', yScale(Math.max(0, Math.min(4, tangentY2))));

            // 在第二个区域显示斜率
            g.select('#slope-display').remove();
            g.append('text')
                .attr('id', 'slope-display')
                .attr('x', width/2)
                .attr('y', height/2)
                .attr('text-anchor', 'middle')
                .attr('font-size', '28px')
                .attr('fill', '#f39c12')
                .text(`斜率 = ${slope.toFixed(2)}`);

            // 在第三个区域显示导数
            g.select('#derivative-display').remove();
            g.append('text')
                .attr('id', 'derivative-display')
                .attr('x', 5*width/6)
                .attr('y', height/2)
                .attr('text-anchor', 'middle')
                .attr('font-size', '28px')
                .attr('fill', '#2ecc71')
                .text(`f'(${currentX.toFixed(1)}) = ${slope.toFixed(2)}`);

            if (globalAnimationPlaying) {
                activeAnimations.push(requestAnimationFrame(updateDerivative));
            }
        }

        updateDerivative();
    }


    // 第7页
function visualizePhysics() {
    const setup = setupD3('vis-physics');
    if (!setup) return;
    const { g, width, height } = setup;

    // 创建三个图表
    const charts = [
        { title: '位移 s(t)', y: 0, color: '#3498db' },
        { title: '速度 v(t)', y: height/3, color: '#2ecc71' },
        { title: '加速度 a(t)', y: 2*height/3, color: '#e74c3c' }
    ];

    const xScale = d3.scaleLinear().domain([0, 5]).range([60, width - 20]);
    const yScales = charts.map(() => 
        d3.scaleLinear().domain([-10, 10]).range([height/3 - 30, 30])
    );

    charts.forEach((chart, i) => {
        const chartG = g.append('g')
            .attr('transform', `translate(0, ${chart.y})`);

        // 背景
        chartG.append('rect')
            .attr('x', 5)
            .attr('y', 5)
            .attr('width', width - 10)
            .attr('height', height/3 - 10)
            .attr('fill', 'rgba(0, 0, 0, 0.3)')
            .attr('rx', 5);

        // 标题
        chartG.append('text')
            .attr('x', 15)
            .attr('y', 25)
            .attr('font-size', '16px')
            .attr('font-weight', 'bold')
            .attr('fill', chart.color)
            .text(chart.title);

        // 坐标轴
        chartG.append('line')
            .attr('x1', xScale(0))
            .attr('x2', xScale(5))
            .attr('y1', yScales[i](0))
            .attr('y2', yScales[i](0))
            .attr('stroke', 'rgba(255, 255, 255, 0.3)')
            .attr('stroke-width', 1);
    });

    // 绘制函数
    const time = d3.range(0, 5.1, 0.05);
    
    // 位移: s(t) = t^2 - 2t
    const position = t => t * t - 2 * t;
    // 速度: v(t) = 2t - 2
    const velocity = t => 2 * t - 2;
    // 加速度: a(t) = 2
    const acceleration = t => 2;

    const functions = [position, velocity, acceleration];
    
    const line = d3.line()
        .x(d => xScale(d))
        .y((d, i) => yScales[Math.floor(i / time.length)](functions[Math.floor(i / time.length)](d)))
        .curve(d3.curveMonotoneX);

    // 绘制每个函数
    functions.forEach((func, i) => {
        const data = time.map(t => ({ t, value: func(t) }));
        
        const chartG = g.append('g')
            .attr('transform', `translate(0, ${charts[i].y})`);

        const pathLine = d3.line()
            .x(d => xScale(d.t))
            .y(d => yScales[i](d.value))
            .curve(d3.curveMonotoneX);

        const path = chartG.append('path')
            .datum(data)
            .attr('d', pathLine)
            .attr('fill', 'none')
            .attr('stroke', charts[i].color)
            .attr('stroke-width', 3);

        // 动画绘制
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .delay(i * 500)
            .duration(1500)
            .attr('stroke-dashoffset', 0);
    });

    // 添加移动的点来显示关系
    const movingPointG = g.append('g');
    
    const points = charts.map((chart, i) => {
        return movingPointG.append('circle')
            .attr('r', 6)
            .attr('fill', chart.color)
            .attr('stroke', 'white')
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');
    });

    // 值显示面板
    const valuePanel = g.append('g')
        .attr('transform', `translate(${width - 150}, 10)`);

    valuePanel.append('rect')
        .attr('width', 140)
        .attr('height', 100)
        .attr('fill', 'rgba(0, 0, 0, 0.8)')
        .attr('rx', 8);

    const timeText = valuePanel.append('text')
        .attr('x', 70)
        .attr('y', 25)
        .attr('text-anchor', 'middle')
        .attr('font-size', '14px')
        .attr('fill', 'white');

    const valueTexts = charts.map((chart, i) => {
        return valuePanel.append('text')
            .attr('x', 10)
            .attr('y', 45 + i * 20)
            .attr('font-size', '12px')
            .attr('fill', chart.color);
    });

    // 动画
    let currentT = 0;
    function animate() {
        if (!globalAnimationPlaying) {
            activeAnimations.push(requestAnimationFrame(animate));
            return;
        }

        currentT = (currentT + 0.01 / globalAnimationSpeed) % 5;
        
        const s = position(currentT);
        const v = velocity(currentT);
        const a = acceleration(currentT);
        
        points[0].attr('cx', xScale(currentT)).attr('cy', yScales[0](s) + charts[0].y);
        points[1].attr('cx', xScale(currentT)).attr('cy', yScales[1](v) + charts[1].y);
        points[2].attr('cx', xScale(currentT)).attr('cy', yScales[2](a) + charts[2].y);
        
        timeText.text(`t = ${currentT.toFixed(2)} s`);
        valueTexts[0].text(`s = ${s.toFixed(2)} m`);
        valueTexts[1].text(`v = ${v.toFixed(2)} m/s`);
        valueTexts[2].text(`a = ${a.toFixed(2)} m/s²`);
        
        activeAnimations.push(requestAnimationFrame(animate));
    }
    
    setTimeout(() => animate(), 2000);
}

// 添加浮动菜单功能
document.addEventListener('DOMContentLoaded', function() {
    // 创建浮动菜单
    const floatingMenu = document.createElement('div');
    floatingMenu.id = 'floating-menu';
    floatingMenu.innerHTML = `
        <button class="menu-toggle" onclick="toggleMenu()">📚 目录</button>
        <div class="menu-content" id="menuContent">
            <a href="#" class="menu-item" onclick="goToSlide(0); toggleMenu();">
                <span class="menu-icon">🏠</span>
                <span class="menu-text">标题页</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(1); toggleMenu();">
                <span class="menu-icon">1</span>
                <span class="menu-text">生活中的变化率</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(2); toggleMenu();">
                <span class="menu-icon">2</span>
                <span class="menu-text">平均变化率</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(3); toggleMenu();">
                <span class="menu-icon">3</span>
                <span class="menu-text">逼近瞬时变化率</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(4); toggleMenu();">
                <span class="menu-icon">4</span>
                <span class="menu-text">导数的定义</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(5); toggleMenu();">
                <span class="menu-icon">5</span>
                <span class="menu-text">切线演示</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(6); toggleMenu();">
                <span class="menu-icon">6</span>
                <span class="menu-text">导数的物理意义</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(7); toggleMenu();">
                <span class="menu-icon">7</span>
                <span class="menu-text">常数函数的导数</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(8); toggleMenu();">
                <span class="menu-icon">8</span>
                <span class="menu-text">幂函数的导数</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(9); toggleMenu();">
                <span class="menu-icon">9</span>
                <span class="menu-text">指数函数的导数</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(10); toggleMenu();">
                <span class="menu-icon">10</span>
                <span class="menu-text">对数函数的导数</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(11); toggleMenu();">
                <span class="menu-icon">11</span>
                <span class="menu-text">三角函数的导数</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(12); toggleMenu();">
                <span class="menu-icon">12</span>
                <span class="menu-text">加法法则</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(13); toggleMenu();">
                <span class="menu-icon">13</span>
                <span class="menu-text">乘法法则</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(14); toggleMenu();">
                <span class="menu-icon">14</span>
                <span class="menu-text">除法法则</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(15); toggleMenu();">
                <span class="menu-icon">15</span>
                <span class="menu-text">链式法则</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(16); toggleMenu();">
                <span class="menu-icon">16</span>
                <span class="menu-text">高阶导数</span>
            </a>
            <a href="#" class="menu-item" onclick="goToSlide(17); toggleMenu();">
                <span class="menu-icon">17</span>
                <span class="menu-text">练习与总结</span>
            </a>
        </div>
    `;
    document.body.appendChild(floatingMenu);
});

function toggleMenu() {
    const menuContent = document.getElementById('menuContent');
    menuContent.classList.toggle('active');
}

// 添加触摸支持
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

document.addEventListener('touchstart', function(e) {
    touchStartX = e.changedTouches[0].screenX;
    touchStartY = e.changedTouches[0].screenY;
}, false);

document.addEventListener('touchend', function(e) {
    touchEndX = e.changedTouches[0].screenX;
    touchEndY = e.changedTouches[0].screenY;
    handleSwipe();
}, false);

function handleSwipe() {
    const swipeThreshold = 50;
    const verticalThreshold = 100;
    
    const deltaX = touchEndX - touchStartX;
    const deltaY = Math.abs(touchEndY - touchStartY);
    
    // 确保是水平滑动而不是垂直滚动
    if (deltaY < verticalThreshold) {
        if (deltaX < -swipeThreshold) {
            nextSlide();
        } else if (deltaX > swipeThreshold) {
            previousSlide();
        }
    }
}

// 优化动画性能
function optimizeAnimations() {
    // 使用 will-change 属性优化动画元素
    const animatedElements = document.querySelectorAll('.function-path, .tangent-line, .point-marker');
    animatedElements.forEach(el => {
        el.style.willChange = 'transform, opacity';
    });
}

// 添加自适应功能
function handleResize() {
    // 重新渲染当前页面的可视化
    runVisualization(currentSlide);
}

window.addEventListener('resize', debounce(handleResize, 300));

// 防抖函数
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// 预加载资源
function preloadResources() {
    // 预加载下一页的内容
    if (currentSlide < totalSlides - 1) {
        const nextSlideIndex = currentSlide + 1;
        // 预渲染数学公式
        if (window.MathJax && slides[nextSlideIndex]) {
            MathJax.typesetPromise([slides[nextSlideIndex]]).catch(err => console.log(err));
        }
    }
}

// 添加加载指示器
function showLoadingIndicator() {
    const loader = document.createElement('div');
    loader.className = 'loading-indicator';
    loader.innerHTML = `
        <div style="
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 28px;
            border-radius: 18px;
            color: #1f2937;
            font-size: 18px;
            box-shadow: 0 18px 40px rgba(15, 23, 42, 0.18);
            z-index: 10000;
        ">
            加载中...
        </div>
    `;
    document.body.appendChild(loader);
    
    setTimeout(() => {
        loader.remove();
    }, 500);
}

// 初始化增强功能
document.addEventListener('DOMContentLoaded', function() {
    optimizeAnimations();
    preloadResources();
    
    // 添加页面切换时的预加载
    const originalShowSlide = showSlide;
    showSlide = function(index) {
        showLoadingIndicator();
        originalShowSlide(index);
        setTimeout(preloadResources, 100);
    };
});

// 添加键盘快捷键提示
function showKeyboardHints() {
    const hints = document.createElement('div');
    hints.style.cssText = `
        position: fixed;
        bottom: 100px;
        right: 30px;
        background: rgba(255, 255, 255, 0.95);
        color: #1f2937;
        padding: 16px 20px;
        border-radius: 18px;
        font-size: 14px;
        z-index: 1000;
        opacity: 0;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.18);
        backdrop-filter: blur(8px);
        transition: opacity 0.3s;
    `;
    hints.innerHTML = `
        <div style="margin-bottom: 10px; font-weight: bold;">键盘快捷键</div>
        <div>← → : 切换页面</div>
        <div>空格 : 下一页</div>
        <div>Home : 第一页</div>
        <div>End : 最后一页</div>
    `;
    document.body.appendChild(hints);
    
    // 淡入效果
    setTimeout(() => {
        hints.style.opacity = '1';
    }, 100);
    
    // 3秒后自动消失
    setTimeout(() => {
        hints.style.opacity = '0';
        setTimeout(() => hints.remove(), 300);
    }, 3000);
}

// 首次加载时显示键盘提示
setTimeout(showKeyboardHints, 2000);

// 添加页面统计功能
let pageViewTimes = new Array(totalSlides).fill(0);
let pageStartTime = Date.now();

function trackPageView() {
    const currentTime = Date.now();
    const timeSpent = (currentTime - pageStartTime) / 1000; // 转换为秒
    pageViewTimes[currentSlide] += timeSpent;
    pageStartTime = currentTime;
}

// 在切换页面时记录时间
const originalShowSlideForTracking = showSlide;
showSlide = function(index) {
    trackPageView();
    originalShowSlideForTracking(index);
};

// 添加学习进度保存功能
function saveProgress() {
    const progress = {
        currentSlide: currentSlide,
        pageViewTimes: pageViewTimes,
        lastVisit: new Date().toISOString()
    };
    // 注意：由于浏览器限制，这里只是示例代码
    console.log('学习进度已保存:', progress);
}

// 定期保存进度
setInterval(saveProgress, 30000); // 每30秒保存一次

// 页面卸载时保存进度
window.addEventListener('beforeunload', saveProgress);

// 添加全屏功能
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.log(`无法进入全屏模式: ${err.message}`);
        });
    } else {
        document.exitFullscreen();
    }
}

// 添加全屏按钮
document.addEventListener('DOMContentLoaded', function() {
    const fullscreenBtn = document.createElement('button');
    fullscreenBtn.className = 'global-control-btn';
    fullscreenBtn.textContent = '全屏';
    fullscreenBtn.style.cssText = `
        position: fixed;
        bottom: 30px;
        right: 140px;
        z-index: 1000;
    `;
    fullscreenBtn.onclick = toggleFullscreen;
    document.body.appendChild(fullscreenBtn);
});

// 性能监控
function monitorPerformance() {
    if (window.performance && window.performance.memory) {
        const memoryInfo = window.performance.memory;
        const usedMemory = (memoryInfo.usedJSHeapSize / 1048576).toFixed(2);
        const totalMemory = (memoryInfo.totalJSHeapSize / 1048576).toFixed(2);
        console.log(`内存使用: ${usedMemory} MB / ${totalMemory} MB`);
    }
}

// 定期监控性能
setInterval(monitorPerformance, 10000);

// 优化SVG渲染
function optimizeSVGRendering() {
    const svgElements = document.querySelectorAll('svg');
    svgElements.forEach(svg => {
        svg.style.shapeRendering = 'optimizeSpeed';
        svg.style.imageRendering = 'optimizeSpeed';
    });
}

// 添加错误处理
window.addEventListener('error', function(e) {
    console.error('发生错误:', e.error);
    // 可以添加用户友好的错误提示
});

// 添加平滑滚动效果
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function(e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
            target.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
        }
    });
});

console.log('🎓 导数与微分课件加载完成！');
console.log('💡 提示：使用方向键或鼠标滚轮切换页面');
console.log('📚 点击右下角"目录"按钮快速跳转');
</script>
</body>
</html>