<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>

<meta content="width=device-width, initial-scale=1.0" name="viewport"/>

<title>微积分第二章：极限与连续 - 完整版</title>

<script src="../common-assets/js/d3-7.8.5.min.js"></script>

<!-- 使用统一的MathJax配置文件，避免配置冲突 -->

<script src="../common-assets/js/mathjax-config.js"></script>

<script async="" id="MathJax-script" src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js" type="text/javascript">

</script>

<style>

        @import url('../common-assets/css/fonts.css');



        :root {

            --chalkboard-bg: #2c3e50;

            --chalk-text: #ecf0f1;

            --visualization-bg: #ffffff;

            --primary-color: #3498db;

            --accent-color: #e67e22;

            --success-color: #2ecc71;

            --danger-color: #e74c3c;

            --warning-color: #f39c12;

            --info-color: #9b59b6;

            --text-color: #34495e;

            --heading-font: 'Noto Serif SC', serif;

            --handwriting-font: 'Noto Serif SC', serif;

        }



        body {

            font-family: var(--heading-font);

            margin: 0;

            background-color: #f0f2f5;

        }



        .scrolly-container {

            display: flex;

            width: 100%;

            min-height: 100vh;

        }



        .lecture-notes {

            flex: 0 0 55%;

            max-width: 55%;

            padding: 24px 0;

            word-wrap: break-word;

            box-sizing: border-box;

            transition: all 0.5s ease-in-out; /* Add this line */

        }



        .lecture-notes.is-fullscreen {

            flex: 0 0 100%;

            max-width: 100%;

        }



        #step-toc .toc-board {

            display: flex;

            align-items: stretch;

            gap: 2rem;

            text-align: left;

        }



        #step-toc .toc-header {

            writing-mode: vertical-rl;

            text-orientation: mixed;

            font-size: 3rem;

            height: 100%;

            display: flex;

            align-items: center;

            justify-content: center;

            border: none;

            padding: 1rem 0;

        }



        #step-toc .toc-grid {

            flex: 1;

            display: grid;

            grid-template-columns: repeat(3, minmax(0, 1fr));

            gap: 1.5rem;

            max-width: 1400px;

        }



        #step-toc .toc-item {

            background: rgba(255,255,255,0.1);

            padding: 0.8rem;

            border-radius: 10px;

            backdrop-filter: blur(10px);

        }



        #step-toc .toc-item h3 {

            color: #e74c3c;

            font-size: 1.3rem;

            margin-bottom: 0.5rem;

            border-bottom: 2px solid #e74c3c;

            padding-bottom: 0.2rem;

            text-align: left;

        }



        #step-toc .toc-list {

            display: grid;

            grid-template-columns: repeat(2, minmax(0, 1fr));

            gap: 0.5rem;

            font-size: 1rem;

            line-height: 1.3;

        }





        .step {

            min-height: 100vh;

            display: flex;

            flex-direction: column;

            justify-content: center;

            background-color: var(--chalkboard-bg);

            background-image: url('../common-assets/images/black-felt.png');

            border-bottom: 1px solid #444;

            color: var(--chalk-text);

            box-sizing: border-box;

            opacity: 0.3;

            transition: opacity 0.5s;

            padding: 0;

        }



        .step.is-active {

            opacity: 1;

        }



        .step:last-child {

            border-bottom: none;

        }



        .step h2 {

            font-family: var(--handwriting-font);

            font-size: 2.2rem;

            color: #f1c40f;

            border-bottom: 2px solid rgba(241, 196, 15, 0.5);

        }



        .step h3 {

            font-family: var(--handwriting-font);

            font-size: 1.5rem;

            color: var(--primary-color);

        }



        .step p, .step li {

            font-size: 1.1rem;

            line-height: 1.7;

        }



        .step ul {

            list-style-type: '→ ';

        }



        .visualization-panel {

            flex: 0 0 45%;

            max-width: 45%;

            position: relative;

            opacity: 1;

            visibility: visible;

            transition: all 0.5s ease-in-out; /* Add this line */

        }



        #sticky-vis-container {

            position: sticky;

            top: 0;

            width: 100%;

            height: 100vh;

            display: flex;

            justify-content: center;

            align-items: center;

            background-color: var(--visualization-bg);

            transition: opacity 0.5s;

        }



        #sticky-vis-container.visualization-flex {

            display: flex;

            justify-content: center;

            align-items: center;

            padding: 30px;

            box-sizing: border-box;

        }



        #sticky-vis-container.visualization-grid {

            display: grid;

            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));

            gap: 20px;

            padding: 30px;

            box-sizing: border-box;

            overflow-y: auto;

        }



        .visualization-flex {

            display: flex;

            justify-content: center;

            align-items: center;

            padding: 30px;

            box-sizing: border-box;

        }



        .visualization-grid {

            display: grid;

            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));

            gap: 20px;

            padding: 30px;

            box-sizing: border-box;

            overflow-y: auto;

        }



        .step.fullscreen {

            padding: 0;

            border: none;

        }



        .step.fullscreen .fullscreen-vis-container {

            width: 100%;

            height: 100vh;

            background-color: var(--visualization-bg);

        }



        .step.fullscreen[data-theme="dark"] .fullscreen-vis-container {

            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);

        }



        .chalkboard {

            background-color: #2c3e50 !important;

            border: 10px solid #8B4513; /* 木质边框 */

            color: var(--chalk-text, #f0f0f0);

            padding: 28px;

            margin: 0;

            width: 100%;

            height: 100%;

            box-sizing: border-box;

            word-wrap: break-word;

            word-break: break-word;

            box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.7);

        }

        

        /* 自定义滚动条样式 */

        .chalkboard::-webkit-scrollbar {

            width: 8px;

        }

        

        .chalkboard::-webkit-scrollbar-track {

            background: rgba(0, 0, 0, 0.3);

            border-radius: 4px;

        }

        

        .chalkboard::-webkit-scrollbar-thumb {

            background: rgba(255, 255, 255, 0.3);

            border-radius: 4px;

        }

        

        .chalkboard::-webkit-scrollbar-thumb:hover {

            background: rgba(255, 255, 255, 0.5);

        }



        .chalkboard h2 {

            font-family: var(--handwriting-font);

            font-size: 2.2rem;

            color: #f1c40f;

            border-bottom: 2px solid rgba(241, 196, 15, 0.5);

            padding-bottom: 2px;

            margin-bottom:3px;

        }



        .chalkboard h3 {

            font-family: var(--handwriting-font);

            font-size: 1.5rem;

            color: var(--primary-color);

            margin-top: 5px;

            margin-bottom: 5px;

        }



        .chalkboard p, .chalkboard li {

            font-size: 1.1rem;

            line-height: 1.4;

            margin-bottom: 8px;

            word-wrap: break-word;

            overflow-wrap: break-word;

            max-width: 100%;

        }



        .chalkboard ul {

            list-style-type: '▸ ';

            padding-left: 20px;

            margin-bottom: 8px;

        }



        .math-formula {

            font-size: 1.2rem;

            color: #1abc9c;

            background: rgba(26, 188, 156, 0.1);

            padding: 12px;

            border-radius: 8px;

            text-align: center;

            margin: 15px 0;

            border: 2px solid rgba(26, 188, 156, 0.3);

            word-wrap: break-word;

            overflow-wrap: break-word;

            max-width: 100%;

        }



        .highlight {

            color: var(--warning-color);

            font-weight: bold;

            background: rgba(243, 156, 18, 0.1);

            padding: 2px 6px;

            border-radius: 4px;

        }



        .example-box {

            background: rgba(52, 152, 219, 0.1);

            border-left: 4px solid var(--primary-color);

            padding: 15px;

            margin: 20px 0;

        }



        .example-box h4 {

            color: var(--primary-color);

            margin-top: 0;

            font-size: 1rem;

        }



        .step-box {

            background: rgba(46, 204, 113, 0.1);

            border: 1px solid rgba(46, 204, 113, 0.3);

            padding: 10px;

            margin: 10px 0;

            border-radius: 5px;

        }



        .warning-box {

            background: rgba(231, 76, 60, 0.1);

            border: 2px solid rgba(231, 76, 60, 0.3);

            padding: 15px;

            margin: 20px 0;

            border-radius: 8px;

        }



        .visualization {

            flex: 1;

            padding: 30px;

            display: grid;

            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));

            gap: 20px;

            overflow-y: auto;

            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);

        }



        .vis-item {

            background: white;

            border-radius: 8px;

            padding: 15px;

            position: relative;

            cursor: pointer;

            transition: transform 0.2s, box-shadow 0.2s;

            box-shadow: 0 2px 8px rgba(0,0,0,0.1);

        }



        .vis-item:hover {

            transform: scale(1.02);

            box-shadow: 0 4px 12px rgba(0,0,0,0.15);

        }



        .vis-item svg {

            width: 100%;

            height: auto;

        }



        .vis-title {

            display: flex;

            flex-direction: row;

            align-items: center;

            justify-content: center;

            gap: 0.1em;

            font-size: 1rem;

            color: var(--text-color);

            margin-bottom: 10px;

            height: auto;

            line-height: 1.2;

        }



        .approach-indicator {

            position: absolute;

            top: 5px;

            right: 5px;

            background: rgba(52, 152, 219, 0.9);

            color: white;

            padding: 2px 6px;

            border-radius: 10px;

            font-size: 0.7rem;

            font-weight: bold;

        }



        .approach-left {

            background: rgba(231, 76, 60, 0.9);

        }



        .approach-right {

            background: rgba(46, 204, 113, 0.9);

        }



        .approach-both {

            background: rgba(155, 89, 182, 0.9);

        }



        .expanded-overlay {

            position: fixed;

            top: 0;

            left: 0;

            width: 100vw;

            height: 100vh;

            background: rgba(0,0,0,0.8);

            z-index: 1000;

            display: flex;

            justify-content: center;

            align-items: center;

            opacity: 0;

            visibility: hidden;

            transition: all 0.3s ease;

        }



        .expanded-overlay.active {

            opacity: 1;

            visibility: visible;

        }



        .expanded-content {

            background: white;

            border-radius: 12px;

            padding: 30px;

            width: 80vw;

            height: 80vh;

            position: relative;

            transform: scale(0.8);

            transition: transform 0.3s ease;

            display: flex;

            flex-direction: column;

        }



        .expanded-overlay.active .expanded-content {

            transform: scale(1);

        }



        .expanded-title {

            font-size: 1.5rem;

            margin-bottom: 20px;

            text-align: center;

            color: var(--text-color);

            line-height: 1.8;

            min-height: 3rem;

            display: flex;

            align-items: center;

            justify-content: center;

        }



        .expanded-title mjx-container {

            font-size: 1.2em !important;

        }



        .simple-annotation {

            font-family: var(--heading-font);

        }



        .simple-annotation mjx-container {

            font-size: 1.1em !important;

        }



        .expanded-annotation {

            text-align: center;

            margin-bottom: 15px;

            font-style: italic;

            color: #6c757d;

        }



        .expanded-svg-container {

            flex: 1;

            overflow: auto;

            position: relative;

        }



        .expanded-controls {

            display: flex;

            justify-content: space-between;

            align-items: center;

            padding: 15px 20px;

            background: #f8f9fa;

            border-radius: 10px;

            margin: 20px;

            flex-wrap: wrap;

            gap: 15px;

        }



        .control-group {

            display: flex;

            align-items: center;

            gap: 10px;

        }



        .control-group label {

            display: flex;

            align-items: center;

            gap: 8px;

            font-weight: 500;

            color: #495057;

        }



        .control-group input[type="range"] {

            width: 120px;

        }



        .control-group button {

            padding: 8px 16px;

            background: #007bff;

            color: white;

            border: none;

            border-radius: 5px;

            cursor: pointer;

            font-size: 14px;

            transition: background 0.3s;

        }



        .control-group button:hover {

            background: #0056b3;

        }



        .annotation-text {

            background: rgba(52, 152, 219, 0.1);

            color: #2980b9;

            padding: 5px 12px;

            border-radius: 15px;

            font-size: 14px;

            display: inline-block;

        }



        .close-btn {

            position: absolute;

            top: 10px;

            right: 10px;

            background: var(--danger-color);

            color: white;

            border: none;

            border-radius: 50%;

            width: 30px;

            height: 30px;

            cursor: pointer;

            font-size: 18px;

        }



        .close-btn:hover {

            background: #c0392b;

        }







        .page-info {

            display: none;

        }



        .interactive-panel {

            position: absolute;

            bottom: 30px;

            right: 70px;

            background: rgba(255, 255, 255, 0.95);

            padding: 20px;

            border-radius: 10px;

            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);

        }



        .draggable-panel {

            cursor: move;

            user-select: none;

        }



        .draggable-panel h3 {

            cursor: grab;

            margin: 0 0 15px 0;

            padding: 5px 0;

            border-bottom: 2px solid var(--primary-color);

            color: var(--primary-color);

            font-weight: bold;

        }



        .draggable-panel h3:hover {

            background: rgba(52, 152, 219, 0.1);

            border-radius: 5px;

            padding: 5px;

        }



        .draggable-panel.dragging {

            cursor: grabbing;

            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);

            transform: scale(1.02);

            transition: transform 0.1s ease;

        }



        .draggable-panel.dragging h3 {

            cursor: grabbing;

        }



        .button-container {

            display: flex;

            flex-wrap: wrap;

            gap: 10px;

            margin: 15px 0;

            align-items: center;

        }



        .slider-container {

            display: flex;

            align-items: center;

            gap: 15px;

            margin: 10px 0;

        }



        .slider {

            flex: 1;

            -webkit-appearance: none;

            height: 8px;

            border-radius: 5px;

            background: linear-gradient(to right, var(--primary-color) 0%, var(--accent-color) 100%);

            outline: none;

        }



        .slider::-webkit-slider-thumb {

            -webkit-appearance: none;

            appearance: none;

            width: 20px;

            height: 20px;

            border-radius: 50%;

            background: white;

            border: 3px solid var(--primary-color);

            cursor: pointer;

        }





        .formula-step {

            display: flex;

            align-items: center;

            justify-content: center;

            gap: 20px;

            margin: 15px 0;

            font-size: 1.3rem;

        }



        .formula-arrow {

            color: var(--accent-color);

            font-size: 1.5rem;

        }



        @keyframes pulse {

            0%, 100% { 

                opacity: 0.8; 

                transform: scale(1); 

            }

            50% { 

                opacity: 1; 

                transform: scale(1.05); 

            }

        }



        @keyframes fadeIn {

            from { opacity: 0; transform: translateY(20px); }

            to { opacity: 1; transform: translateY(0); }

        }

        

        .animated-point, .fade-in, .pulse {

            will-change: transform, opacity;

            transform: translateZ(0);

            backface-visibility: hidden;

        }



        .animated-point {

            animation: pulse 2s ease-in-out infinite;

        }



        .fade-in {

            animation: fadeIn 0.8s ease-out;

        }



        .limit-arrow {

            stroke: var(--danger-color);

            stroke-width: 2;

            marker-end: url(#arrowhead);

            stroke-dasharray: 5, 5;

            animation: dash 2s linear infinite;

        }



        @keyframes dash {

            to { stroke-dashoffset: -10; }

        }



        .epsilon-band {

            fill: rgba(52, 152, 219, 0.2);

            stroke: rgba(52, 152, 219, 0.5);

            stroke-width: 1;

            stroke-dasharray: 3, 3;

        }



        .thinking-bubble {

            background: rgba(255, 255, 255, 0.95);

            border-radius: 20px;

            padding: 15px;

            position: relative;

            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);

        }



               /* 极限动画增强样式 */

               .limit-approach-container .approach-indicator {

            animation: pulse 2s infinite ease-in-out;

        }



        @keyframes pulse {

            0%, 100% { 

                opacity: 0.8; 

                transform: scale(1); 

            }

            50% { 

                opacity: 1; 

                transform: scale(1.05); 

            }

        }



        .left-approach-point, .right-approach-point {

            filter: drop-shadow(0 0 4px currentColor);

        }

        

        .chart-annotation {

            margin-top: 15px;

            padding: 12px 20px;

            background: rgba(52, 73, 94, 0.08);

            border-radius: 8px;

            font-size: 14px;

            line-height: 1.5;

            color: var(--text-color);

            border: none;

            font-family: 'Noto Serif SC', serif;

            max-width: 800px;

            margin-left: auto;

            margin-right: auto;

        }

        

        .chart-annotation .conclusion {

            font-weight: 600;

            color: var(--primary-color);

        }

        

        .chart-annotation .analysis {

            margin-top: 4px;

            opacity: 0.8;

        }



    /* 封面样式 */

    .cover-full {

        display: flex;

        flex-direction: column;

        width: 100%;

        height: 100%;

        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);

        justify-content: center;

        align-items: center;

        padding: 60px;

        box-sizing: border-box;

    }



    .cover-content {

        max-width: 1000px;

        text-align: center;

        background: rgba(255, 255, 255, 0.95);

        padding: 60px;

        border-radius: 20px;

        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);

    }



    .cover-header {

        margin-bottom: 50px;

    }



    .cover-title-main {

        font-size: 3.5rem;

        color: var(--primary-color);

        font-weight: bold;

        margin: 0 0 15px 0;

        text-shadow: 2px 2px 4px rgba(0,0,0,0.1);

    }



    .cover-title-subtitle {

        font-size: 2.2rem;

        color: var(--accent-color);

        margin: 0;

        font-weight: 600;

    }



    .cover-version {

        font-size: 1.4rem;

        color: var(--success-color);

        margin-top: 20px;

        font-weight: 500;

    }



    .cover-center {

        margin: 50px 0;

    }



    .cover-icon {

        font-size: 5rem;

        margin-bottom: 40px;

        text-shadow: 2px 2px 8px rgba(0,0,0,0.2);

        animation: pulse 3s ease-in-out infinite;

    }



    .cover-objectives {

        margin-bottom: 40px;

    }



    .objectives-list {

        display: grid;

        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));

        gap: 20px;

        margin-top: 20px;

    }



    .objective-item {

        display: flex;

        align-items: center;

        gap: 15px;

        padding: 15px;

        background: rgba(52, 152, 219, 0.1);

        border-radius: 10px;

        border-left: 4px solid var(--primary-color);

        transition: transform 0.2s ease, box-shadow 0.2s ease;

    }



    .objective-item:hover {

        transform: translateY(-2px);

        box-shadow: 0 8px 15px rgba(0,0,0,0.15);

    }



    .objective-icon {

        font-size: 1.5rem;

        flex-shrink: 0;

    }



    .knowledge-flow {

        display: flex;

        align-items: center;

        gap: 20px;

        margin-top: 40px;

        padding: 25px;

        background: rgba(155, 89, 182, 0.1);

        border-radius: 15px;

        border: 2px solid rgba(155, 89, 182, 0.3);

    }



    .flow-item {

        padding: 12px 25px;

        background: linear-gradient(135deg, var(--primary-color), var(--accent-color));

        color: white;

        border-radius: 25px;

        font-weight: 600;

        font-size: 0.95rem;

        text-align: center;

        min-width: 140px;

        box-shadow: 0 4px 15px rgba(0,0,0,0.2);

        transition: transform 0.3s ease;

    }



    .current {

        background: linear-gradient(135deg, var(--success-color), #27ae60) !important;

        transform: scale(1.05);

    }



    .flow-arrow {

        font-size: 1.5rem;

        color: var(--accent-color);

        font-weight: bold;

    }



    .cover-footer {

        margin-top: 60px;

        border-top: 2px solid rgba(0,0,0,0.1);

        padding-top: 30px;

    }



    .nav-guide {

        display: flex;

        justify-content: center;

        gap: 20px;

        margin-bottom: 30px;

    }



    .nav-item {

        display: flex;

        flex-direction: column;

        align-items: center;

        gap: 8px;

        padding: 15px 20px;

        background: rgba(52, 152, 219, 0.1);

        border-radius: 10px;

        transition: background 0.3s ease;

    }



    .nav-item:hover {

        background: rgba(52, 152, 219, 0.2);

    }



    .nav-icon {

        font-size: 1.5rem;

    }



    .tech-info {

        color: var(--info-color);

        font-size: 0.9rem;

        font-weight: 500;

        padding: 10px 20px;

        background: rgba(26, 188, 156, 0.1);

        border-radius: 20px;

        display: inline-block;

    }



    /* 首页导航按钮样式 */

    .home-nav-buttons {

        display: flex;

        justify-content: center;

        gap: 20px;

        margin-top: 40px;

        flex-wrap: wrap;

    }



    .nav-btn {

        display: flex;

        flex-direction: column;

        align-items: center;

        padding: 15px 20px;

        background: rgba(255, 255, 255, 0.1);

        border: 2px solid rgba(255, 255, 255, 0.3);

        border-radius: 15px;

        text-decoration: none;

        color: white;

        transition: all 0.3s ease;

        backdrop-filter: blur(10px);

        min-width: 120px;

        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);

    }



    .nav-btn:hover {

        background: rgba(255, 255, 255, 0.2);

        border-color: rgba(255, 255, 255, 0.5);

        transform: translateY(-5px);

        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);

    }



    .nav-btn .btn-icon {

        font-size: 1.2rem;

        margin-bottom: 8px;

        font-weight: bold;

        letter-spacing: 1px;

    }



    .nav-btn .btn-text {

        font-size: 1.1rem;

        font-weight: 500;

    }



    .cover-chalkboard {

        display: flex;

        flex-direction: column;

        align-items: center;

        text-align: center;

        gap: 24px;

    }



    .cover-button-area {

        display: flex;

        flex-direction: column;

        gap: 24px;

        width: 100%;

        max-width: 990px;

    }



    .cover-primary-group {

        display: flex;

        justify-content: center;

    }



    .cover-quick-links {

        display: flex;

        justify-content: center;

        gap: 12px;

        flex-wrap: wrap;

    }



    .cover-link {

        padding: 10px 18px;

        border-radius: 999px;

        background: rgba(255, 255, 255, 0.15);

        color: #f8fafc;

        text-decoration: none;

        transition: background 0.2s ease, transform 0.2s ease;

    }



    .cover-link:hover {

        background: rgba(255, 255, 255, 0.28);

        transform: translateY(-2px);

    }



    .cover-resource-group, .cover-chapter-group {

        background: rgba(255, 255, 255, 0.08);

        border: 1px solid rgba(255, 255, 255, 0.2);

        border-radius: 18px;

        padding: 20px;

        display: flex;

        flex-direction: column;

        gap: 12px;

    }



    .cover-resource-group h3, .cover-chapter-group h3 {

        margin: 0;

        font-size: 1.4rem;

        color: #f1c40f;

        text-align: left;

    }



    .cover-resource-grid {

        display: grid;

        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));

        gap: 12px;

    }



    .cover-chapter-grid {

        display: grid;

        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));

        gap: 12px;

    }



    .cover-resource, .cover-chapter-grid a {

        display: flex;

        align-items: center;

        padding: 12px 16px;

        border-radius: 12px;

        background: rgba(255, 255, 255, 0.1);

        color: #ecf0f1;

        text-decoration: none;

        line-height: 1.4;

        transition: background 0.2s ease, transform 0.2s ease;

    }



    .cover-resource:hover, .cover-chapter-grid a:hover {

        background: rgba(255, 255, 255, 0.24);

        transform: translateY(-2px);

    }



    @media (max-width: 768px) {

        .cover-button-area {

            padding: 0 12px;

        }

    }



    /* 不同按钮的特殊颜色 */

    .home-btn:hover {

        background: rgba(52, 152, 219, 0.3);

        border-color: rgba(52, 152, 219, 0.6);

    }



    .story-btn:hover {

        background: rgba(155, 89, 182, 0.3);

        border-color: rgba(155, 89, 182, 0.6);

    }



    .exercise-btn:hover {

        background: rgba(46, 204, 113, 0.3);

        border-color: rgba(46, 204, 113, 0.6);

    }



    .resource-btn:hover {

        background: rgba(230, 126, 34, 0.3);

        border-color: rgba(230, 126, 34, 0.6);

    }



    /* 响应式设计 */

    @media (max-width: 768px) {

        .home-nav-buttons {

            gap: 15px;

            margin-top: 30px;

        }

        

        .nav-btn {

            padding: 12px 16px;

            min-width: 100px;

        }

        

        .nav-btn .btn-icon {

            font-size: 1rem;

        }

        

        .nav-btn .btn-text {

            font-size: 1rem;

        }

    }

        .return-home-panel {

            position: fixed;

            top: 16px;

            left: 16px;

            display: flex;

            gap: 10px;

            z-index: 9999;

            flex-wrap: wrap;

        }

        .return-home-panel .return-link {

            padding: 8px 14px;

            border-radius: 999px;

            background: rgba(15, 23, 42, 0.8);

            color: #f8fafc;

            font-size: 14px;

            text-decoration: none;

            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);

            backdrop-filter: blur(8px);

            -webkit-backdrop-filter: blur(8px);

            transition: transform 0.2s ease, box-shadow 0.2s ease;

        }

        .return-home-panel .return-link:hover {

            transform: translateY(-2px);

            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);

        }

        .return-home-panel .return-link.return-main {

            background: rgba(79, 70, 229, 0.85);

        }

        @media (max-width: 640px) {

            .return-home-panel {

                top: 12px;

                left: 12px;

                right: 12px;

                justify-content: center;

            }

            .return-home-panel .return-link {

                width: 100%;

                text-align: center;

            }

        }

        #sticky-vis-container.custom-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            background-image: url('../common-assets/images/black-felt.png');
            padding: 0;
            align-items: stretch;
        }

        .right-panel-content .info-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--chalk-text);
            backdrop-filter: blur(10px);
        }

        .right-panel-content .info-card h4 {
            color: #f39c12;
            border-bottom: 2px solid #f39c12;
        }

        .right-panel-content .button-container button {
            background: rgba(52, 152, 219, 0.8);
            border: 1px solid rgba(52, 152, 219, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .right-panel-content .button-container button:hover {
            background: rgba(52, 152, 219, 1);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }



        /* Lab Menu Button Styles */
        .lab-menu-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 999;
            background: rgba(52, 73, 94, 0.8);
            color: #ecf0f1;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .lab-menu-button:hover {
            background: rgba(52, 73, 94, 1);
            transform: scale(1.1);
        }

        /* Lab Menu Dropdown */
        .lab-menu {
            position: fixed;
            bottom: 90px;
            right: 30px;
            z-index: 998;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            padding: 15px;
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }

        .lab-menu.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .lab-menu h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }

        .lab-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .lab-item {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            text-decoration: none;
            padding: 10px 8px;
            border-radius: 8px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            display: block;
        }

        .lab-item:hover {
            background: linear-gradient(135deg, #2980b9, #3498db);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

    </style>

</head>

<body>
    <!-- Lab Menu Button -->
    <button class="lab-menu-button" onclick="toggleLabMenu()" title="第二章实验室">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 11H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2h-4"/>
            <path d="M9 7V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v3"/>
            <circle cx="12" cy="13" r="1"/>
        </svg>
    </button>

    <!-- Lab Menu Dropdown -->
    <div class="lab-menu" id="labMenu">
        <h3>第二章实验室</h3>
        <div class="lab-grid">
            <a href="../网页资源/lab 2-1.html" class="lab-item" target="_blank">Lab 2-1</a>
            <a href="../网页资源/lab 2-2.html" class="lab-item" target="_blank">Lab 2-2</a>
            <a href="../网页资源/lab 2-3.html" class="lab-item" target="_blank">Lab 2-3</a>
            <a href="../网页资源/lab 2-4.html" class="lab-item" target="_blank">Lab 2-4</a>
            <a href="../网页资源/lab 2-5.html" class="lab-item" target="_blank">Lab 2-5</a>
            <a href="../网页资源/lab 2-6.html" class="lab-item" target="_blank">Lab 2-6</a>
            <a href="../网页资源/lab 2-7.html" class="lab-item" target="_blank">Lab 2-7</a>
            <a href="../网页资源/lab 2-8.html" class="lab-item" target="_blank">Lab 2-8</a>
            <a href="../网页资源/lab 2-9.html" class="lab-item" target="_blank">Lab 2-9</a>
            <a href="../网页资源/lab 2-10.html" class="lab-item" target="_blank">Lab 2-10</a>
            <a href="../网页资源/lab 2-11.html" class="lab-item" target="_blank">Lab 2-11</a>
            <a href="../网页资源/lab 2-12.html" class="lab-item" target="_blank">Lab 2-12</a>
            <a href="../网页资源/lab 2-13.html" class="lab-item" target="_blank">Lab 2-13</a>
        </div>
    </div>



<div class="scrolly-container">

<div class="lecture-notes">

<section class="step" data-animation="intro" id="step-intro">

<div class="chalkboard cover-chalkboard">

<h2 style="font-size: 4rem; border: none;">第二章</h2>

<p style="font-size: 2.5rem; color: white;">极限与连续</p>

<div class="cover-button-area">

    <div class="cover-primary-group">

        <div class="home-nav-buttons">

            <a class="nav-btn home-btn" href="../index.html">

                <span class="btn-icon">HOME</span>

                <span class="btn-text">主页</span>

            </a>

            <a class="nav-btn story-btn" href="../故事书/index.html">

                <span class="btn-icon">STORY</span>

                <span class="btn-text">故事书</span>

            </a>

            <a class="nav-btn exercise-btn" href="../习题/index.html">

                <span class="btn-icon">EXERCISE</span>

                <span class="btn-text">习题</span>

            </a>

            <a class="nav-btn resource-btn" href="../网页资源/index.html">

                <span class="btn-icon">RESOURCE</span>

                <span class="btn-text">网页资源</span>

            </a>

        </div>

    </div>

    <div class="cover-quick-links">

        <a class="cover-link" href="index.html">← 返回目录</a>

        <a class="cover-link" href="../index.html">⌂ 返回主站</a>

    </div>


</div>

</div>

</section>

<div class="right-panel-content" style="display: none;">

    <div class="cover-resource-group">

        <h3>扩展实验室</h3>

        <div class="cover-resource-grid">

            <a class="cover-resource" href="../网页资源/lab 2-1.html" target="_blank">LAB 2-1 图像压缩与数列极限实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-2.html" target="_blank">LAB 2-2 数列极限案例探索实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-3.html" target="_blank">LAB 2-3 函数极限与自变量变化实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-4.html" target="_blank">LAB 2-4 左右极限与存在性判定实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-5.html" target="_blank">LAB 2-5 无穷大与无穷小倒数关系实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-6.html" target="_blank">LAB 2-6 重要极限实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-7.html" target="_blank">LAB 2-7 无穷小比较实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-8.html" target="_blank">LAB 2-8 函数增量实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-9.html" target="_blank">LAB 2-9 等价无穷小倒水游戏</a>

            <a class="cover-resource" href="../网页资源/lab 2-10.html" target="_blank">LAB 2-10 连续与间断游戏</a>

            <a class="cover-resource" href="../网页资源/lab 2-11.html" target="_blank">LAB 2-11 函数连续性实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-12.html" target="_blank">LAB 2-12 函数间断点实验室</a>

            <a class="cover-resource" href="../网页资源/lab 2-13.html" target="_blank">LAB 2-13 极限与连续游戏</a>

            <a class="cover-resource" href="../习题/assets/limit.html" target="_blank">EXER 习题练习</a>

        </div>

    </div>

    <div class="cover-chapter-group">

        <h3>章节直达</h3>

        <div class="cover-chapter-grid">

            <a href="javascript:void(0);" onclick="scrollToStep('why-limit')">1. 为什么要学极限？</a>

            <a href="javascript:void(0);" onclick="scrollToStep('intuitive-limit')">2. 什么是极限？</a>

            <a href="javascript:void(0);" onclick="scrollToStep('convergent-sequences')">3. 数列极限（收敛）</a>

            <a href="javascript:void(0);" onclick="scrollToStep('divergent-sequences')">4. 数列极限（发散）</a>

            <a href="javascript:void(0);" onclick="scrollToStep('sequence-calculation')">5. 数列极限的计算方法</a>

            <a href="javascript:void(0);" onclick="scrollToStep('function-limits')">6. 函数的极限</a>

            <a href="javascript:void(0);" onclick="scrollToStep('one-sided-limits')">7. 左极限与右极限</a>

            <a href="javascript:void(0);" onclick="scrollToStep('one-sided-detailed')">8. 左右极限详细演示</a>

            <a href="javascript:void(0);" onclick="scrollToStep('limit-operations')">9. 极限的四则运算法则</a>

            <a href="javascript:void(0);" onclick="scrollToStep('limit-methods-detailed')">10. 极限运算方法</a>

            <a href="javascript:void(0);" onclick="scrollToStep('limit-methods')">11. 极限计算技巧</a>

            <a href="javascript:void(0);" onclick="scrollToStep('important-limit-1')">12. 第一重要极限</a>

            <a href="javascript:void(0);" onclick="scrollToStep('important-limit-2')">13. 第二重要极限</a>

            <a href="javascript:void(0);" onclick="scrollToStep('important-limits-detailed')">14. 两个重要极限</a>

            <a href="javascript:void(0);" onclick="scrollToStep('infinitesimal-infinity')">15. 无穷小与无穷大</a>

            <a href="javascript:void(0);" onclick="scrollToStep('infinitesimal-comparison')">16. 无穷小的比较</a>

            <a href="javascript:void(0);" onclick="scrollToStep('equivalent-infinitesimal')">17. 常用等价无穷小</a>

            <a href="javascript:void(0);" onclick="scrollToStep('equivalent-infinitesimal-app')">18. 等价无穷小应用技巧</a>

            <a href="javascript:void(0);" onclick="scrollToStep('continuous-functions')">19. 函数的连续性</a>

            <a href="javascript:void(0);" onclick="scrollToStep('discontinuities')">20. 间断点的分类</a>

            <a href="javascript:void(0);" onclick="scrollToStep('elementary-functions')">21. 初等函数的连续性</a>

            <a href="javascript:void(0);" onclick="scrollToStep('continuity-determination')">22. 连续性的判定与应用</a>

            <a href="javascript:void(0);" onclick="scrollToStep('applications')">23. 极限的实际应用</a>

            <a href="javascript:void(0);" onclick="scrollToStep('summary')">24. 章节总结</a>

        </div>

    </div>

</div>

<section class="step" data-animation="toc" id="step-toc"><!-- 目录页 -->

<div class="chalkboard toc-board">

<div class="toc-header">目录</div>

<div class="toc-grid">

<div class="toc-item">

<h3>1. 极限概念</h3>

<div class="toc-list">

<div>• 极限的直观理解</div>

<div>• 数列极限</div>

<div>• 函数极限</div>

<div>• 左右极限</div>

<div></div>

<div></div>

</div>

</div>

<div class="toc-item">

<h3>2. 极限计算</h3>

<div class="toc-list">

<div>• 四则运算法则</div>

<div>• 直接代入法</div>

<div>• 因式分解法</div>

<div>• 有理化方法</div>

<div>• 计算技巧</div>

<div></div>

</div>

</div>

<div class="toc-item">

<h3>3. 两个重要极限</h3>

<div class="toc-list">

<div>• 第一重要极限</div>

<div>• 第二重要极限</div>

<div>• 重要极限应用</div>

<div>• 极限变形技巧</div>

<div></div>

<div></div>

</div>

</div>


</div>

</div>

</section>

<div class="right-panel-content" style="display: none;">

    <div class="toc-item">

        <h3>4. 无穷小的比较</h3>

        <div class="toc-list">

            <div>• 无穷小定义</div>

            <div>• 无穷大定义</div>

            <div>• 无穷小比较</div>

            <div>• 等价无穷小</div>

            <div>• 等价替换应用</div>

            <div></div>

        </div>

    </div>

    <div class="toc-item">

        <h3>5. 连续性与间断点</h3>

        <div class="toc-list">

            <div>• 连续的定义</div>

            <div>• 间断点分类</div>

            <div>• 初等函数连续性</div>

            <div>• 连续性判定</div>

            <div>• 连续性的应用</div>

            <div></div>

        </div>

    </div>

    <div class="toc-item">

        <h3>6. 章节总结</h3>

        <div class="toc-list">

            <div>• 核心概念回顾</div>

            <div>• 重要公式总结</div>

            <div>• 解题方法归纳</div>

            <div>• 下章预告</div>

            <div></div>

            <div></div>

        </div>

    </div>

</div>

<section class="step" data-animation="why-limit" id="step-why-limit"><!-- 第1页：引言 - 为什么要学极限 -->

<div class="chalkboard">

<h2>为什么要学极限？</h2>

<h3>古代难题</h3>

<p>古希腊哲学家芝诺提出：<span class="highlight">阿基里斯追龟悖论</span></p>

<p>跑得快的阿基里斯永远追不上前面的乌龟？因为当他跑到乌龟原来的位置时，乌龟又向前爬了一段...</p>

<h3>现实问题</h3>

<ul>

<li><strong>瞬时速度</strong>：汽车速度表显示的是瞬间速度，怎么算？</li>

<li><strong>曲线切线</strong>：GPS导航的转弯提示需要计算道路切线</li>

<li><strong>经济决策</strong>：当产量增加一个单位时，成本增加多少？</li>

<li><strong>图像压缩</strong>：JPEG如何用有限数据逼近原始图像？</li>

</ul>

<div class="warning-box">

<p><strong>核心矛盾：</strong>我们想知道"瞬间"的变化率，但"瞬间"意味着时间为0，而0不能做分母！</p>

<p>极限就是解决这个矛盾的<span class="highlight">数学工具</span>。</p>

</div>

</div>

</section>

<section class="step" data-animation="intuitive-limit" id="step-intuitive-limit"><!-- 第2页：什么是极限 - 直观理解 -->

<div class="chalkboard">

<h2>什么是极限？</h2>

<h3>核心思想</h3>

<p>极限描述的是一个<span class="highlight">变化过程的趋势</span>，而不是最终结果。</p>

<div class="example-box">

<h4>生活例子1：往杯子里倒水</h4>

<p>假设杯子容量是1升，你每次倒入剩余空间的一半：</p>

<ul>

<li>第1次：倒入0.5升（杯中0.5升）</li>

<li>第2次：倒入0.25升（杯中0.75升）</li>

<li>第3次：倒入0.125升（杯中0.875升）</li>

</ul>

<p>永远倒不满，但<span class="highlight">无限接近1升</span>！</p>

</div>

<!-- 新增更贴近生活的例子 -->

<div class="example-box" style="background: rgba(155, 89, 182, 0.1);">

<h4>生活例子2：手机电量</h4>

<p>手机显示"1%电量"，但永远用不完？</p>

<p>实际上是 1.4% → 1.1% → 1.01% → ...</p>

<p><span class="highlight">无限接近0，但还没到0</span></p>

</div>

<div class="example-box" style="background: rgba(230, 126, 34, 0.1);">

<h4>生活例子3：和朋友约见面</h4>

<p>"马上到" → "5分钟" → "2分钟" → "楼下了"</p>

<p>时间间隔越来越小，<span class="highlight">趋向于见面那一刻</span></p>

</div>

<div class="warning-box">

<p><strong>记住：</strong></p>

<p>极限 = "越来越接近" 而不是 "到达"</p>

<p>就像追女朋友，过程比结果重要！😊</p>

</div>

<div class="math-formula">

                总量 = 0.5 + 0.25 + 0.125 + ... → 1

            </div>

<p><strong>关键理解：</strong>极限不是"到达"，而是"趋向"！</p>

</div>

</section>

<section class="step" data-animation="convergent-sequences" id="step-convergent-sequences"><!-- 第3页：数列极限 - 收敛数列 -->

<div class="chalkboard">

<h2>数列极限（收敛）</h2>

<h3>什么是数列？</h3>

<p>按一定规律排列的一串数：$a_1, a_2, a_3, ..., a_n, ...$</p>

<h3>收敛数列</h3>

<p>当项数 $n$ 无限增大时，$a_n$ 无限接近某个确定的数 $A$。</p>

<div class="math-formula">

                $\lim\limits_{n \to \infty} a_n = A$

            </div>

<div class="example-box">

<h4>典型收敛模式</h4>

<ul>

<li>指数衰减：越来越快地接近极限</li>

<li>交替收敛：正负交替但幅度递减</li>

<li>调和收敛：缓慢但稳定地接近</li>

<li>振荡收敛：波动中趋向极限</li>

</ul>

</div>

<p>观察右侧15种不同的收敛模式，体会收敛的多样性。</p>

</div>

</section>

<section class="step" data-animation="divergent-sequences" id="step-divergent-sequences"><!-- 第4页：数列极限 - 发散数列 -->

<div class="chalkboard">

<h2>数列极限（发散）</h2>

<h3>发散数列的特征</h3>

<p>数列的项不趋向于任何固定值。</p>

<div class="example-box">

<h4>发散的类型</h4>

<ul>

<li><strong>趋向无穷：</strong>$a_n = n$ → $+\infty$</li>

<li><strong>振荡发散：</strong>$a_n = (-1)^n \cdot n$</li>

<li><strong>周期振荡：</strong>$a_n = (-1)^n$</li>

<li><strong>混沌发散：</strong>无规律的变化</li>

</ul>

</div>

<div class="warning-box">

<p><strong>判断技巧：</strong></p>

<p>• 如果能找到极限值 → 收敛</p>

<p>• 如果无限增大/减小 → 发散</p>

<p>• 如果持续振荡 → 发散</p>

</div>

</div>

</section>

<section class="step" data-animation="sequence-calculation" id="step-sequence-calculation"><!-- 第5页：数列极限的计算 -->

<div class="chalkboard">

<h2>数列极限的计算方法</h2>

<h3>基本方法</h3>

<div class="example-box">

<h4>方法1：直接代入法</h4>

<p>$\lim\limits_{n \to \infty} \frac{1}{n^2} = \frac{1}{\infty} = 0$</p>

<p>（无穷大的倒数是0）</p>

</div>

<div class="example-box">

<h4>方法2：分子分母同除最高次</h4>

<p>求：$\lim\limits_{n \to \infty} \frac{2n^2 + 3n + 1}{n^2 + 5}$</p>

<div class="step-box">

<p>步骤1：分子分母同除以 $n^2$</p>

<p>$= \lim\limits_{n \to \infty} \frac{2 + \frac{3}{n} + \frac{1}{n^2}}{1 + \frac{5}{n^2}}$</p>

<p>步骤2：当 $n \to \infty$ 时，$\frac{1}{n} \to 0$</p>

<p>$= \frac{2 + 0 + 0}{1 + 0} = 2$</p>

</div>

</div>

<h3>记住规律</h3>

<ul>

<li>分子次数 &gt; 分母次数 → 极限为 ∞</li>

<li>分子次数 = 分母次数 → 极限为系数比</li>

<li>分子次数 &lt; 分母次数 → 极限为 0</li>

</ul>

</div>

</section>

<section class="step" data-animation="function-limits" id="step-function-limits"><!-- 第6页：函数极限 -->

<div class="chalkboard">

<h2>函数的极限</h2>

<h3>两种基本情况</h3>

<div class="example-box">

<h4>情况1：$x$ 趋向于某个数</h4>

<p>$\lim\limits_{x \to a} f(x) = L$</p>

<p>意义：当 $x$ 无限接近 $a$ 时，$f(x)$ 无限接近 $L$</p>

</div>

<div class="example-box">

<h4>情况2：$x$ 趋向于无穷</h4>

<p>$\lim\limits_{x \to \infty} f(x) = L$</p>

<p>意义：当 $x$ 无限增大时，$f(x)$ 无限接近 $L$</p>

</div>

<div class="math-formula">

                $\lim\limits_{x \to a} f(x) = L$ 的含义：<br/>

                对任意小的 $\varepsilon &gt; 0$，存在 $\delta &gt; 0$，<br/>

                当 $0 &lt; |x - a| &lt; \delta$ 时，$|f(x) - L| &lt; \varepsilon$

            </div>

<p><strong>关键：</strong>$x$ 可以从任意方向接近目标值！</p>

</div>

</section>

<section class="step" data-animation="one-sided-limits" id="step-one-sided-limits"><!-- 第7页：左右极限 -->

<div class="chalkboard">

<h2>左极限与右极限</h2>

<h3>为什么要分左右？</h3>

<p>有些函数在某点处从不同方向接近会得到<span class="highlight">不同的值</span>。</p>

<div class="example-box">

<h4>左极限</h4>

<p>$\lim\limits_{x \to a^-} f(x) = L_1$</p>

<p>从左侧（小于$a$的方向）接近</p>

</div>

<div class="example-box">

<h4>右极限</h4>

<p>$\lim\limits_{x \to a^+} f(x) = L_2$</p>

<p>从右侧（大于$a$的方向）接近</p>

</div>

<div class="warning-box">

<p><strong>极限存在的条件：</strong></p>

<p>$\lim\limits_{x \to a} f(x)$ 存在 ⟺ $\lim\limits_{x \to a^-} f(x) = \lim\limits_{x \to a^+} f(x)$</p>

<p>左极限 = 右极限 = 共同值</p>

</div>

<p><strong>记忆口诀：</strong>左右相等极限在，左右不等无极限。</p>

</div>

</section>

<section class="step" data-animation="one-sided-detailed" id="step-one-sided-detailed"><!-- 第7.1页：左右极限详细演示 -->

<div class="chalkboard">

<h2>左右极限详细演示</h2>

<p>单侧极限的各种情况：</p>

<ul>

<li>相等（极限存在）</li>

<li>不相等（跳跃）</li>

<li>一侧不存在</li>

<li>振荡间断</li>

<li>可去间断</li>

</ul>

</div>

</section>

<section class="step" data-animation="limit-operations" id="step-limit-operations"><!-- 第8页：极限的四则运算 -->

<div class="chalkboard">

<h2>极限的四则运算法则</h2>

<h3>基本法则</h3>

<p>若 $\lim f(x) = A$，$\lim g(x) = B$，则：</p>

<div class="math-formula">

<p>加法：$\lim [f(x) + g(x)] = A + B$</p>

<p>减法：$\lim [f(x) - g(x)] = A - B$</p>

<p>乘法：$\lim [f(x) \cdot g(x)] = A \cdot B$</p>

<p>除法：$\lim \frac{f(x)}{g(x)} = \frac{A}{B}$ （$B \neq 0$）</p>

</div>

<div class="example-box">

<h4>推论</h4>

<ul>

<li>常数倍：$\lim [c \cdot f(x)] = c \cdot A$</li>

<li>幂运算：$\lim [f(x)]^n = A^n$</li>

<li>根运算：$\lim \sqrt[n]{f(x)} = \sqrt[n]{A}$（$A &gt; 0$）</li>

</ul>

</div>

<p><strong>注意：</strong>只有当各部分极限都存在时，法则才能用！</p>

</div>

</section>

<section class="step" data-animation="limit-methods-detailed" id="step-limit-methods-detailed"><!-- 第8.1页：极限运算方法 -->

<div class="chalkboard">

<h2>极限运算方法</h2>

<p><strong>直接代入法</strong>：连续点处直接代入</p>

<p><strong>因式分解法</strong>：约去零因子</p>

<p><strong>根式有理化</strong>：分子分母有理化</p>

<p><strong>无穷大比较法</strong>：比较最高次项</p>

<p><strong>等价无穷小替换</strong>：乘除关系中替换</p>

<p>展示12种常用的极限计算技巧</p>



<div class="example-box">

<h4>思路梳理</h4>

<p>遇到极限题目时先判断函数是否连续，如果连续可以直接代入；若出现未定式，再按类型选择因式分解、有理化或等价无穷小等工具。</p>

<p>对于无穷大的情形，鼓励学生优先比较最高次项，并在必要时结合变量替换，将复杂表达式拆成熟悉的基础模型。</p>

</div>

<div class="warning-box">

<p><strong>课堂提示：</strong>计算过程中要写明关键极限结论，例如 $

rac{1}{n} 	o 0$ 或 $\sin u \sim u$，这样既巩固知识点，也让推理更完整。</p>

</div>

</div>

</section>

<section class="step" data-animation="limit-methods" id="step-limit-methods"><!-- 第9页：极限计算技巧 -->

<div class="chalkboard">

<h2>极限计算技巧</h2>

<h3>0/0型未定式</h3>

<p>直接代入得到0/0时，需要化简！</p>

<div class="example-box">

<h4>方法1：因式分解</h4>

<p>$\lim\limits_{x \to 1} \frac{x^2 - 1}{x - 1} = \lim\limits_{x \to 1} \frac{(x+1)(x-1)}{x-1} = 2$</p>

</div>

<div class="example-box">

<h4>方法2：有理化</h4>

<p>$\lim\limits_{x \to 0} \frac{\sqrt{x+1} - 1}{x}$ </p>

<p>分子分母同乘 $\sqrt{x+1} + 1$ 后得 $\frac{1}{2}$</p>

</div>

<h3>∞/∞型未定式</h3>

<div class="example-box">

<h4>方法：除以最高次</h4>

<p>$\lim\limits_{x \to \infty} \frac{3x^2 + 2x}{x^2 - 5} = \lim\limits_{x \to \infty} \frac{3 + \frac{2}{x}}{1 - \frac{5}{x^2}} = 3$</p>

</div>

<p><strong>记住：</strong>遇到0/0要化简，遇到∞/∞看最高次！</p>

</div>

</section>

<section class="step" data-animation="important-limit-1" id="step-important-limit-1"><!-- 第10页：第一重要极限 -->

<div class="chalkboard">

<h2>第一重要极限</h2>

<div class="math-formula">

                $\lim\limits_{x \to 0} \frac{\sin x}{x} = 1$

            </div>

<h3>几何理解</h3>

<p>在单位圆中，当角度很小时：</p>

<p>弧长 ≈ 弦长 ≈ 正切线长</p>

<p>即：$x ≈ \sin x ≈ \tan x$ （$x$很小时）</p>

<h3>推广形式</h3>

<p>若 $f(x) \to 0$，则：</p>

<div class="math-formula">

                $\lim\limits_{f(x) \to 0} \frac{\sin f(x)}{f(x)} = 1$

            </div>

<div class="example-box">

<h4>应用例子</h4>

<p>$\lim\limits_{x \to 0} \frac{\sin 3x}{x} = \lim\limits_{x \to 0} \frac{\sin 3x}{3x} \cdot 3 = 1 \cdot 3 = 3$</p>

</div>

<p><strong>技巧：</strong>凑出标准形式，然后应用重要极限。</p>

</div>

</section>

<section class="step" data-animation="important-limit-2" id="step-important-limit-2"><!-- 第11页：第二重要极限 -->

<div class="chalkboard">

<h2>第二重要极限</h2>

<div class="math-formula">

                $\lim\limits_{x \to \infty} \left(1 + \frac{1}{x}\right)^x = e \approx 2.718$

            </div>

<h3>自然常数 $e$ 的意义</h3>

<p>这是<span class="highlight">自然常数e</span>的定义，在复利、人口增长、放射性衰变等问题中广泛应用。</p>

<h3>推广形式</h3>

<p>若 $f(x) \to \infty$，则：</p>

<div class="math-formula">

                $\lim\limits_{f(x) \to \infty} \left(1 + \frac{1}{f(x)}\right)^{f(x)} = e$

            </div>

<div class="example-box">

<h4>变形应用</h4>

<p>$\lim\limits_{x \to \infty} \left(1 + \frac{2}{x}\right)^x = \lim\limits_{x \to \infty} \left[\left(1 + \frac{1}{x/2}\right)^{x/2}\right]^2 = e^2$</p>

</div>

<p><strong>意义：</strong>描述了连续复利的极限情况。</p>

</div>

</section>

<section class="step" data-animation="important-limits-detailed" id="step-important-limits-detailed"><!-- 第11.1页：两个重要极限 -->

<div class="chalkboard">

<h2>两个重要极限</h2>

<p><strong>重要极限 I：</strong> $\lim\limits_{x \to 0} \frac{\sin x}{x} = 1$</p>

<p><strong>重要极限 II：</strong> $\lim\limits_{x \to \infty} \left(1+\frac{1}{x}\right)^x = e$</p>

<p>展示各种变形和应用</p>



<div class="example-box">

<h4>教学补充</h4>

<p>第一重要极限强调弧长与正弦在小角度时的互相逼近，适合处理 $0/0$ 型三角极限；第二重要极限则刻画指数底数趋近 1 时的增长，是连续复利与指数模型的核心。</p>

<p>引导学生识别“凑成 $\sin u / u$”和“指数底数接近 1”这类信号，可以帮助他们在复杂题目中快速选用合适的标准模型。</p>

</div>

<div class="warning-box">

<p><strong>对比思考：</strong>前者关注变量趋于 0 的几何直观，后者关注变量趋于无穷时的指数逼近；课堂上可安排一题多解，强化二者的联系与差异。</p>

</div>

</div>

</section>

<section class="step" data-animation="infinitesimal-infinity" id="step-infinitesimal-infinity"><!-- 第12页：无穷小与无穷大 -->

<div class="chalkboard">

<h2>无穷小与无穷大</h2>

<h3>无穷小量</h3>

<p>极限为0的变量叫<span class="highlight">无穷小</span>。</p>

<div class="example-box">

<h4>性质</h4>

<ul>

<li>有限个无穷小的和仍是无穷小</li>

<li>有限个无穷小的积仍是无穷小</li>

<li>有界函数与无穷小的积是无穷小</li>

</ul>

</div>

<h3>无穷大量</h3>

<p>极限为无穷的变量叫<span class="highlight">无穷大</span>。</p>

<div class="warning-box">

<p><strong>重要关系：</strong></p>

<p>在同一过程中，无穷大与无穷小（≠0）互为倒数：</p>

<p>若 $\lim f(x) = 0$（$f(x) \neq 0$），则 $\lim \frac{1}{f(x)} = \infty$</p>

</div>

<p><strong>注意：</strong>无穷小是变量，不是很小的数！</p>

</div>

</section>

<section class="step" data-animation="infinitesimal-comparison" id="step-infinitesimal-comparison"><!-- 第13页：无穷小的比较 -->

<div class="chalkboard">

<h2>无穷小的比较</h2>

<!-- 新增：速度对比表 -->

<div class="example-box">

<h4>趋向0的速度比赛（x→0时）</h4>

<table style="width: 100%; text-align: center;">

<tr style="background: rgba(255,255,255,0.1);">

<th>函数</th>

<th>x=0.1</th>

<th>x=0.01</th>

<th>x=0.001</th>

<th>速度</th>

</tr>

<tr>

<td>x</td>

<td>0.1</td>

<td>0.01</td>

<td>0.001</td>

<td>🐢 慢</td>

</tr>

<tr>

<td>x²</td>

<td>0.01</td>

<td>0.0001</td>

<td>0.000001</td>

<td>🐰 快</td>

</tr>

<tr>

<td>x³</td>

<td>0.001</td>

<td>0.000001</td>

<td>0.000000001</td>

<td>🚀 超快</td>

</tr>

</table>

<p style="margin-top: 10px;">

<span class="highlight">结论：次数越高，趋向0越快！</span>

</p>

</div>

<h3>阶的概念</h3>

<p>设 $\alpha$、$\beta$ 都是无穷小，且 $\alpha \neq 0$：</p>

<div class="math-formula">

<p>若 $\lim \frac{\beta}{\alpha} = 0$ → $\beta$ 是 $\alpha$ 的高阶无穷小</p>

<p>若 $\lim \frac{\beta}{\alpha} = \infty$ → $\beta$ 是 $\alpha$ 的低阶无穷小</p>

<p>若 $\lim \frac{\beta}{\alpha} = k \neq 0$ → $\beta$ 与 $\alpha$ 同阶</p>

<p>若 $\lim \frac{\beta}{\alpha} = 1$ → $\beta$ 与 $\alpha$ 等价，记作 $\alpha \sim \beta$</p>

</div>

<h3>意义</h3>

<p>比较不同无穷小趋于0的"速度"：</p>

<ul>

<li>$x^2$ 比 $x$ 更快趋于0（高阶）</li>

<li>$\sin x$ 与 $x$ 以相同速度趋于0（等价）</li>

</ul>

</div>

</section>

<section class="step" data-animation="equivalent-infinitesimal" id="step-equivalent-infinitesimal"><!-- 第14页：等价无穷小 -->

<div class="chalkboard">

<h2>常用等价无穷小</h2>

<p>当 $x \to 0$ 时：</p>

<div class="math-formula">

<p>$\sin x \sim x$，$\tan x \sim x$</p>

<p>$\arcsin x \sim x$，$\arctan x \sim x$</p>

<p>$1 - \cos x \sim \frac{x^2}{2}$</p>

<p>$e^x - 1 \sim x$，$\ln(1+x) \sim x$</p>

<p>$(1+x)^a - 1 \sim ax$</p>

</div>

<div class="warning-box">

<p><strong>替换规则：</strong></p>

<p>✓ 乘除关系中可以替换</p>

<p>✗ 加减关系中不能直接替换</p>

</div>

<div class="example-box">

<h4>应用例子</h4>

<p>$\lim\limits_{x \to 0} \frac{\sin x \cdot \tan x}{x^2} = \lim\limits_{x \to 0} \frac{x \cdot x}{x^2} = 1$</p>

</div>

</div>

</section>

<section class="step" data-animation="equivalent-infinitesimal-app" id="step-equivalent-infinitesimal-app"><!-- 第15页：等价无穷小应用 -->

<div class="chalkboard">

<h2>等价无穷小应用技巧</h2>

<h3>正确使用方法</h3>

<div class="example-box">

<h4>✓ 正确：乘除中替换</h4>

<p>$\lim\limits_{x \to 0} \frac{\sin 3x \cdot \tan 2x}{x^2} = \lim\limits_{x \to 0} \frac{3x \cdot 2x}{x^2} = 6$</p>

</div>

<div class="warning-box">

<h4>✗ 错误：加减中直接替换</h4>

<p>$\lim\limits_{x \to 0} \frac{\sin x - \tan x}{x^3}$ 不能替换为 $\frac{x - x}{x^3} = 0$</p>

<p>正确做法：先化简再替换</p>

</div>

<h3>处理加减的技巧</h3>

<ul>

<li>先通分或因式分解</li>

<li>转化为乘除形式</li>

<li>使用泰勒展开（高级方法）</li>

</ul>

<p><strong>记住：</strong>等价无穷小替换能大大简化计算！</p>

</div>

</section>

<section class="step" data-animation="continuous-functions" id="step-continuous-functions"><!-- 第16页：函数的连续性 -->

<div class="chalkboard">

<h2>函数的连续性</h2>

<h3>连续的直观理解</h3>

<p>函数图像<span class="highlight">不断开</span>，可以一笔画出来。</p>

<h3>连续的三个条件</h3>

<div class="step-box">

<p><strong>条件1：</strong>$f(x_0)$ 有定义（点存在）</p>

<p><strong>条件2：</strong>$\lim\limits_{x \to x_0} f(x)$ 存在（极限存在）</p>

<p><strong>条件3：</strong>$\lim\limits_{x \to x_0} f(x) = f(x_0)$（极限等于函数值）</p>

</div>

<div class="math-formula">

                函数在 $x_0$ 处连续 ⟺ $\lim\limits_{x \to x_0} f(x) = f(x_0)$

            </div>

<h3>单侧连续</h3>

<ul>

<li>左连续：$\lim\limits_{x \to x_0^-} f(x) = f(x_0)$</li>

<li>右连续：$\lim\limits_{x \to x_0^+} f(x) = f(x_0)$</li>

</ul>

<p><strong>意义：</strong>连续函数便于研究，许多定理只对连续函数成立。</p>

</div>

</section>

<section class="step" data-animation="discontinuities" id="step-discontinuities"><!-- 第17页：间断点分类 -->

<div class="chalkboard">

<h2>间断点的分类</h2>

<h3>第一类间断点（左右极限都存在）</h3>

<div class="example-box">

<h4>1. 可去间断点</h4>

<p>左极限 = 右极限 ≠ 函数值（或无定义）</p>

<p>例：$f(x) = \frac{\sin x}{x}$ 在 $x=0$ 处</p>

<p><span class="highlight">可以通过补充定义"去掉"间断</span></p>

</div>

<div class="example-box">

<h4>2. 跳跃间断点</h4>

<p>左极限 ≠ 右极限</p>

<p>例：符号函数 $\text{sgn}(x)$ 在 $x=0$ 处</p>

<p><span class="highlight">无法通过补充定义消除</span></p>

</div>

<h3>第二类间断点（至少一侧极限不存在）</h3>

<div class="example-box">

<h4>无穷间断点</h4>

<p>例：$f(x) = \frac{1}{x}$ 在 $x=0$ 处</p>

</div>

<div class="example-box">

<h4>振荡间断点</h4>

<p>例：$f(x) = \sin\frac{1}{x}$ 在 $x=0$ 处</p>

</div>

</div>

</section>

<section class="step" data-animation="elementary-functions" id="step-elementary-functions"><!-- 第18页：初等函数的连续性 -->

<div class="chalkboard">

<h2>初等函数的连续性</h2>

<h3>基本初等函数</h3>

<p>在其定义域内都是连续的：</p>

<div class="math-formula">

<p>• 常数函数：$f(x) = c$</p>

<p>• 幂函数：$f(x) = x^n$</p>

<p>• 指数函数：$f(x) = a^x$ ($a &gt; 0, a \neq 1$)</p>

<p>• 对数函数：$f(x) = \log_a x$ ($a &gt; 0, a \neq 1$)</p>

<p>• 三角函数：$\sin x, \cos x, \tan x$ 等</p>

<p>• 反三角函数：$\arcsin x, \arccos x$ 等</p>

</div>

<h3>复合运算的连续性</h3>

<p>连续函数经过以下运算仍连续：</p>

<ul>

<li>四则运算（除法要求分母不为0）</li>

<li>复合运算</li>

<li>反函数（单调连续函数）</li>

</ul>

<p><strong>结论：</strong>初等函数在其定义域内处处连续！</p>

</div>

</section>

<section class="step" data-animation="continuity-determination" id="step-continuity-determination"><!-- 第19页：连续性判定与应用 -->

<div class="chalkboard">

<h2>连续性的判定与应用</h2>

<h3>判定步骤</h3>

<div class="step-box">

<p>1. 检查函数是否有定义</p>

<p>2. 计算左极限 $\lim\limits_{x \to x_0^-} f(x)$</p>

<p>3. 计算右极限 $\lim\limits_{x \to x_0^+} f(x)$</p>

<p>4. 比较：左极限 = 右极限 = 函数值？</p>

</div>

<h3>连续函数的性质</h3>

<div class="example-box">

<h4>零点定理</h4>

<p>若 $f(x)$ 在 $[a,b]$ 连续，$f(a) \cdot f(b) &lt; 0$</p>

<p>则存在 $c \in (a,b)$ 使 $f(c) = 0$</p>

</div>

<div class="example-box">

<h4>最值定理</h4>

<p>连续函数在闭区间上必有最大值和最小值</p>

</div>

<div class="example-box">

<h4>介值定理</h4>

<p>连续函数取遍最值之间的所有值</p>

</div>

</div>

</section>

<section class="step" data-animation="applications" id="step-applications"><!-- 第20页：极限在实际中的应用 -->

<div class="chalkboard">

<h2>极限的实际应用</h2>

<h3>1. 瞬时速度</h3>

<div class="example-box">

<h4>问题：汽车t秒时的瞬时速度</h4>

<p>位置函数：$s(t) = 5t^2$（米）</p>

<p>瞬时速度 = $\lim\limits_{h \to 0} \frac{s(t+h) - s(t)}{h} = 10t$ m/s</p>

</div>

<h3>2. 边际成本</h3>

<div class="example-box">

<h4>成本函数：$C(x) = 100 + 2x + 0.01x^2$</h4>

<p>边际成本 = $\lim\limits_{h \to 0} \frac{C(x+h) - C(x)}{h} = 2 + 0.02x$</p>

</div>

<h3>3. 图像压缩（JPEG）</h3>

<div class="example-box">

<h4>渐进式压缩</h4>

<p>图像序列 $\{P_n\}$ 逐步逼近原图 $P_{原始}$</p>

<p>误差序列：$\{d_n\} \to 0$ (当 $n \to \infty$)</p>

</div>

<p><strong>本质：</strong>极限让我们能计算<span class="highlight">瞬间的变化率</span>！</p>

</div>

</section>

<section class="step" data-animation="summary" id="step-summary"><!-- 第21页：章节总结 -->

<div class="chalkboard">

<h2>章节总结</h2>

<h3>核心概念网络</h3>

<div class="step-box">

<p><strong>极限</strong> → 描述变化趋势</p>

<p>├─ <strong>数列极限</strong> → $n \to \infty$</p>

<p>├─ <strong>函数极限</strong> → $x \to a$ 或 $x \to \infty$</p>

<p>│   ├─ 左极限、右极限</p>

<p>│   └─ 极限存在条件</p>

<p>├─ <strong>重要极限</strong> → $\frac{\sin x}{x}$、$(1+\frac{1}{x})^x$</p>

<p>├─ <strong>无穷小</strong> → 极限为0</p>

<p>│   └─ 等价无穷小替换</p>

<p>└─ <strong>连续性</strong> → 极限=函数值</p>

<p>    └─ 间断点分类</p>

</div>

<h3>学习要点</h3>

<ul>

<li>极限是<span class="highlight">趋势</span>，不是结果</li>

<li>计算极限要先判断<span class="highlight">类型</span></li>

<li>0/0型要<span class="highlight">化简</span></li>

<li>∞/∞型看<span class="highlight">最高次</span></li>

<li>等价无穷小可<span class="highlight">替换</span></li>

</ul>

<div class="warning-box">

<p><strong>下一步：</strong>极限是导数的基础，导数是微分的核心！</p>

</div>

</div>

</section>

</div>

<div class="visualization-panel">

<div class="visualization-flex" id="sticky-vis-container"></div>

</div>

</div>

<script>

    // ============ 全局变量和初始化 ============

    let currentAnimations = [];

    let globalAnimationSpeed = 1.0;



    // MathJax重新渲染

    const renderMathJax = async (container) => {

        if (window.MathJax && window.MathJax.typesetPromise) {

            try {

                await window.MathJax.typesetPromise([container]);

            } catch (error) {

                console.warn('MathJax rendering failed:', error);

            }

        }

    };



    // 幻灯片控制

    function cleanupAnimations() {

        currentAnimations.forEach(cleanup => {

            if (typeof cleanup === 'function') {

                cleanup();

            }

        });

        currentAnimations = [];

    }



    function getContainer(containerId, mode = 'flex') {

        let element = document.getElementById(containerId);

        if (!element) {

            if (containerId === 'sticky-vis-container') {

                console.error(`Container ${containerId} not found`);

                return null;

            }



            const activeStep = document.querySelector('.step.is-active');

            if (activeStep) {

                let fullscreenHost = activeStep.querySelector('.fullscreen-vis-container');

                if (!fullscreenHost) {

                    fullscreenHost = document.createElement('div');

                    fullscreenHost.className = 'fullscreen-vis-container';

                    activeStep.appendChild(fullscreenHost);

                } else {

                    fullscreenHost.innerHTML = '';

                }

                element = document.createElement('div');

                element.id = containerId;

                fullscreenHost.appendChild(element);

            } else {

                console.warn(`Container ${containerId} missing; creating fallback container.`);

                const panel = document.querySelector('.visualization-panel');

                if (!panel) {

                    return null;

                }

                element = document.createElement('div');

                element.id = containerId;

                panel.appendChild(element);

            }

        } else {

            element.innerHTML = '';

        }



        element.classList.remove('visualization-grid', 'visualization-flex');

        if (mode === 'grid') {

            element.classList.add('visualization-grid');

        } else {

            element.classList.add('visualization-flex');

        }

        return element;

    }



    // ============ D3.js 辅助函数 ============

    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 60, left: 60}) {

        let containerElement = document.getElementById(containerId);

        if (!containerElement) {

            containerElement = getContainer(containerId, 'flex');

            if (!containerElement) {

                console.error(`Container ${containerId} not found`);

                return null;

            }

        } else {

            containerElement.innerHTML = '';

            containerElement.classList.remove('visualization-grid');

            containerElement.classList.add('visualization-flex');

        }



        const container = d3.select(containerElement);

        const bounds = containerElement.getBoundingClientRect();

        

        const svg = container.append('svg')

            .attr('width', bounds.width)

            .attr('height', bounds.height);

            

        const width = bounds.width - margins.left - margins.right;

        const height = bounds.height - margins.top - margins.bottom;

        

        const g = svg.append('g')

            .attr('transform', `translate(${margins.left}, ${margins.top})`);

        

        // 添加箭头标记

        svg.append('defs').append('marker')

            .attr('id', 'arrowhead')

            .attr('viewBox', '0 -5 10 10')

            .attr('refX', 8)

            .attr('refY', 0)

            .attr('markerWidth', 8)

            .attr('markerHeight', 8)

            .attr('orient', 'auto')

            .append('path')

            .attr('d', 'M0,-5L10,0L0,5')

            .attr('fill', 'var(--danger-color)');

            

        return { container, svg, g, width, height };

    }



    // 通用可视化设置函数

    const setup = (container, index, title, approachDirection = 'both', approachValue = 'a') => {

        if (container && container.classList) {

            container.classList.remove('visualization-flex');

            container.classList.add('visualization-grid');

        }



        function parseVisTitle(title) {

            let formula = '', chinese = '';

            let t = title.trim();

            let brMatch = t.match(/^(.*?)(?:<br\s*\/?>)(.*)$/i);

            if (brMatch) {

                let part1 = brMatch[1].trim();

                let part2 = brMatch[2].trim();

                if (/^\$|\\|[a-zA-Z0-9_{}^]/.test(part2)) {

                    if (/[\u4e00-\u9fa5]/.test(part1)) {

                        chinese = part1;

                        formula = part2;

                    } else {

                        formula = part1;

                        chinese = part2;

                    }

                } else {

                    formula = part1;

                    chinese = part2;

                }

            } else {

                let colonMatch = t.match(/^(.+?)[:：]\s*(.+)$/);

                if (colonMatch) {

                    formula = colonMatch[2].trim();

                    chinese = colonMatch[1].trim();

                } else {

                    if (/[\u4e00-\u9fa5]/.test(t)) {

                        chinese = t;

                        formula = '';

                    } else {

                        formula = t;

                        chinese = '';

                    }

                }

            }

            formula = formula.trim();

            chinese = chinese.trim();

            if (formula && !/^\$.*\$$/.test(formula)) {

                formula = '$' + formula + '$';

            }

            return { formula, chinese };

        }



        function fracReplace(str) {

            return str

                .replace(/\\frac\s*{([^}]*)}\s*{([^}]*)}/g, '\\dfrac{$1}{$2}')

                .replace(/([^a-zA-Z0-9_\\])([0-9]+)\/([a-zA-Z0-9]+)/g, '$1\\dfrac{$2}{$3}')

                .replace(/([^a-zA-Z0-9_\\])([a-zA-Z0-9^{}\\]+)\/([a-zA-Z0-9^{}\\]+)/g, function(m, pre, num, den) {

                    if (num.startsWith('\\dfrac') || den.startsWith('\\dfrac')) return m;

                    return pre + '\\dfrac{' + num + '}{' + den + '}';

                });

        }



        const div = document.createElement('div');

        div.className = 'vis-item';



        // 处理趋向值显示

        const indicator = document.createElement('div');

        indicator.className = `approach-indicator approach-${approachDirection}`;

        let displayValue = approachValue;

        if (approachValue === 'a') {

            displayValue = '0'; // 默认显示0而不是a

        } else if (approachValue === Infinity || approachValue === '∞') {

            displayValue = '∞';

        } else if (typeof approachValue === 'number') {

            if (approachValue === Math.PI/2) {

                displayValue = 'π/2';

            } else {

                displayValue = Number.isInteger(approachValue) ? approachValue : approachValue.toFixed(1);

            }

        }

        

        const indicatorText = {

            'left': `x→${displayValue}⁻`,

            'right': `x→${displayValue}⁺`,

            'both': `x→${displayValue}`,

            'infinity': 'n→∞'

        };

        indicator.textContent = indicatorText[approachDirection] || `x→${displayValue}`;

        div.appendChild(indicator);



        const titleDiv = document.createElement('div');

        titleDiv.className = 'vis-title';



        const { formula, chinese } = parseVisTitle(title);



        let formulaHtml = formula ? fracReplace(formula) : '';

        if (formulaHtml) {

            const formulaSpan = document.createElement('span');

            formulaSpan.className = 'vis-formula';

            formulaSpan.innerHTML = formulaHtml;

            titleDiv.appendChild(formulaSpan);

        }

        if (chinese) {

            const chineseSpan = document.createElement('span');

            chineseSpan.className = 'vis-chinese';

            chineseSpan.textContent = chinese;

            titleDiv.appendChild(chineseSpan);

        }



        div.appendChild(titleDiv);



        const svg = d3.select(div).append('svg')

            .attr('width', 260)

            .attr('height', 200)

            .attr('viewBox', '0 0 260 200')

            .attr('preserveAspectRatio', 'xMidYMid meet');

        

        container.appendChild(div);



        // 添加点击展开功能

        div.addEventListener('click', () => expandVisualization(div, title, approachDirection, displayValue));



        const width = 240;

        const height = 180;

        const margin = {top: 20, right: 20, bottom: 30, left: 30};

        const innerWidth = width - margin.left - margin.right;

        const innerHeight = height - margin.top - margin.bottom;



        const g = svg.append('g')

            .attr('transform', `translate(${margin.left},${margin.top})`);



        return { svg, g, width: innerWidth, height: innerHeight, div };

    };



    // 格式化数值为分数或小数

    function formatLimitValue(value) {

        if (typeof value !== 'number') {

            return value;

        }



        if (Math.abs(value - Math.sqrt(2)) < 0.001) {

            return '√2 ≈ 1.414';

        } else if (Math.abs(value - 1.618) < 0.001) {

            return '(1+√5)/2 ≈ 1.618';  // 黄金比例

        } else if (Math.abs(value - 2/3) < 0.001) {

            return '2/3';  // 2/3 ≈ 0.6666666666666666

        } else if (Math.abs(value - 1/3) < 0.001) {

            return '1/3';  // 1/3 ≈ 0.3333333333333333

        } else if (Math.abs(value - 1/2) < 0.001) {

            return '1/2';  // 1/2 = 0.5

        } else if (Math.abs(value - 3/4) < 0.001) {

            return '3/4';  // 3/4 = 0.75

        } else if (Math.abs(value - 1/4) < 0.001) {

            return '1/4';  // 1/4 = 0.25

        } else if (Math.abs(value - 5/6) < 0.001) {

            return '5/6';  // 5/6 ≈ 0.8333333333333334

        } else if (Math.abs(value - 1/6) < 0.001) {

            return '1/6';  // 1/6 ≈ 0.16666666666666666

        } else if (Number.isInteger(value)) {

            return value.toString();

        } else if (value === 0) {

            return '0';

        } else {

            return value.toFixed(3);

        }

    }



    // 展开可视化功能

    function expandVisualization(originalDiv, title, approachDirection = 'both', approachValue = 'a') {

        const overlay = document.createElement('div');

        overlay.className = 'expanded-overlay';



        const content = document.createElement('div');

        content.className = 'expanded-content';

        

        // 获取当前页面中所有的可视化项目

        const currentSlide = document.querySelector('.step.is-active');

        const allVisItems = currentSlide ? currentSlide.querySelectorAll('.vis-item') : [];

        const currentIndex = Array.from(allVisItems).indexOf(originalDiv);



        const titleElement = document.createElement('div');

        titleElement.className = 'expanded-title';

        

        // 处理标题，保持数学公式的正确格式

        function parseExpandedTitle(title) {

            let formula = '', chinese = '';

            let t = title.trim();

            let brMatch = t.match(/^(.*?)(?:<br\s*\/?>)(.*)$/i);

            if (brMatch) {

                let part1 = brMatch[1].trim();

                let part2 = brMatch[2].trim();

                if (/^\$|\\|[a-zA-Z0-9_{}^]/.test(part2)) {

                    if (/[\u4e00-\u9fa5]/.test(part1)) {

                        chinese = part1;

                        formula = part2;

                    } else {

                        formula = part1;

                        chinese = part2;

                    }

                } else {

                    formula = part1;

                    chinese = part2;

                }

            } else {

                let colonMatch = t.match(/^(.+?)[:：]\s*(.+)$/);

                if (colonMatch) {

                    formula = colonMatch[2].trim();

                    chinese = colonMatch[1].trim();

                } else {

                    if (/[\u4e00-\u9fa5]/.test(t)) {

                        chinese = t;

                        formula = '';

                    } else {

                        formula = t;

                        chinese = '';

                    }

                }

            }

            formula = formula.trim();

            chinese = chinese.trim();

            if (formula && !/^\$.*\$$/.test(formula)) {

                formula = '$' + formula + '$';

            }

            return { formula, chinese };

        }



        function fracReplace(str) {

            return str

                .replace(/\\frac\s*{([^}]*)}\s*{([^}]*)}/g, '\\dfrac{$1}{$2}')

                .replace(/([^a-zA-Z0-9_\\])([0-9]+)\/([a-zA-Z0-9]+)/g, '$1\\dfrac{$2}{$3}')

                .replace(/([^a-zA-Z0-9_\\])([a-zA-Z0-9^{}\\]+)\/([a-zA-Z0-9^{}\\]+)/g, function(m, pre, num, den) {

                    if (num.startsWith('\\dfrac') || den.startsWith('\\dfrac')) return m;

                    return pre + '\\dfrac{' + num + '}{' + den + '}';

                });

        }



        const { formula, chinese } = parseExpandedTitle(title);

        let processedFormula = formula;

        if (formula) {

            processedFormula = fracReplace(formula);

        }

        

        if (chinese && processedFormula) {

            titleElement.innerHTML = `${chinese} - ${processedFormula}`;

        } else if (processedFormula) {

            titleElement.innerHTML = processedFormula;

        } else {

            titleElement.innerHTML = chinese;

        }

        

        content.appendChild(titleElement);



        // 为展开的标题重新渲染MathJax

        setTimeout(async () => {

            await renderMathJax(titleElement);

        }, 100);



        const svgContainer = document.createElement('div');

        svgContainer.className = 'expanded-svg-container';



        const closeBtn = document.createElement('button');

        closeBtn.className = 'close-btn';

        closeBtn.innerHTML = '×';

        closeBtn.onclick = () => {

            overlay.classList.remove('active');

            setTimeout(() => document.body.removeChild(overlay), 300);

        };



        // 创建简洁注释内容并添加到标题中

        const annotation = generateSimpleAnnotation(title, approachDirection, approachValue);

        

        // 将注释添加到标题的同一行

        if (chinese && processedFormula) {

            titleElement.innerHTML = `${chinese} - ${processedFormula} <span style="margin-left: 20px; color: #666; font-size: 0.9em;">${annotation}</span>`;

        } else if (processedFormula) {

            titleElement.innerHTML = `${processedFormula} <span style="margin-left: 20px; color: #666; font-size: 0.9em;">${annotation}</span>`;

        } else {

            titleElement.innerHTML = `${chinese} <span style="margin-left: 20px; color: #666; font-size: 0.9em;">${annotation}</span>`;

        }



        // 获取原始数据并重新绘制大图

        console.log('Original div:', originalDiv);

        console.log('Original div properties:', Object.keys(originalDiv));

        const originalData = originalDiv.__chartData;

        console.log('Original data:', originalData);

        

        // 尝试从div的父元素或其他方式获取数据

        if (!originalData) {

            console.log('Trying to find data in parent elements...');

            let parent = originalDiv.parentElement;

            while (parent && !originalData) {

                console.log('Checking parent:', parent);

                if (parent.__chartData) {

                    console.log('Found data in parent:', parent.__chartData);

                    break;

                }

                parent = parent.parentElement;

            }

        }

        

        if (originalData && originalData.drawFunction) {

            console.log('Drawing expanded chart...');

            const expandedSvg = d3.select(svgContainer).append('svg')

                .attr('width', '100%')

                .attr('height', '100%')

                .attr('viewBox', '0 0 800 500')

                .attr('preserveAspectRatio', 'xMidYMid meet');

            

            const g = expandedSvg.append('g')

                .attr('transform', 'translate(60, 50)');

            

            originalData.drawFunction(g, 680, 400);

        } else {

            console.log('No original data or drawFunction found');

            // 创建一个占位符

            const expandedSvg = d3.select(svgContainer).append('svg')

                .attr('width', '100%')

                .attr('height', '100%')

                .attr('viewBox', '0 0 800 500')

                .attr('preserveAspectRatio', 'xMidYMid meet');

            

            expandedSvg.append('text')

                .attr('x', 400)

                .attr('y', 250)

                .attr('text-anchor', 'middle')

                .style('font-size', '18px')

                .style('fill', '#666')

                .text('图表数据未找到');

        }



        content.appendChild(svgContainer);

        

        // 添加底部标注

        if (originalData && originalData.annotationData) {

            const annotationDiv = document.createElement('div');

            annotationDiv.className = 'chart-annotation';

            annotationDiv.innerHTML = generateChartAnnotation(title, originalData.annotationData);

            content.appendChild(annotationDiv);

        }

        content.appendChild(closeBtn);

        overlay.appendChild(content);

        document.body.appendChild(overlay);



        setTimeout(async () => {

            overlay.classList.add('active');

            // 为整个展开的内容重新渲染MathJax，延迟确保DOM完全加载

            setTimeout(async () => {

                await renderMathJax(titleElement);

                await renderMathJax(content);

            }, 300);

        }, 10);

        

        overlay.addEventListener('click', (e) => {

            if (e.target === overlay) {

                closeBtn.click();

            }

        });

    }



    // 生成底部标注函数

    function generateChartAnnotation(title, data) {

        const { type, approachPoint, limitValue, leftLimit, rightLimit, functionValue, isSequence, isDivergent, discontinuityType } = data;

        

        if (isSequence) {

            // 数列极限标注

            if (isDivergent) {

                return `<span class="conclusion">结论: 发散</span>。当 n→∞ 时, 数列的点${getSequenceBehavior(title)}。`;

            } else {

                // 格式化极限值

                const formattedLimit = formatLimitValue(limitValue);

                return `<span class="conclusion">结论: 收敛于${formattedLimit}</span>。当 n→∞ 时, 数列的点在 y=${formattedLimit} 上下振荡且幅度衰减为0。`;

            }

        } else {

            // 函数极限标注

            if (type === 'limit') {

                if (limitValue === null) {

                    const discType = getDiscontinuityType(title, leftLimit, rightLimit);

                    return `<span class="conclusion">结论: 极限不存在(${discType})</span>。<br>左极限(x→${approachPoint}⁻): ${leftLimit}。右极限(x→${approachPoint}⁺): ${rightLimit}。<br><div class="analysis">分析: ${getAnalysis(leftLimit, rightLimit, discType)}。</div>`;

                } else {

                    const formattedLimit = formatLimitValue(limitValue);

                    return `<span class="conclusion">结论: 极限存在，值为${formattedLimit}</span>。<br>左极限(x→${approachPoint}⁻): ${formattedLimit}。右极限(x→${approachPoint}⁺): ${formattedLimit}。<br><div class="analysis">分析: 左右极限存在且相等。</div>`;

                }

            } else if (type === 'continuity') {

                if (limitValue !== null && leftLimit === rightLimit && leftLimit === functionValue) {

                    const formattedLeft = formatLimitValue(leftLimit);

                    const formattedRight = formatLimitValue(rightLimit);

                    const formattedFunction = formatLimitValue(functionValue);

                    return `<span class="conclusion">结论: 在x=${approachPoint}处连续</span>。<br><div class="analysis">分析: 左极限=${formattedLeft}, 右极限=${formattedRight}, 函数值f(${approachPoint})=${formattedFunction}。三者相等。</div>`;

                } else {

                    const formattedLeft = leftLimit ? formatLimitValue(leftLimit) : '不存在';

                    const formattedRight = rightLimit ? formatLimitValue(rightLimit) : '不存在';

                    const formattedFunction = functionValue ? formatLimitValue(functionValue) : '不存在';

                    return `<span class="conclusion">结论: 在x=${approachPoint}处间断</span>。<br><div class="analysis">分析: 左极限=${formattedLeft}, 右极限=${formattedRight}, 函数值f(${approachPoint})=${formattedFunction}。三者不完全相等。</div>`;

                }

            }

        }

        

        return '';

    }

    

    function getSequenceBehavior(title) {

        if (title.includes('线性增长') || title.includes('平方增长')) return '无限增高，趋于+∞';

        if (title.includes('指数增长')) return '指数式无限增高';

        if (title.includes('震荡')) return '上下震荡且幅度增大';

        if (title.includes('交替')) return '正负交替且绝对值增大';

        if (title.includes('混沌')) return '无规律震荡';

        return '发散到无穷';

    }

    

    function getDiscontinuityType(title, leftLimit, rightLimit) {

        if (leftLimit === '∞' || leftLimit === '-∞' || rightLimit === '∞' || rightLimit === '-∞') {

            return '无穷间断点';

        }

        if (leftLimit !== rightLimit && leftLimit !== '振荡' && rightLimit !== '振荡') {

            return '跳跃间断点';

        }

        if (leftLimit === '振荡' || rightLimit === '振荡') {

            return '振荡间断点';

        }

        return '间断点';

    }

    

    function getAnalysis(leftLimit, rightLimit, discType) {

        if (discType === '跳跃间断点') return '左右极限存在但不相等';

        if (discType === '无穷间断点') return '至少一侧极限为无穷';

        if (discType === '振荡间断点') return '至少一侧极限不存在';

        return '极限性质复杂';

    }

    

    function calculateLeftLimit(caseItem, a) {

        try {

            if (caseItem.name.includes('振荡')) return '振荡';

            if (caseItem.name.includes('不存在') && caseItem.name.includes('左极限')) return '不存在';

            const testVal = a - 0.01;

            const result = caseItem.fnLeft(testVal);

            if (!isFinite(result)) return result > 0 ? '+∞' : '-∞';

            return result.toFixed(1);

        } catch(e) {

            return '不存在';

        }

    }

    

    function calculateRightLimit(caseItem, a) {

        try {

            if (caseItem.name.includes('振荡')) return '振荡';

            if (caseItem.name.includes('不存在') && caseItem.name.includes('右极限')) return '不存在';

            const testVal = a + 0.01;

            const result = caseItem.fnRight(testVal);

            if (!isFinite(result)) return result > 0 ? '+∞' : '-∞';

            return result.toFixed(1);

        } catch(e) {

            return '不存在';

        }

    }



    // 生成简洁注释

    function generateSimpleAnnotation(title, approachDirection, approachValue) {

        const annotations = {

            '左极限': '从左侧接近',

            '右极限': '从右侧接近',

            '双侧极限': '从两侧接近',

            '无穷大': '趋向无穷',

            '无穷小': '趋向零',

            '连续函数': '无间断点',

            '间断点': '存在间断',

            '初等函数': '基本函数类型',

            '等价无穷小': '极限值相等'

        };

        

        for (const [key, value] of Object.entries(annotations)) {

            if (title.includes(key)) {

                return `<div class="annotation-text">${value}</div>`;

            }

        }

        

        if (approachDirection === 'left') {

            return '<div class="annotation-text">从左侧接近</div>';

        } else if (approachDirection === 'right') {

            return '<div class="annotation-text">从右侧接近</div>';

        } else if (approachDirection === 'both') {

            return '<div class="annotation-text">从两侧接近</div>';

        }

        

        return null;

    }



    // 坐标轴绘制函数

    function drawAxes(g, xScale, yScale, width, height) {

        const xDomain = xScale.domain();

        const yDomain = yScale.domain();

        

        // X轴

        const xAxisY = (yDomain[0] <= 0 && yDomain[1] >= 0) ? yScale(0) : height;

        g.append('g')

            .attr('class', 'x-axis')

            .attr('transform', `translate(0,${xAxisY})`)

            .call(d3.axisBottom(xScale).ticks(5).tickSizeOuter(0));

        

        // Y轴

        const yAxisX = (xDomain[0] <= 0 && xDomain[1] >= 0) ? xScale(0) : 0;

        g.append('g')

            .attr('class', 'y-axis')

            .attr('transform', `translate(${yAxisX},0)`)

            .call(d3.axisLeft(yScale).ticks(5).tickSizeOuter(0));

            

        // 网格线

        g.append('g')

            .attr('class', 'grid')

            .attr('opacity', 0.1)

            .call(d3.axisBottom(xScale).ticks(5)

                .tickSize(height)

                .tickFormat(''))

            .attr('transform', `translate(0,0)`);

            

        g.append('g')

            .attr('class', 'grid')

            .attr('opacity', 0.1)

            .call(d3.axisLeft(yScale).ticks(5)

                .tickSize(-width)

                .tickFormat(''));

    }



    // 动画函数

    const animatePath = (path, duration = 2000, loop = true) => {

        if (!path || !path.node()) return;

        const totalLength = path.node().getTotalLength();

        if (totalLength === 0) return;



        function restart() {

            path

                .attr('stroke-dasharray', totalLength + ' ' + totalLength)

                .attr('stroke-dashoffset', totalLength)

                .transition()

                .duration(duration)

                .ease(d3.easeLinear)

                .attr('stroke-dashoffset', 0)

                .on('end', () => {

                    if (loop) {

                        setTimeout(restart, 500);

                    }

                });

        }

        restart();

    };



    const animatePoints = (selection, loop = true) => {

        const duration = 300;

        const delay = 50;



        function restart() {

            selection

                .style('opacity', 0)

                .transition()

                .delay((d, i) => i * delay)

                .duration(duration)

                .style('opacity', 1)

                .on('end', (d, i, nodes) => {

                    if (i === nodes.length - 1 && loop) {

                        setTimeout(() => {

                            selection.transition()

                                .duration(500)

                                .style('opacity', 0.3)

                                .on('end', () => restart());

                        }, 1500);

                    }

                });

        }

        restart();

    };



    // 极限趋近动画函数

    const animateLimitApproach = (g, xScale, yScale, func, approachPoint, limitValue, width, height) => {

        const duration = 3000;

        

        // 降低函数曲线透明度，让动画更突出

        g.selectAll('path').attr('opacity', 0.6);

        

        if (approachPoint === Infinity || approachPoint === -Infinity) {

            // 对于无穷大极限，单点向右移动

            const animateInfinity = () => {

                const movingPoint = g.append('circle')

                    .attr('class', 'moving-point')

                    .attr('r', 4)

                    .attr('fill', '#3498db')

                    .attr('opacity', 0);

                

                const xStart = xScale.domain()[0];

                const xEnd = xScale.domain()[1];

                

                movingPoint

                    .attr('cx', xScale(xStart))

                    .attr('cy', yScale(func(xStart)))

                    .transition()

                    .duration(200)

                    .attr('opacity', 1)

                    .transition()

                    .duration(duration)

                    .ease(d3.easeLinear)

                    .attr('cx', xScale(xEnd))

                    .attr('cy', yScale(func(xEnd)))

                    .on('end', () => {

                        movingPoint.transition()

                            .duration(200)

                            .attr('opacity', 0)

                            .on('end', () => {

                                movingPoint.remove();

                                setTimeout(animateInfinity, 500);

                            });

                    });

            };

            animateInfinity();

            

        } else {

            // 双边趋近动画

            const animateApproach = () => {

                const xDomain = xScale.domain();

                const range = Math.abs(xDomain[1] - xDomain[0]) * 0.4;

                const leftStart = Math.max(approachPoint - range, xDomain[0]);

                const rightStart = Math.min(approachPoint + range, xDomain[1]);

                

                // 左侧趋近点（红色）- 更大

                const leftPoint = g.append('circle')

                    .attr('class', 'left-approach-point')

                    .attr('r', 6)

                    .attr('fill', '#e74c3c')

                    .attr('opacity', 0);

                

                // 右侧趋近点（蓝色）- 更大

                const rightPoint = g.append('circle')

                    .attr('class', 'right-approach-point')

                    .attr('r', 6)

                    .attr('fill', '#3498db')

                    .attr('opacity', 0);

                

                // x轴上的三角形指示器 - 更大

                const leftTriangle = g.append('polygon')

                    .attr('class', 'left-triangle')

                    .attr('points', '0,-5 10,0 0,5')

                    .attr('fill', '#e74c3c')

                    .attr('opacity', 0);

                

                const rightTriangle = g.append('polygon')

                    .attr('class', 'right-triangle')

                    .attr('points', '0,-5 -10,0 0,5')

                    .attr('fill', '#3498db')

                    .attr('opacity', 0);

                

                // 垂直轨迹线

                const leftTrail = g.append('line')

                    .attr('class', 'left-trail')

                    .attr('stroke', '#e74c3c')

                    .attr('stroke-width', 1)

                    .attr('stroke-dasharray', '2,2')

                    .attr('opacity', 0);

                

                const rightTrail = g.append('line')

                    .attr('class', 'right-trail')

                    .attr('stroke', '#3498db')

                    .attr('stroke-width', 1)

                    .attr('stroke-dasharray', '2,2')

                    .attr('opacity', 0);

                

                // 不再显示极限点标记

                let limitPoint = null;

                

                // 初始位置

                leftPoint

                    .attr('cx', xScale(leftStart))

                    .attr('cy', yScale(func(leftStart)));

                

                rightPoint

                    .attr('cx', xScale(rightStart))

                    .attr('cy', yScale(func(rightStart)));

                

                leftTriangle

                    .attr('transform', `translate(${xScale(leftStart)}, ${height + 15})`);

                

                rightTriangle

                    .attr('transform', `translate(${xScale(rightStart)}, ${height + 15})`);

                

                // 开始动画

                const animationPromises = [];

                

                // 显示所有元素

                animationPromises.push(

                    leftPoint.transition().duration(300).attr('opacity', 1).end(),

                    rightPoint.transition().duration(300).attr('opacity', 1).end(),

                    leftTriangle.transition().duration(300).attr('opacity', 0.8).end(),

                    rightTriangle.transition().duration(300).attr('opacity', 0.8).end()

                );

                

                Promise.all(animationPromises).then(() => {

                    // 主要的趋近动画 - 确保x和y都在动

                    const leftEndX = approachPoint - 0.02;

                    const rightEndX = approachPoint + 0.02;

                    

                    // 创建连续的动画序列，让点沿着函数曲线移动

                    const animatePoint = (point, startX, endX, color, trail, triangle) => {

                        const steps = 50; // 增加步数让动画更流畅

                        const stepDuration = duration / steps;

                        let currentStep = 0;

                        

                        const animate = () => {

                            if (currentStep >= steps) {

                                // 动画完成，重新开始

                                setTimeout(() => {

                                    g.selectAll('.left-approach-point, .right-approach-point, .left-triangle, .right-triangle, .left-trail, .right-trail').remove();

                                    animateApproach();

                                }, 1000);

                                return;

                            }

                            

                            const progress = currentStep / steps;

                            const currentX = startX + (endX - startX) * progress;

                            const currentY = func(currentX);

                            

                            // 确保函数值有效

                            if (isFinite(currentY)) {

                                point

                                    .transition()

                                    .duration(stepDuration)

                                    .ease(d3.easeLinear)

                                    .attr('cx', xScale(currentX))

                                    .attr('cy', yScale(currentY));

                                

                                // 更新轨迹线

                                if (currentStep === 0) {

                                    trail

                                        .attr('x1', xScale(startX))

                                        .attr('y1', yScale(func(startX)))

                                        .attr('x2', xScale(startX))

                                        .attr('y2', yScale(func(startX)))

                                        .attr('opacity', 0.5);

                                }

                                

                                trail

                                    .transition()

                                    .duration(stepDuration)

                                    .attr('x2', xScale(currentX))

                                    .attr('y2', yScale(currentY));

                                

                                // 更新三角形指示器

                                triangle

                                    .transition()

                                    .duration(stepDuration)

                                    .attr('transform', `translate(${xScale(currentX)}, ${height + 15})`);

                            }

                            

                            currentStep++;

                            setTimeout(animate, stepDuration);

                        };

                        

                        animate();

                    };

                    

                    // 同时启动左右两个点的动画

                    animatePoint(leftPoint, leftStart, leftEndX, '#e74c3c', leftTrail, leftTriangle);

                    animatePoint(rightPoint, rightStart, rightEndX, '#3498db', rightTrail, rightTriangle);

                });

            };

            

            animateApproach();

        }

    };



    // ============ 可视化函数 ============

    const animationMap = {

        'intro': () => {},

        'toc': () => {},

        'why-limit': visualizeWhyLimit,

        'intuitive-limit': visualizeIntuitiveLimit,

        'convergent-sequences': visualizeConvergentSequences,

        'divergent-sequences': visualizeDivergentSequences,

        'sequence-calculation': visualizeSequenceCalculation,

        'function-limits': visualizeFunctionLimits,

        'one-sided-limits': visualizeOneSidedLimits,

        'one-sided-detailed': visualizeOneSidedLimitsDetailed,

        'limit-operations': visualizeLimitOperations,

        'limit-methods-detailed': visualizeLimitMethodsDetailed,

        'limit-methods': visualizeLimitMethods,

        'important-limit-1': visualizeImportantLimit1,

        'important-limit-2': visualizeImportantLimit2,

        'important-limits-detailed': visualizeImportantLimitsDetailed,

        'infinitesimal-infinity': visualizeInfinitesimalInfinity,

        'infinitesimal-comparison': visualizeInfinitesimalComparison,

        'equivalent-infinitesimal': visualizeEquivalentInfinitesimal,

        'equivalent-infinitesimal-app': visualizeEquivalentInfinitesimalApp,

        'continuous-functions': visualizeContinuousFunctions,

        'discontinuities': visualizeDiscontinuities,

        'elementary-functions': visualizeElementaryFunctions,

        'continuity-determination': visualizeContinuityDetermination,

        'applications': visualizeApplications,

        'summary': visualizeSummary

    };



    function scrollToStep(stepKey) {

        const target = document.getElementById(`step-${stepKey}`);

        if (target) {

            target.scrollIntoView({ behavior: 'smooth', block: 'center' });

        }

    }



    window.scrollToStep = scrollToStep;



    document.addEventListener('DOMContentLoaded', () => {

        const steps = Array.from(document.querySelectorAll('.step'));

        const visContainer = d3.select('#sticky-vis-container');

        let activeStep = null;



        function handleStepEnter(step) {

            if (activeStep === step) {

                return;

            }



            activeStep = step;

            cleanupAnimations();



            steps.forEach(s => s.classList.remove('is-active'));

            step.classList.add('is-active');



            const animationKey = step.dataset.animation;

            const isFullscreen = step.classList.contains('fullscreen');

            const targetContainerId = isFullscreen ? `vis-${animationKey}` : 'sticky-vis-container';



            const shouldHideVisualization = (animationKey === 'intro' || animationKey === 'toc');

            visContainer.style('opacity', (isFullscreen || shouldHideVisualization) ? 0 : 1);



            // 使用类与淡入淡出避免重排引起的闪烁

            const visualizationPanelEl = document.querySelector('.visualization-panel');

            const lectureNotesEl = document.querySelector('.lecture-notes');

            if (visualizationPanelEl && lectureNotesEl) {

                if (shouldHideVisualization) {

                    visualizationPanelEl.style.opacity = '0';

                    visualizationPanelEl.style.visibility = 'hidden';

                    lectureNotesEl.classList.add('is-fullscreen');

                } else {

                    visualizationPanelEl.style.opacity = '1';

                    visualizationPanelEl.style.visibility = 'visible';

                    lectureNotesEl.classList.remove('is-fullscreen');

                }

            }



            if (!isFullscreen) {

                visContainer.classed('visualization-flex', true);

                visContainer.classed('visualization-grid', false);

                visContainer.html('');

            }



            const animator = animationMap[animationKey];

            if (typeof animator === 'function') {

                animator(targetContainerId);

            }



            if (window.MathJax && window.MathJax.typesetPromise) {

                window.MathJax.typesetPromise([step]);

            }

        }



        const observer = new IntersectionObserver((entries) => {

            entries.forEach(entry => {

                if (entry.isIntersecting) {

                    handleStepEnter(entry.target);

                }

            });

        }, {

            rootMargin: '-50% 0px -50% 0px',

            threshold: 0

        });



        steps.forEach(step => observer.observe(step));



        if (steps.length > 0) {

            handleStepEnter(steps[0]);

        }



        if (window.MathJax && window.MathJax.typesetPromise) {

            window.MathJax.typesetPromise();

        }

    });



    // 辅助函数

    function factorial(n) {

        if (n <= 1) return 1;

        return n * factorial(n - 1);

    }



    function fibonacciRatio(n) {

        let a = 1, b = 1;

        for(let i = 2; i < n; i++) {

            [a, b] = [b, a + b];

        }

        return b / a;

    }



    function colorWithAlpha(hex, alpha) {

        const c = d3.color(hex);

        if (!c) return hex;

        return `rgba(${c.r}, ${c.g}, ${c.b}, ${alpha})`;

    }



    function visualizeIntro(containerId) {

        const setup = setupD3(containerId, {top: 40, right: 40, bottom: 50, left: 40});

        if (!setup) return;

        const { g, width, height } = setup;



        const cards = [

            { title: '极限导览', subtitle: '认识极限思想', target: 'why-limit', color: '#3498db' },

            { title: '教材案例', subtitle: '例 2-1 / 2-2 的收敛模型', target: 'convergent-sequences', color: '#1abc9c' },

            { title: '连续性判定', subtitle: '例 2-4 人影长度', target: 'continuity-determination', color: '#e67e22' }

        ];



        const cardWidth = Math.min(width * 0.9, 360);

        const cardHeight = 90;

        const gap = 24;

        const totalHeight = cards.length * cardHeight + (cards.length - 1) * gap;

        const startY = Math.max((height - totalHeight) / 2, 0);



        const cardGroup = g.selectAll('.intro-card')

            .data(cards)

            .enter()

            .append('g')

            .attr('class', 'intro-card')

            .attr('transform', (d, i) => `translate(${(width - cardWidth) / 2}, ${startY + i * (cardHeight + gap)})`)

            .style('cursor', 'pointer')

            .on('click', (_, d) => {

                if (window.scrollToStep) {

                    window.scrollToStep(d.target);

                }

            });



        cardGroup.append('rect')

            .attr('width', cardWidth)

            .attr('height', cardHeight)

            .attr('rx', 18)

            .attr('fill', d => colorWithAlpha(d.color, 0.18))

            .attr('stroke', d => colorWithAlpha(d.color, 0.65))

            .attr('stroke-width', 2);



        cardGroup.append('text')

            .attr('x', 24)

            .attr('y', 38)

            .attr('fill', d => d.color)

            .style('font-size', '22px')

            .style('font-weight', 600)

            .text(d => d.title);



        cardGroup.append('text')

            .attr('x', 24)

            .attr('y', 62)

            .attr('fill', '#34495e')

            .style('font-size', '14px')

            .text(d => d.subtitle);



        cardGroup.append('text')

            .attr('x', cardWidth - 24)

            .attr('y', cardHeight / 2)

            .attr('text-anchor', 'end')

            .attr('dominant-baseline', 'middle')

            .attr('fill', d => d.color)

            .style('font-size', '20px')

            .style('font-weight', 700)

            .text('→');

    }



    function visualizeToc(containerId) {

        const setup = setupD3(containerId, {top: 40, right: 40, bottom: 50, left: 40});

        if (!setup) return;

        const { g, width, height } = setup;



        const sections = [

            { title: '极限概念', items: ['直观理解', '数列极限', '函数极限', '左右极限'], target: 'why-limit', color: '#3498db' },

            { title: '极限计算', items: ['四则运算', '直接代入', '因式分解', '有理化'], target: 'limit-operations', color: '#9b59b6' },

            { title: '重要极限', items: ['第一重要极限', '第二重要极限', '运用技巧'], target: 'important-limit-1', color: '#e67e22' },

            { title: '无穷小比较', items: ['无穷小/无穷大', '比较法', '等价替换'], target: 'infinitesimal-comparison', color: '#16a085' },

            { title: '连续性', items: ['连续条件', '间断点', '初等函数'], target: 'continuous-functions', color: '#e74c3c' },

            { title: '综合应用', items: ['例 2-3 并联电阻', '例 2-4 人影长度', '章节总结'], target: 'applications', color: '#2ecc71' }

        ];



        const columns = width > 520 ? 2 : 1;

        const gap = 24;

        const cardWidth = (width - (columns - 1) * gap) / columns;

        const cardHeight = 160;

        const rows = Math.ceil(sections.length / columns);

        const totalHeight = rows * cardHeight + (rows - 1) * gap;

        const startY = Math.max((height - totalHeight) / 2, 0);



        const cardGroup = g.selectAll('.toc-card')

            .data(sections)

            .enter()

            .append('g')

            .attr('class', 'toc-card')

            .attr('transform', (d, i) => {

                const col = i % columns;

                const row = Math.floor(i / columns);

                const x = col * (cardWidth + gap);

                const y = startY + row * (cardHeight + gap);

                return `translate(${x}, ${y})`;

            })

            .style('cursor', 'pointer')

            .on('click', (_, d) => {

                if (window.scrollToStep) {

                    window.scrollToStep(d.target);

                }

            });



        cardGroup.append('rect')

            .attr('width', cardWidth)

            .attr('height', cardHeight)

            .attr('rx', 18)

            .attr('fill', d => colorWithAlpha(d.color, 0.18))

            .attr('stroke', d => colorWithAlpha(d.color, 0.65))

            .attr('stroke-width', 2);



        cardGroup.append('text')

            .attr('x', 20)

            .attr('y', 34)

            .attr('fill', d => d.color)

            .style('font-size', '18px')

            .style('font-weight', 600)

            .text(d => d.title);



        cardGroup.each(function(d) {

            const group = d3.select(this);

            d.items.forEach((item, idx) => {

                group.append('text')

                    .attr('x', 24)

                    .attr('y', 58 + idx * 20)

                    .attr('fill', '#34495e')

                    .style('font-size', '13px')

                    .text(`• ${item}`);

            });

        });



        cardGroup.append('text')

            .attr('x', cardWidth - 20)

            .attr('y', cardHeight - 20)

            .attr('text-anchor', 'end')

            .attr('fill', d => d.color)

            .style('font-size', '12px')

            .text('点击查看');

    }



    // 第1页：为什么要学极限

    function visualizeWhyLimit(containerId) {

        const setup = setupD3(containerId);

        if (!setup) return;

        const { g, width, height } = setup;

        

        // 阿基里斯追龟动画

        const trackY = height / 2;

        g.append('line')

            .attr('x1', 0)

            .attr('x2', width)

            .attr('y1', trackY)

            .attr('y2', trackY)

            .attr('stroke', '#34495e')

            .attr('stroke-width', 3);

        

        // 阿基里斯

        const achilles = g.append('g');

        achilles.append('circle')

            .attr('r', 15)

            .attr('fill', '#3498db')

            .attr('cy', trackY - 30);

        achilles.append('text')

            .attr('y', trackY - 50)

            .attr('text-anchor', 'middle')

            .attr('fill', '#34495e')

            .text('阿基里斯');

        

        // 乌龟

        const tortoise = g.append('g');

        tortoise.append('circle')

            .attr('r', 10)

            .attr('fill', '#2ecc71')

            .attr('cy', trackY + 30);

        tortoise.append('text')

            .attr('y', trackY + 50)

            .attr('text-anchor', 'middle')

            .attr('fill', '#34495e')

            .text('乌龟');

        

        // 距离标记

        const distanceText = g.append('text')

            .attr('x', width / 2)

            .attr('y', 30)

            .attr('text-anchor', 'middle')

            .attr('fill', '#34495e')

            .style('font-size', '18px');

        

        let step = 0;

        const steps = [

            { achilles: 0, tortoise: 200, text: "初始：乌龟领先200米" },

            { achilles: 200, tortoise: 220, text: "第1步：阿基里斯跑到200米，乌龟到220米" },

            { achilles: 220, tortoise: 222, text: "第2步：阿基里斯跑到220米，乌龟到222米" },

            { achilles: 222, tortoise: 222.2, text: "第3步：距离越来越小..." },

            { achilles: 222.2, tortoise: 222.22, text: "第4步：差距仅0.02米" },

            { achilles: 222.22, tortoise: 222.222, text: "无限接近！极限思想的体现" }

        ];

        

        function animate() {

            if (step >= steps.length) {

                step = 0;

            }

            

            const currentStep = steps[step];

            const scale = width / 300;

            

            achilles.transition()

                .duration(2000 / globalAnimationSpeed)

                .attr('transform', `translate(${currentStep.achilles * scale}, 0)`);

            

            tortoise.transition()

                .duration(2000 / globalAnimationSpeed)

                .attr('transform', `translate(${currentStep.tortoise * scale}, 0)`);

            

            distanceText.text(currentStep.text);

            

            step++;

            const timeoutId = setTimeout(animate, 3000 / globalAnimationSpeed);

            currentAnimations.push(() => clearTimeout(timeoutId));

        }

        

        animate();

    }



    // 第2页：极限的直观理解

    function visualizeIntuitiveLimit(containerId) {

        const setup = setupD3(containerId);

        if (!setup) return;

        const { g, width, height } = setup;

        

        // 杯子倒水动画

        const cupWidth = 100;

        const cupHeight = 200;

        const cupX = width / 2 - cupWidth / 2;

        const cupY = height / 2 - cupHeight / 2;

        

        // 杯子轮廓

        g.append('rect')

            .attr('x', cupX)

            .attr('y', cupY)

            .attr('width', cupWidth)

            .attr('height', cupHeight)

            .attr('fill', 'none')

            .attr('stroke', '#34495e')

            .attr('stroke-width', 3);

        

        // 刻度线

        for (let i = 1; i <= 10; i++) {

            const y = cupY + cupHeight - (cupHeight * i / 10);

            g.append('line')

                .attr('x1', cupX - 10)

                .attr('x2', cupX)

                .attr('y1', y)

                .attr('y2', y)

                .attr('stroke', '#34495e')

                .attr('stroke-width', 1);

            

            if (i % 2 === 0) {

                g.append('text')

                    .attr('x', cupX - 15)

                    .attr('y', y + 3)

                    .attr('text-anchor', 'end')

                    .attr('fill', '#34495e')

                    .style('font-size', '12px')

                    .text(`${i / 10}L`);

            }

        }

        

        // 水位

        const water = g.append('rect')

            .attr('x', cupX + 2)

            .attr('y', cupY + cupHeight - 2)

            .attr('width', cupWidth - 4)

            .attr('height', 0)

            .attr('fill', 'rgba(52, 152, 219, 0.7)');

        

        // 显示当前水量

        const volumeText = g.append('text')

            .attr('x', width / 2)

            .attr('y', cupY - 20)

            .attr('text-anchor', 'middle')

            .attr('fill', '#34495e')

            .style('font-size', '18px');

        

        let totalVolume = 0;

        let pourCount = 0;

        

        function pour() {

            if (pourCount > 8) {

                totalVolume = 0;

                pourCount = 0;

                water.attr('height', 0);

            }

            

            const pourAmount = 0.5 * Math.pow(0.5, pourCount);

            totalVolume += pourAmount;

            

            water.transition()

                .duration(1000 / globalAnimationSpeed)

                .attr('height', cupHeight * totalVolume)

                .attr('y', cupY + cupHeight - cupHeight * totalVolume);

            

            volumeText.text(`当前：${totalVolume.toFixed(4)}L，本次倒入：${pourAmount.toFixed(4)}L`);

            

            pourCount++;

            const timeoutId = setTimeout(pour, 2000 / globalAnimationSpeed);

            currentAnimations.push(() => clearTimeout(timeoutId));

        }

        

        pour();

    }



    // 第3页：收敛数列

    function visualizeConvergentSequences(containerId) {

        const container = getContainer(containerId, 'grid');

        if (!container) return;



        const sequences = [

            { name: '指数衰减: $a_n = \\frac{2}{3} + \\frac{1}{3}e^{-0.3n}$', fn: n => 2/3 + (1/3) * Math.exp(-0.3 * n), limit: 2/3 },

            { name: '交替收敛: $a_n = 2 + (-0.9)^n$', fn: n => 2 + Math.pow(-0.9, n), limit: 2 },

            { name: '调和收敛: $a_n = 1 + \\frac{1}{n}$', fn: n => 1 + 1/n, limit: 1 },

            { name: '平方根收敛: $a_n = \\sqrt{n+1} - \\sqrt{n}$', fn: n => Math.sqrt(n + 1) - Math.sqrt(n), limit: 0 },

            { name: '对数收敛: $a_n = \\frac{\\ln(n+1)}{\\ln n}$', fn: n => Math.log(n + 1) / Math.log(n), limit: 1 },

            { name: '阶乘比: $a_n = \\frac{2^n}{n!}$', fn: n => Math.pow(2, n) / (n > 10 ? 1000000 : factorial(n)), limit: 0 },

            { name: '正弦衰减: $a_n = \\frac{\\sin n}{n}$', fn: n => Math.sin(n) / n, limit: 0 },

            { name: '余弦衰减: $a_n = \\frac{1+\\cos n}{n}$', fn: n => (1 + Math.cos(n)) / n, limit: 0 },

            { name: '幂函数比: $a_n = \\frac{n^2}{n^{2.1}}$', fn: n => Math.pow(n, 2) / Math.pow(n, 2.1), limit: 0 },

            { name: '嵌套根式: $a_n = \\sqrt{2 + \\frac{1}{n}}$', fn: n => Math.sqrt(2 + 1/n), limit: Math.sqrt(2) },

            { name: '连分数: $a_n = \\frac{1}{1 + 1/n}$', fn: n => 1 / (1 + 1/n), limit: 1 },

            { name: '几何级数和: $S_n = \\sum_{k=0}^{n-1} (\\frac{1}{2})^k$', fn: n => (1 - Math.pow(0.5, n)) / 0.5, limit: 2 },

            { name: '复合函数: $a_n = n \\sin(\\frac{1}{n})$', fn: n => n * Math.sin(1/n), limit: 1 },

            { name: '双曲函数: $a_n = \\tanh(\\frac{n}{5})$', fn: n => Math.tanh(n/5), limit: 1 },

            { name: 'Fibonacci比: $a_n = \\frac{F_{n+1}}{F_n}$', fn: n => fibonacciRatio(n), limit: 1.618 }

        ];



        sequences.forEach((seq, i) => {

            const drawFunction = (g, width, height) => {

                const xScale = d3.scaleLinear().domain([1, 20]).range([0, width]);

                const yScale = d3.scaleLinear()

                    .domain([Math.min(seq.limit - 1, -1), Math.max(seq.limit + 1, 4)])

                    .range([height, 0]);



                drawAxes(g, xScale, yScale, width, height);



                // 极限线

                g.append('line')

                    .attr('x1', 0)

                    .attr('y1', yScale(seq.limit))

                    .attr('x2', width)

                    .attr('y2', yScale(seq.limit))

                    .attr('stroke', 'var(--success-color)')

                    .attr('stroke-dasharray', '3,3')

                    .attr('opacity', 0.7);



                const data = d3.range(1, 21).map(n => ({x: n, y: seq.fn(n)}));



                const points = g.selectAll('.point')

                    .data(data)

                    .enter().append('circle')

                    .attr('cx', d => xScale(d.x))

                    .attr('cy', d => yScale(d.y))

                    .attr('r', 3)

                    .attr('fill', 'var(--primary-color)');



                animatePoints(points);

            };



            const { g, width, height, div } = setup(container, i, seq.name, 'infinity');

            div.__chartData = { drawFunction, annotationData: { type: 'sequence', isSequence: true, limitValue: seq.limit } };

            drawFunction(g, width, height);

        });



        // 渲染MathJax

        setTimeout(() => renderMathJax(container), 100);

    }



    // 第4页：发散数列

function visualizeDivergentSequences(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) return;



        const sequences = [

            { name: '线性增长: $a_n = n$', fn: n => n },

            { name: '平方增长: $a_n = \\frac{n^2}{10}$', fn: n => n * n / 10 },

            { name: '指数增长: $a_n = (1.2)^n$', fn: n => Math.pow(1.2, n) },

            { name: '对数增长: $a_n = 2\\ln n$', fn: n => Math.log(n) * 2 },

            { name: '震荡发散: $a_n = \\frac{n(-1)^n}{5}$', fn: n => n * Math.pow(-1, n) / 5 },

            { name: '正弦震荡: $a_n = \\frac{n\\sin n}{10}$', fn: n => n * Math.sin(n) / 10 },

            { name: '交替无界: $a_n = (-1.1)^n$', fn: n => Math.pow(-1.1, n) },

            { name: '阶乘增长: $a_n = \\frac{n!}{10}$', fn: n => n > 6 ? 20 : factorial(n) / 10 },

            { name: '混沌: $a_n = 3\\sin(\\frac{n^2}{10})$', fn: n => 3 * Math.sin(n * n / 10) },

            { name: '分段发散: $a_n = f(n)$', fn: n => n % 3 === 0 ? n/2 : -n/3 },

            { name: '周期爆炸: $a_n = e^{n/10}\\sin n$', fn: n => Math.sin(n) * Math.exp(n/10) },

            { name: '螺旋发散: $a_n = \\frac{n}{5}\\cos(\\frac{n}{2})$', fn: n => n * Math.cos(n/2) / 5 }

        ];



        sequences.forEach((seq, i) => {

            const drawFunction = (g, width, height) => {

                const data = d3.range(1, 21).map(n => ({x: n, y: seq.fn(n)}));

                const yExtent = d3.extent(data, d => d.y);



                const xScale = d3.scaleLinear().domain([1, 20]).range([0, width]);

                const yScale = d3.scaleLinear()

                    .domain([Math.min(yExtent[0], -5), Math.max(yExtent[1], 5)])

                    .range([height, 0]);



                drawAxes(g, xScale, yScale, width, height);



                const points = g.selectAll('.point')

                    .data(data)

                    .enter().append('circle')

                    .attr('cx', d => xScale(d.x))

                    .attr('cy', d => yScale(d.y))

                    .attr('r', 3)

                    .attr('fill', 'var(--accent-color)');



                animatePoints(points);

            };



            const { g, width, height, div } = setup(container, i, seq.name, 'infinity');

            div.__chartData = { drawFunction, annotationData: { type: 'sequence', isSequence: true, limitValue: null } };

            drawFunction(g, width, height);

        });



        // 渲染MathJax

        setTimeout(() => renderMathJax(container), 100);

    }



    // 第5页：数列极限计算

    function visualizeSequenceCalculation(containerId) {

        const setup = setupD3(containerId);

        if (!setup) return;

        const { g, width, height } = setup;

        

        // 创建交互式面板

        const panel = d3.select('#vis-sequence-calculation')

            .append('div')

            .attr('class', 'interactive-panel')

            .style('bottom', '20px');

        

        panel.append('h3')

            .style('text-align', 'center')

            .text('分子分母同除最高次演示');

        

        // 创建步骤显示区

        const stepsDiv = panel.append('div')

            .style('background', 'rgba(0, 0, 0, 0)')

            .style('padding', '20px')

            .style('border-radius', '8px')

            .style('margin-top', '20px');

        

        // 增加更详细的步骤，适合高职学生

        const steps = [

            { delay: 0, html: `<span style="color: #e74c3c;">第1步：观察最高次</span><br>

                              <span>分子最高次：n² (系数是2)</span><br>

                              <span>分母最高次：n² (系数是1)</span>` },

            { delay: 2000, html: `<span style="color: #e74c3c;">第2步：原式</span><br>

                                 <span style="font-size: 1.5rem;">$$\\lim\\limits_{n \\to \\infty} \\frac{2n^2 + 3n + 1}{n^2 + 5}$$</span>` },

            { delay: 4000, html: `<span style="color: #e74c3c;">第3步：分子分母同时除以n²</span><br>

                                 <span>分子每项都除以n²：</span><br>

                                 <span>$$\\frac{2n^2}{n^2} + \\frac{3n}{n^2} + \\frac{1}{n^2}$$</span>` },

            { delay: 6000, html: `<span style="color: #e74c3c;">第4步：化简每一项</span><br>

                                 <span>$$2 + \\frac{3}{n} + \\frac{1}{n^2}$$</span><br>

                                 <span>分母同样处理：$$1 + \\frac{5}{n^2}$$</span>` },

            { delay: 8000, html: `<span style="color: #e74c3c;">第5步：极限规律</span><br>

                                 <span style="color: #27ae60;">当n→∞时：</span><br>

                                 <span>$$\\frac{1}{n} → 0, \\quad \\frac{1}{n^2} → 0$$</span>` },

            { delay: 10000, html: `<span style="color: #e74c3c;">第6步：代入极限值</span><br>

                                  <span style="font-size: 1.8rem; color: #27ae60;">

                                  $$= \\frac{2 + 0 + 0}{1 + 0} = 2$$</span>` },

            { delay: 12000, html: `<div style="background: rgba(46, 204, 113, 0.1); padding: 15px; border-radius: 8px;">

                                  <strong>记忆口诀：</strong><br>

                                  分子分母同除以最高次<br>

                                  看系数比就是极限值！<br>

                                  <span style="color: #e74c3c;">最高次系数比 = 2/1 = 2</span>

                                  </div>` }

        ];



        // 计算步骤动画只播放一次，不循环

        let stepIndex = 0;

        function showNextStep() {

            if (stepIndex < steps.length) {

                const step = steps[stepIndex];

                stepsDiv.append('div')

                    .attr('class', 'formula-step fade-in')

                    .style('margin-top', stepIndex === 0 ? '0' : '20px')

                    .html(step.html);

                

                if (window.MathJax) {

                    MathJax.typesetPromise();

                }

                

                stepIndex++;

                if (stepIndex < steps.length) {

                    // 使用下一个步骤的延迟时间减去当前步骤的延迟时间

                    const nextStep = steps[stepIndex];

                    const delay = nextStep.delay - step.delay;

                    setTimeout(showNextStep, delay / globalAnimationSpeed);

                }

            }

        }

        

        showNextStep();

    }







    function visualizeFunctionLimits(containerId) {

        const container = getContainer(containerId, 'grid');

        if (!container) {

            console.error('Container vis-function-limits not found');

            return;

        }



        const functions = [

            { name: '多项式极限<br>$x^2-2x+1$', fn: x => x*x - 2*x + 1, a: 2, L: 1 },

            { name: '有理函数<br>$\\dfrac{x^2-4}{x-2}$', fn: x => Math.abs(x-2) > 0.01 ? (x*x - 4)/(x - 2) : 4, a: 2, L: 4 },

            { name: '根式函数<br>$\\sqrt{x+1}$', fn: x => Math.sqrt(x + 1), a: 3, L: 2 },

            { name: '三角极限<br>$\\dfrac{\\sin x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sin(x)/x : 1, a: 0, L: 1 },

            { name: '指数极限<br>$e^{-|x|}$', fn: x => Math.exp(-Math.abs(x)), a: 0, L: 1 },

            { name: '对数极限<br>$\\ln(x+1)$', fn: x => Math.log(x + 1), a: Math.E - 1, L: 1 },

            { name: '反三角<br>$\\arctan x$', fn: x => Math.atan(x), a: 0, L: 0 },

            { name: '双曲函数<br>$\\dfrac{\\sinh x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sinh(x)/x : 1, a: 0, L: 1 },

            { name: '分段函数<br>$\\begin{cases} x+2, & x<0 \\\\ x^2, & x\\ge0 \\end{cases}$', fn: x => x < 0 ? x + 2 : x*x, a: 0, L: null },

            { name: '绝对值<br>$|x-1|$', fn: x => Math.abs(x - 1), a: 1, L: 0 },

            { name: '取整函数<br>$\\lfloor x \\rfloor$', fn: x => Math.floor(x), a: 2, L: null },

            { name: '符号函数<br>$\\text{sgn}(x)$', fn: x => Math.sign(x), a: 0, L: null },

            { name: '振荡衰减<br>$x\\sin\\left(\\dfrac{1}{x}\\right)$', fn: x => Math.abs(x) > 0.01 ? x * Math.sin(1/x) : 0, a: 0, L: 0 },

            { name: '复合函数<br>$\\sin(\\cos x)$', fn: x => Math.sin(Math.cos(x)), a: 1, L: Math.sin(Math.cos(1)) },

            { name: '幂指函数<br>$x^x$', fn: x => x > 0 ? Math.pow(x, x) : undefined, a: 1, L: 1 }

        ];



        functions.forEach((func, i) => {

            const drawFunction = (g, width, height) => {

                const range = 2;

                const xMin = func.a - range;

                const xMax = func.a + range;



                const xScale = d3.scaleLinear().domain([xMin, xMax]).range([0, width]);

                

                const testPoints = d3.range(xMin, xMax, 0.1).map(x => func.fn(x)).filter(y => isFinite(y));

                const yExtent = d3.extent(testPoints);

                const yPadding = Math.abs(yExtent[1] - yExtent[0]) * 0.2 || 1;

                const yScale = d3.scaleLinear()

                    .domain([yExtent[0] - yPadding, yExtent[1] + yPadding])

                    .range([height, 0]);



                drawAxes(g, xScale, yScale, width, height);



                const line = d3.line()

                    .x(d => xScale(d.x))

                    .y(d => yScale(d.y))

                    .defined(d => !isNaN(d.y) && isFinite(d.y));



                const data = d3.range(xMin, xMax, 0.05).map(x => ({

                    x: x,

                    y: func.fn(x)

                }));



                const path = g.append('path')

                    .datum(data)

                    .attr('fill', 'none')

                    .attr('stroke', 'var(--primary-color)')

                    .attr('stroke-width', 2)

                    .attr('d', line);



                animatePath(path, 2000, false);



                // 添加极限趋近动画

                setTimeout(() => {

                    animateLimitApproach(g, xScale, yScale, func.fn, func.a, func.L, width, height);

                }, 100);



                if (func.L !== undefined && func.L !== null && !isNaN(func.L) && isFinite(func.L)) {

                    g.append('circle')

                        .attr('cx', xScale(func.a))

                        .attr('cy', yScale(func.L))

                        .attr('r', 4)

                        .attr('fill', 'var(--success-color)');

                }

            };



            const { g, width, height, div } = setup(container, i, func.name, 'both', func.a);

            div.__chartData = { drawFunction, annotationData: { type: 'limit', isSequence: false, approachPoint: func.a, limitValue: func.L, leftLimit: func.L, rightLimit: func.L } };

            drawFunction(g, width, height);

        });

    }





// 第7页：左右极限

function visualizeOneSidedLimits(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) {

        console.error('Container vis-one-sided not found');

        return;

    }

    

    // 创建控制面板

    const controlPanel = document.createElement('div');

    controlPanel.className = 'interactive-panel';

    controlPanel.style.cssText = 'margin-bottom: 20px; text-align: center;';

    

    const title = document.createElement('h3');

    title.textContent = '左右极限演示';

    title.style.cssText = 'margin: 0 0 15px 0; color: var(--primary-color);';

    controlPanel.appendChild(title);

    

    const buttonContainer = document.createElement('div');

    buttonContainer.className = 'button-container';

    buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;';

    controlPanel.appendChild(buttonContainer);

    

    container.appendChild(controlPanel);

    

    // 创建SVG容器

    const svgContainer = document.createElement('div');

    svgContainer.style.cssText = 'width: 100%; height: calc(100% - 80px); position: relative;';

    container.appendChild(svgContainer);

    

    const svg = d3.select(svgContainer)

        .append('svg')

        .attr('width', '100%')

        .attr('height', '100%');

    

    const margins = {top: 40, right: 40, bottom: 60, left: 60};

    const bounds = svgContainer.getBoundingClientRect();

    const width = bounds.width - margins.left - margins.right;

    const height = bounds.height - margins.top - margins.bottom;

    

    const g = svg.append('g')

        .attr('transform', `translate(${margins.left}, ${margins.top})`);

    

    // 添加箭头标记

    svg.append('defs').append('marker')

        .attr('id', 'arrowhead-one-sided')

        .attr('viewBox', '0 -5 10 10')

        .attr('refX', 8)

        .attr('refY', 0)

        .attr('markerWidth', 8)

        .attr('markerHeight', 8)

        .attr('orient', 'auto')

        .append('path')

        .attr('d', 'M0,-5L10,0L0,5')

        .attr('fill', 'var(--danger-color)');

    

    // 创建分段函数示例

    const cases = [

        {

            name: '跳跃间断',

            fnLeft: x => x,

            fnRight: x => x + 2,

            a: 0,

            leftLimit: 0,

            rightLimit: 2

        },

        {

            name: '可去间断',

            fnLeft: x => (x*x - 1)/(x - 1),

            fnRight: x => (x*x - 1)/(x - 1),

            a: 1,

            leftLimit: 2,

            rightLimit: 2

        },

        {

            name: '无穷间断',

            fnLeft: x => -1/x,

            fnRight: x => 1/x,

            a: 0,

            leftLimit: -Infinity,

            rightLimit: Infinity

        }

    ];

    

    // 创建按钮

    cases.forEach((c, i) => {

        const button = document.createElement('button');

        button.className = 'nav-btn';

        button.textContent = c.name;

        button.style.cssText = 'margin: 5px; padding: 8px 16px; border: 1px solid var(--primary-color); background: white; color: var(--primary-color); border-radius: 4px; cursor: pointer; transition: all 0.3s;';

        button.onmouseover = function() {

            this.style.background = 'var(--primary-color)';

            this.style.color = 'white';

        };

        button.onmouseout = function() {

            this.style.background = 'white';

            this.style.color = 'var(--primary-color)';

        };

        button.onclick = () => drawCase(i);

        buttonContainer.appendChild(button);

    });

    

    const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);

    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    

    // 坐标轴

    g.append('g')

        .attr('transform', `translate(0, ${yScale(0)})`)

        .call(d3.axisBottom(xScale));

    

    g.append('g')

        .attr('transform', `translate(${xScale(0)}, 0)`)

        .call(d3.axisLeft(yScale));

    

    function drawCase(index) {

        g.selectAll('.function-path').remove();

        g.selectAll('.limit-marker').remove();

        

        const caseItem = cases[index];

        

        // 左侧函数

        const leftData = d3.range(-3, caseItem.a - 0.01, 0.01)

            .map(x => ({x: x, y: caseItem.fnLeft(x)}))

            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y));

        

        g.append('path')

            .attr('class', 'function-path')

            .datum(leftData)

            .attr('d', line)

            .attr('fill', 'none')

            .attr('stroke', '#e74c3c')

            .attr('stroke-width', 2);

        

        // 右侧函数

        const rightData = d3.range(caseItem.a + 0.01, 3, 0.01)

            .map(x => ({x: x, y: caseItem.fnRight(x)}))

            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);

        

        g.append('path')

            .attr('class', 'function-path')

            .datum(rightData)

            .attr('d', line)

            .attr('fill', 'none')

            .attr('stroke', '#3498db')

            .attr('stroke-width', 2);

        

        // 标记间断点位置

        g.append('line')

            .attr('class', 'limit-marker')

            .attr('x1', xScale(caseItem.a))

            .attr('y1', 0)

            .attr('x2', xScale(caseItem.a))

            .attr('y2', height)

            .attr('stroke', 'gray')

            .attr('stroke-dasharray', '2,2')

            .attr('opacity', 0.5);

        

        // 显示左右极限值

        if (isFinite(caseItem.leftLimit)) {

            g.append('circle')

                .attr('class', 'limit-marker')

                .attr('cx', xScale(caseItem.a))

                .attr('cy', yScale(caseItem.leftLimit))

                .attr('r', 5)

                .attr('fill', 'white')

                .attr('stroke', '#e74c3c')

                .attr('stroke-width', 2);

            

            g.append('text')

                .attr('class', 'limit-marker')

                .attr('x', xScale(caseItem.a) - 60)

                .attr('y', yScale(caseItem.leftLimit))

                .attr('fill', '#e74c3c')

                .text(`左极限: ${caseItem.leftLimit}`);

        }

        

        if (isFinite(caseItem.rightLimit)) {

            g.append('circle')

                .attr('class', 'limit-marker')

                .attr('cx', xScale(caseItem.a))

                .attr('cy', yScale(caseItem.rightLimit))

                .attr('r', 5)

                .attr('fill', 'white')

                .attr('stroke', '#3498db')

                .attr('stroke-width', 2);

            

            g.append('text')

                .attr('class', 'limit-marker')

                .attr('x', xScale(caseItem.a) + 10)

                .attr('y', yScale(caseItem.rightLimit))

                .attr('fill', '#3498db')

                .text(`右极限: ${caseItem.rightLimit}`);

        }

        

        // 添加说明文字

        g.append('text')

            .attr('class', 'limit-marker')

            .attr('x', width / 2)

            .attr('y', height + 30)

            .attr('text-anchor', 'middle')

            .attr('fill', '#34495e')

            .style('font-size', '14px')

            .text(`函数类型: ${caseItem.name} - 观察 x = ${caseItem.a} 处的左右极限`);

    }

    

    drawCase(0);

}



// 第7.1页：左右极限详细演示

function visualizeOneSidedLimitsDetailed(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) {

        console.error('Container vis-one-sided-detailed not found');

        return;

    }



    const cases = [

        {

            name: '左右极限相等<br>$x+1$',

            fnLeft: x => x + 1,

            fnRight: x => x + 1,

            a: 0, L: 1

        },

        {

            name: '跳跃间断<br>$\\begin{cases} x,\\ x<0 \\\\ x+2,\\ x \\ge 0 \\end{cases}$',

            fnLeft: x => x,

            fnRight: x => x + 2,

            a: 0, L: null

        },

        {

            name: '左极限不存在<br>$\\begin{cases} \\dfrac{1}{x},\\ x<0 \\\\ x+1,\\ x \\ge 0 \\end{cases}$',

            fnLeft: x => 1/x,

            fnRight: x => x + 1,

            a: 0, L: null

        },

        {

            name: '右极限不存在<br>$\\begin{cases} x-1,\\ x<1 \\\\ \\dfrac{1}{x-1},\\ x \\ge 1 \\end{cases}$',

            fnLeft: x => x - 1,

            fnRight: x => 1/(x-1),

            a: 1, L: null

        },

        {

            name: '振荡间断<br>$\\sin\\left(\\dfrac{1}{x}\\right)$',

            fnLeft: x => Math.sin(1/x),

            fnRight: x => Math.sin(1/x),

            a: 0, L: null

        },

        {

            name: '可去间断<br>$\\dfrac{x^2-1}{x-1}$',

            fnLeft: x => (x*x - 1)/(x - 1),

            fnRight: x => (x*x - 1)/(x - 1),

            a: 1, L: 2

        },

        {

            name: '无穷间断<br>$\\begin{cases} -\\dfrac{1}{x^2},\\ x<0 \\\\ \\dfrac{1}{x^2},\\ x>0 \\end{cases}$',

            fnLeft: x => -1/(x*x),

            fnRight: x => 1/(x*x),

            a: 0, L: null

        },

        {

            name: '分段连续<br>$\\begin{cases} \\sin x,\\ x<0 \\\\ x,\\ x \\ge 0 \\end{cases}$',

            fnLeft: x => Math.sin(x),

            fnRight: x => x,

            a: 0, L: 0

        },

        {

            name: '指数跳跃<br>$\\begin{cases} e^x,\\ x<0 \\\\ e^x+1,\\ x \\ge 0 \\end{cases}$',

            fnLeft: x => Math.exp(x),

            fnRight: x => Math.exp(x) + 1,

            a: 0, L: null

        },

        {

            name: '对数间断<br>$\\ln|x|$',

            fnLeft: x => Math.log(-x),

            fnRight: x => Math.log(x),

            a: 0, L: null

        },

        {

            name: '三角跳跃<br>$\\begin{cases} \\cos x,\\ x<\\pi/2 \\\\ \\sin x,\\ x \\ge \\pi/2 \\end{cases}$',

            fnLeft: x => Math.cos(x),

            fnRight: x => Math.sin(x),

            a: Math.PI/2, L: null

        },

        {

            name: '幂函数跳跃<br>$\\begin{cases} x^2,\\ x<1 \\\\ x^3+1,\\ x \\ge 1 \\end{cases}$',

            fnLeft: x => Math.pow(x, 2),

            fnRight: x => Math.pow(x, 3) + 1,

            a: 1, L: null

        }

    ];



    cases.forEach((caseItem, i) => {

        const drawFunction = (g, width, height) => {

            const range = 1.5;

            const xScale = d3.scaleLinear()

                .domain([caseItem.a - range, caseItem.a + range])

                .range([0, width]);

            const yScale = d3.scaleLinear()

                .domain([-3, 3])

                .range([height, 0]);



            drawAxes(g, xScale, yScale, width, height);



            const line = d3.line()

                .x(d => xScale(d.x))

                .y(d => yScale(d.y))

                .defined(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);



            const leftData = d3.range(caseItem.a - range, caseItem.a - 0.01, 0.01)

                .map(x => ({x: x, y: caseItem.fnLeft(x)}));



            const leftPath = g.append('path')

                .datum(leftData)

                .attr('fill', 'none')

                .attr('stroke', 'var(--danger-color)')

                .attr('stroke-width', 2)

                .attr('d', line);

            animatePath(leftPath);



            const rightData = d3.range(caseItem.a + 0.01, caseItem.a + range, 0.01)

                .map(x => ({x: x, y: caseItem.fnRight(x)}));



            const rightPath = g.append('path')

                .datum(rightData)

                .attr('fill', 'none')

                .attr('stroke', 'var(--primary-color)')

                .attr('stroke-width', 2)

                .attr('d', line);

            animatePath(rightPath, 2000, false);



            g.append('line')

                .attr('x1', xScale(caseItem.a))

                .attr('y1', 0)

                .attr('x2', xScale(caseItem.a))

                .attr('y2', height)

                .attr('stroke', 'gray')

                .attr('stroke-dasharray', '2,2')

                .attr('opacity', 0.5);



            // 添加双边趋近动画

            setTimeout(() => {

                // 计算左右极限值

                const leftLimit = caseItem.fnLeft(caseItem.a - 0.001);

                const rightLimit = caseItem.fnRight(caseItem.a + 0.001);

                const avgLimit = isFinite(leftLimit) && isFinite(rightLimit) ? (leftLimit + rightLimit) / 2 : (caseItem.L || 0);

                animateLimitApproach(g, xScale, yScale, x => x < caseItem.a ? caseItem.fnLeft(x) : caseItem.fnRight(x), caseItem.a, avgLimit, width, height);

            }, 100);

        };



        let approachVal;

        if (caseItem.a === Math.PI/2) {

            approachVal = 'π/2';

        } else if (caseItem.a === 0) {

            approachVal = '0';

        } else if (caseItem.a === 1) {

            approachVal = '1';

        } else {

            approachVal = caseItem.a.toString();

        }

        const { g, width, height, div } = setup(container, i, caseItem.name, 'both', approachVal);

        div.__chartData = { drawFunction, annotationData: { type: 'limit', isSequence: false, approachPoint: caseItem.a, limitValue: caseItem.L, leftLimit: caseItem.L, rightLimit: caseItem.L } };

        drawFunction(g, width, height);

    });

}



// 第8页：极限的四则运算法则

function visualizeLimitOperations(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) return;



  



const operations = [

    { name: '和<br>$x+x^2$', f: x => x, g: x => x*x, op: (a,b) => a+b },

    { name: '差<br>$x^2-x$', f: x => x*x, g: x => x, op: (a,b) => a-b },

    { name: '积<br>$x \\sin x$', f: x => x, g: x => Math.sin(x), op: (a,b) => a*b },

    { name: '商<br>$x^2/x$', f: x => x*x, g: x => x, op: (a,b) => a/b },

    { name: '数乘<br>$2\\sin x$', f: x => Math.sin(x), g: x => 2, op: (a,b) => a*b },

    { name: '幂<br>$x^2$', f: x => x, g: x => 2, op: (a,b) => Math.pow(a, b) },

    { name: '开方<br>$\\sqrt{x+4}$', f: x => x + 4, g: x => 0, op: (a,b) => Math.sqrt(a) },

    { name: '绝对值<br>$|x-1|$', f: x => x - 1, g: x => 0, op: (a,b) => Math.abs(a) },

    { name: '复合<br>$(x+1)^2$', f: x => x*x, g: x => x+1, op: (a,b) => (b*b) },

    { name: '最大值<br>$\\max(x, 1-x)$', f: x => x, g: x => 1-x, op: (a,b) => Math.max(a,b) },

    { name: '最小值<br>$\\min(x^2, x)$', f: x => x*x, g: x => x, op: (a,b) => Math.min(a,b) },

    { name: '幂指<br>$(x+2)^2$', f: x => x+2, g: x => 2, op: (a,b) => Math.pow(a,b) }

];



operations.forEach((op, i) => {

    const drawFunction = (g, width, height) => {

        const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);

        const yScale = d3.scaleLinear().domain([-2, 4]).range([height, 0]);



        drawAxes(g, xScale, yScale, width, height);



        const data1 = d3.range(-2, 2, 0.05).map(x => ({x: x, y: op.f(x)}));

        const data2 = d3.range(-2, 2, 0.05).map(x => ({x: x, y: op.g(x)}));

        const dataResult = d3.range(-2, 2, 0.05).map(x => ({

            x: x,

            y: op.op(op.f(x), op.g(x))

        })).filter(d => !isNaN(d.y) && isFinite(d.y));



        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y))

            .defined(d => !isNaN(d.y) && isFinite(d.y));



        const path1 = g.append('path')

            .datum(data1)

            .attr('fill', 'none')

            .attr('stroke', 'var(--accent-color)')

            .attr('stroke-width', 1)

            .attr('stroke-dasharray', '3,3')

            .attr('d', line);

        animatePath(path1, 1500);



        const path2 = g.append('path')

            .datum(data2)

            .attr('fill', 'none')

            .attr('stroke', 'var(--primary-color)')

            .attr('stroke-width', 1)

            .attr('stroke-dasharray', '3,3')

            .attr('d', line);

        animatePath(path2, 1500);



        const pathResult = g.append('path')

            .datum(dataResult)

            .attr('fill', 'none')

            .attr('stroke', 'var(--success-color)')

            .attr('stroke-width', 2)

            .attr('d', line);

        animatePath(pathResult, 2000);

    };



    const { g, width, height, div } = setup(container, i, op.name);

    div.__chartData = {

        drawFunction,

        annotationData: {

            type: 'limit',

            isSequence: false,

            approachPoint: 0,

            limitValue: op.op(op.f(0), op.g(0)),

            leftLimit: op.op(op.f(0), op.g(0)),

            rightLimit: op.op(op.f(0), op.g(0))

        }

    };

    drawFunction(g, width, height);

});

}

    

// 第8.1页：极限运算方法

function visualizeLimitMethodsDetailed(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) {

        console.error('Container vis-limit-methods-detailed not found');

        return;

    }



    const methods = [

        { name: '直接代入法<br>$\\frac{x^2+1}{x+2}$', fn: x => (x*x + 1)/(x+2), a: 1, L: 2/3 },

        { name: '因式分解法<br>$\\frac{x^2-1}{x-1}$', fn: x => Math.abs(x-1) > 0.01 ? (x*x - 1)/(x-1) : 2, a: 1, L: 2 },

        { name: '分子有理化<br>$\\frac{\\sqrt{x+1}-1}{x}$', fn: x => Math.abs(x) > 0.01 ? (Math.sqrt(x+1)-1)/x : 0.5, a: 0, L: 0.5 },

        { name: '分母有理化<br>$\\frac{x}{\\sqrt{x+4}-2}$', fn: x => Math.abs(Math.sqrt(x+4)-2) > 0.01 ? x/(Math.sqrt(x+4)-2) : 4, a: 0, L: 4 },

        { name: '无穷大比较法<br>$\\frac{2x^2-3}{3x^2+x}$', fn: x => (2*x*x - 3)/(3*x*x + x), a: 10, L: 2/3 },

        { name: '夹逼定理<br>$x^2\\sin(\\frac{1}{x})$', fn: x => Math.abs(x) > 0.01 ? x*x * Math.sin(1/x) : 0, a: 0, L: 0 },

        { name: '重要极限 I<br>$\\frac{\\sin x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sin(x)/x : 1, a: 0, L: 1 },

        { name: '重要极限 II<br>$\\left(1+\\frac{1}{x}\\right)^x$', fn: x => x > 0.1 ? Math.pow(1+1/x, x) : Math.E, a: 10, L: Math.E },

        { name: '洛必达法则<br>$\\frac{e^x-1}{\\sin x}$', fn: x => Math.abs(x) > 0.001 ? (Math.exp(x)-1)/Math.sin(x) : 1, a: 0, L: 1 },

        { name: '等价无穷小<br>$\\frac{\\tan(2x)}{\\ln(1+x)}$', fn: x => Math.abs(x) > 0.01 ? Math.tan(2*x) / Math.log(1+x) : 2, a: 0, L: 2 },

        { name: '通分法<br>$\\frac{1}{x-1}-\\frac{2}{x^2-1}$', fn: x => Math.abs(x-1) > 0.01 ? 1/(x-1) - 2/(x*x-1) : 0.5, a: 1, L: 0.5 },

        { name: '变量替换法<br>$\\frac{e^x-1}{e^x+1}$', fn: x => (Math.exp(x) - 1)/(Math.exp(x) + 1), a: 0, L: 0 }

    ];



    methods.forEach((method, i) => {

        const drawFunction = (g, width, height) => {

            let xDomain, data;

            if (method.a >= 10) {

                xDomain = [1, 20];

                data = d3.range(1, 20, 0.5).map(x => ({x: x, y: method.fn(x)}));

            } else {

                xDomain = [method.a - 2, method.a + 2];

                data = d3.range(xDomain[0], xDomain[1], 0.02)

                    .filter(x => Math.abs(x - method.a) > 1e-6)

                    .map(x => ({x: x, y: method.fn(x)}));

            }



            const yExtent = d3.extent(data.filter(d => isFinite(d.y)), d => d.y);

            const yPadding = Math.abs(yExtent[1] - yExtent[0]) * 0.2 || 1;

            const yDomain = [yExtent[0] - yPadding, yExtent[1] + yPadding];



            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);

            const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);



            drawAxes(g, xScale, yScale, width, height);



            const line = d3.line()

                .x(d => xScale(d.x))

                .y(d => yScale(d.y))

                .defined(d => !isNaN(d.y) && isFinite(d.y));



            const path = g.append('path')

                .datum(data.filter(d => isFinite(d.y)))

                .attr('fill', 'none')

                .attr('stroke', 'var(--primary-color)')

                .attr('stroke-width', 2)

                .attr('d', line);

            animatePath(path, 2000, false);



            // 添加极限趋近动画

            setTimeout(() => {

                const approachVal = method.a >= 10 ? Infinity : method.a;

                animateLimitApproach(g, xScale, yScale, method.fn, approachVal, method.L, width, height);

            }, 100);



            if (method.a < 10) {

                g.append('circle')

                    .attr('cx', xScale(method.a))

                    .attr('cy', yScale(method.L))

                    .attr('r', 4)

                    .attr('fill', 'white')

                    .attr('stroke', 'var(--success-color)')

                    .attr('stroke-width', 2);

            }

        };



        const { g, width, height, div } = setup(container, i, method.name, 'both', method.a);

        div.__chartData = {

            drawFunction,

            annotationData: {

                type: 'limit',

                isSequence: false,

                approachPoint: method.a,

                limitValue: method.L,

                leftLimit: method.L,

                rightLimit: method.L

            }

        };

        drawFunction(g, width, height);

    });

}



// 第9页：极限计算方法

function visualizeLimitMethods(containerId) {

    const setup = setupD3(containerId);

    if (!setup) return;

    const { g, width, height } = setup;

    

    const panel = d3.select('#vis-limit-methods')

        .append('div')

        .attr('class', 'interactive-panel')

        .style('width', '50%')

        .style('fill', 'rgba(255, 255, 255, 0)');

 

    

    const methods = [

        {

            name: '因式分解法',

            problem: '$$\\lim\\limits_{x \\to 1} \\frac{x^2 - 1}{x - 1}$$',

            steps: [

                '分解: $\\frac{(x+1)(x-1)}{x-1}$',

                '约分: $x+1$',

                '代入: $1+1 = 2$'

            ],

            fn: x => Math.abs(x-1) > 0.01 ? (x*x - 1)/(x - 1) : 2,

            a: 1,

            L: 2

        },

        {

            name: '有理化法',

            problem: '$$\\lim\\limits_{x \\to 0} \\frac{\\sqrt{x+1}-1}{x}$$',

            steps: [

                '分子分母同乘 $\\sqrt{x+1}+1$',

                '= $\\frac{(x+1)-1}{x(\\sqrt{x+1}+1)}$',

                '= $\\frac{1}{\\sqrt{x+1}+1} = \\frac{1}{2}$'

            ],

            fn: x => Math.abs(x) > 0.01 ? (Math.sqrt(x+1)-1)/x : 0.5,

            a: 0,

            L: 0.5

        },

        {

            name: '等价无穷小',

            problem: '$$\\lim\\limits_{x \\to 0} \\frac{\\sin x}{x}$$',

            steps: [

                '当 $x \\to 0$ 时',

                '$\\sin x \\sim x$',

                '极限 = 1'

            ],

            fn: x => Math.abs(x) > 0.001 ? Math.sin(x)/x : 1,

            a: 0,

            L: 1

        }

    ];

    

    let currentMethod = 0;

    

    const buttonContainer = panel.append('div')

        .style('display', 'flex')

        .style('gap', '10px')

        .style('margin-bottom', '20px');

    

    methods.forEach((method, i) => {

        buttonContainer.append('button')

            .attr('class', 'nav-btn')

            .text(method.name)

            .on('click', () => showMethod(i));

    });

    

    const stepsContainer = panel.append('div')

        .style('background', 'rgba(0,0,0,0.05)')

        .style('padding', '20px')

        .style('border-radius', '8px');

    

    const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);

    const yScale = d3.scaleLinear().domain([-1, 4]).range([height - 100, 0]);

    

    // 坐标轴

    g.append('g')

        .attr('transform', `translate(0, ${yScale(0)})`)

        .call(d3.axisBottom(xScale));

    

    g.append('g')

        .attr('transform', `translate(${xScale(0)}, 0)`)

        .call(d3.axisLeft(yScale));

    

    function showMethod(index) {

        currentMethod = index;

        const method = methods[index];

        

        // 清除之前的内容

        stepsContainer.selectAll('*').remove();

        g.selectAll('.method-graph').remove();

        

        // 显示问题

        stepsContainer.append('div')

            .style('font-size', '1.5rem')

            .style('margin-bottom', '20px')

            .html(method.problem);

        

        // 逐步显示步骤 - 只播放一次，不循环

        let stepIndex = 0;

        function showMethodStep() {

            if (stepIndex < method.steps.length) {

                const step = method.steps[stepIndex];

                stepsContainer.append('div')

                    .attr('class', 'formula-step fade-in')

                    .style('margin', '10px 0')

                    .style('padding-left', '20px')

                    .html(`步骤 ${stepIndex+1}: ${step}`);

                

                if (window.MathJax) {

                    MathJax.typesetPromise();

                }

                

                stepIndex++;

                if (stepIndex < method.steps.length) {

                    setTimeout(showMethodStep, 1000 / globalAnimationSpeed);

                }

            }

        }

        

        showMethodStep();

        

        // 绘制函数

        const data = d3.range(-2, 2, 0.01)

            .map(x => ({x: x, y: method.fn(x)}))

            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y));

        

        const path = g.append('path')

            .attr('class', 'method-graph')

            .datum(data)

            .attr('d', line)

            .attr('fill', 'none')

            .attr('stroke', 'var(--primary-color)')

            .attr('stroke-width', 2);

        

        // 标记极限点

        g.append('circle')

            .attr('class', 'method-graph')

            .attr('cx', xScale(method.a))

            .attr('cy', yScale(method.L))

            .attr('r', 6)

            .attr('fill', 'var(--success-color)');

        

        // 动画

        const totalLength = path.node().getTotalLength();

        path

            .attr('stroke-dasharray', totalLength + ' ' + totalLength)

            .attr('stroke-dashoffset', totalLength)

            .transition()

            .duration(2000 / globalAnimationSpeed)

            .ease(d3.easeLinear)

            .attr('stroke-dashoffset', 0);

    }

    

    showMethod(0);

}



// 第10页：第一重要极限

function visualizeImportantLimit1(containerId) {

    const container = getContainer(containerId, 'flex');

    if (!container) return;

    

    // 创建左右分栏布局

    const mainDiv = d3.select(container)

        .append('div')

        .style('display', 'flex')

        .style('height', '100%');

    

    // 左侧：图形展示

    const leftDiv = mainDiv.append('div')

        .style('flex', '1')

        .style('padding', '20px');

    

    // 右侧：练习题

    const rightDiv = mainDiv.append('div')

        .style('flex', '0.5')

        .style('padding', '20px')

        .style('background', 'rgba(52, 152, 219, 0.05)')

        .style('border-radius', '10px')

        .style('margin', '20px');

    

    rightDiv.append('h3')

        .style('color', '#3498db')

        .text('试试看：');

    

    // 练习题组

    const exercises = [

        { 

            problem: '$$\\lim_{x→0} \\frac{\\sin 2x}{x}$$',

            hint: '把2x看作整体',

            answer: '2'

        },

        { 

            problem: '$$\\lim_{x→0} \\frac{\\sin 3x}{2x}$$',

            hint: '分子分母都有系数',

            answer: '3/2'

        },

        { 

            problem: '$$\\lim_{x→0} \\frac{\\sin 5x}{\\sin 2x}$$',

            hint: '上下同除以x',

            answer: '5/2'

        }

    ];

    

    exercises.forEach((ex, i) => {

        const exDiv = rightDiv.append('div')

            .style('margin', '20px 0')

            .style('padding', '15px')

            .style('background', 'white')

            .style('border-radius', '8px');

        

        exDiv.append('div')

            .html(`题${i+1}：${ex.problem}`);

        

        const hintBtn = exDiv.append('button')

            .style('margin', '10px 5px')

            .style('padding', '5px 10px')

            .style('background', '#f39c12')

            .style('color', 'white')

            .style('border', 'none')

            .style('border-radius', '4px')

            .style('cursor', 'pointer')

            .text('提示')

            .on('click', function() {

                d3.select(this.parentNode)

                    .append('div')

                    .style('color', '#f39c12')

                    .style('margin-top', '5px')

                    .text(ex.hint);

            });

        

        const answerBtn = exDiv.append('button')

            .style('margin', '10px 5px')

            .style('padding', '5px 10px')

            .style('background', '#27ae60')

            .style('color', 'white')

            .style('border', 'none')

            .style('border-radius', '4px')

            .style('cursor', 'pointer')

            .text('答案')

            .on('click', function() {

                d3.select(this.parentNode)

                    .append('div')

                    .style('color', '#27ae60')

                    .style('margin-top', '5px')

                    .style('font-weight', 'bold')

                    .text(`答案：${ex.answer}`);

            });

    });

    

    // 左侧图形代码

    const titleDiv = leftDiv

        .append('div')

        .style('text-align', 'center')

        .style('font-size', '20px')

        .style('color', 'black')

        .style('margin-bottom', '10px')

        .html('$$\\lim\\limits_{x \\to 0} \\frac{\\sin x}{x} = 1$$');

    

    const width = 500;

    const height = 300;

    const margin = { top: 20, right: 50, bottom: 50, left: 50 };

    

    const svg = leftDiv

        .append('svg')

        .attr('width', width + margin.left + margin.right)

        .attr('height', height + margin.top + margin.bottom);

    

    const g = svg.append('g')

        .attr('transform', `translate(${margin.left}, ${margin.top})`);

    

    const xScale = d3.scaleLinear().domain([-Math.PI, Math.PI]).range([0, width]);

    const yScale = d3.scaleLinear().domain([-0.5, 1.5]).range([height, 0]);

    

    // 坐标轴

    g.append('g')

        .attr('transform', `translate(0, ${yScale(0)})`)

        .call(d3.axisBottom(xScale).tickFormat(d => {

            if (d === 0) return '0';

            if (d === Math.PI) return 'π';

            if (d === -Math.PI) return '-π';

            return d.toFixed(1);

        }));

    

    g.append('g')

        .call(d3.axisLeft(yScale));

    

    // 渲染MathJax

    if (window.MathJax) {

        MathJax.typesetPromise([titleDiv.node()]);

    }

    

    // 绘制sin(x)/x

    const data = [];

    for (let x = -Math.PI; x <= Math.PI; x += 0.01) {

        if (Math.abs(x) > 0.001) {

            data.push({ x: x, y: Math.sin(x) / x });

        }

    }

    

    const line = d3.line()

        .x(d => xScale(d.x))

        .y(d => yScale(d.y));

    

    g.append('path')

        .datum(data)

        .attr('d', line)

        .attr('fill', 'none')

        .attr('stroke', 'cyan')

        .attr('stroke-width', 3);

    

    // 极限值线 y=1

    g.append('line')

        .attr('x1', 0)

        .attr('x2', width)

        .attr('y1', yScale(1))

        .attr('y2', yScale(1))

        .attr('stroke', 'darkgreen')

        .attr('stroke-width', 6)

        .attr('stroke-dasharray', '5,5');

    

    g.append('text')

        .attr('x', width - 90)

        .attr('y', yScale(1) - 25)

        .attr('fill', 'darkgreen')

        .style('font-size', '24px')

        .text('y = 1');

    

    // x=0处的极限点

    g.append('circle')

        .attr('cx', xScale(0))

        .attr('cy', yScale(1))

        .attr('r', 6)

        .attr('fill', 'red')

        .attr('stroke', 'black')

        .attr('stroke-width', 2);

}



// 第11页：第二重要极限

function visualizeImportantLimit2(containerId) {

    const container = getContainer(containerId, 'flex');

    if (!container) return;

    

    // 创建主容器，确保垂直布局

    const mainDiv = d3.select(container)

        .append('div')

        .style('display', 'flex')

        .style('flex-direction', 'column')

        .style('align-items', 'center')

        .style('width', '100%');

    

    // 标题容器

    const titleDiv = mainDiv

        .append('div')

        .style('text-align', 'center')

        .style('font-size', '20px')

        .style('color', 'black')

        .style('margin-bottom', '10px')

        .style('width', '100%')

        .html('$$\\lim\\limits_{x \\to \\infty} \\left(1+\\frac{1}{x}\\right)^x = e$$');

    

    // 图表容器

    const chartDiv = mainDiv

        .append('div')

        .style('width', '100%')

        .style('display', 'flex')

        .style('justify-content', 'center');

    

    const width = 600;

    const height = 400;

    const margin = { top: 20, right: 50, bottom: 50, left: 50 };

    

    const svg = chartDiv

        .append('svg')

        .attr('width', width + margin.left + margin.right)

        .attr('height', height + margin.top + margin.bottom);

    

    const g = svg.append('g')

        .attr('transform', `translate(${margin.left}, ${margin.top})`);

    

    const xScale = d3.scaleLog().domain([1, 100]).range([0, width]);

    const yScale = d3.scaleLinear().domain([2, 3]).range([height, 0]);

    

    // 坐标轴

    g.append('g')

        .attr('transform', `translate(0, ${height})`)

        .call(d3.axisBottom(xScale).tickFormat(d => {

            if (d === 1) return '1';

            if (d === 10) return '10';

            if (d === 100) return '100';

            return d.toString();

        }));

    

    g.append('g')

        .call(d3.axisLeft(yScale));

    

    // 渲染MathJax

    if (window.MathJax) {

        MathJax.typesetPromise([titleDiv.node()]);

    }

    

    // 绘制(1+1/x)^x - 带动画效果

    const data = [];

    for (let x = 1; x <= 100; x *= 1.1) {

        data.push({ x: x, y: Math.pow(1 + 1/x, x) });

    }

    

    const line = d3.line()

        .x(d => xScale(d.x))

        .y(d => yScale(d.y));

    

    const path = g.append('path')

        .datum(data)

        .attr('d', line)

        .attr('fill', 'none')

        .attr('stroke', 'lime')

        .attr('stroke-width', 3);

    

    // 路径动画

    const totalLength = path.node().getTotalLength();

    path.attr('stroke-dasharray', totalLength + ' ' + totalLength)

        .attr('stroke-dashoffset', totalLength)

        .transition()

        .duration(2000)

        .attr('stroke-dashoffset', 0);

    

    // e值线 - 延迟出现

    const eLine = g.append('line')

        .attr('x1', 0)

        .attr('x2', width)

        .attr('y1', yScale(Math.E))

        .attr('y2', yScale(Math.E))

        .attr('stroke', 'orange')

        .attr('stroke-width', 6)

        .attr('stroke-dasharray', '5,5')

        .attr('opacity', 0);

    

    eLine.transition()

        .delay(1000)

        .duration(1000)

        .attr('opacity', 1);

    

    const eLabel = g.append('text')

        .attr('x', width - 120)

        .attr('y', yScale(Math.E) - 15)

        .attr('fill', 'orange')

        .style('font-size', '24px')

        .style('opacity', 0)

        .text(`e ≈ ${Math.E.toFixed(5)}`);

    

    eLabel.transition()

        .delay(1500)

        .duration(1000)

        .style('opacity', 1);

    

    // 添加数值表格 - 带动画和公式渲染

    const table = g.append('g')

        .attr('transform', `translate(50, 50)`)

        .style('opacity', 0);

    

    table.append('rect')

        .attr('width', 250)

        .attr('height', 180)

        .attr('fill', 'rgba(255, 255, 255, 0)')

        .attr('stroke', 'black')

        .attr('stroke-width', 2)

        .attr('rx', 5);

    

    const tableValues = [

        { x: 1, y: Math.pow(1 + 1/1, 1) },

        { x: 10, y: Math.pow(1 + 1/10, 10) },

        { x: 100, y: Math.pow(1 + 1/100, 100) },

        { x: 1000, y: Math.pow(1 + 1/1000, 1000) },

        { x: 10000, y: Math.pow(1 + 1/10000, 10000) }

    ];

    

    // 表格标题 - 使用MathJax公式

    const tableTitle = table.append('foreignObject')

        .attr('x', 10)

        .attr('y', 5)

        .attr('width', 230)

        .attr('height', 80);

    

    tableTitle.append('xhtml:div')

        .style('text-align', 'center')

        .style('font-size', '10px')

        .style('font-weight', 'bold')

        .html('$$\\left(1+\\frac{1}{x}\\right)^x$$');

    

    // 表格数据行 - 逐行动画出现

    tableValues.forEach((val, i) => {

        const row = table.append('g')

            .style('opacity', 0);

        

        // x值

        const xLabel = row.append('foreignObject')

            .attr('x', 10)

            .attr('y', 40 + i * 25)

            .attr('width', 80)

            .attr('height', 25);

        

        xLabel.append('xhtml:div')

            .style('font-size', '12px')

            .html(`$$x=${val.x}$$`);

        

        // 分隔符

        row.append('text')

            .attr('x', 90)

            .attr('y', 55 + i * 25)

            .attr('fill', 'black')

            .style('font-size', '12px')

            .text('→');

        

        // 计算结果

        row.append('text')

            .attr('x', 110)

            .attr('y', 55 + i * 25)

            .attr('fill', 'darkgreen')

            .style('font-size', '12px')

            .style('font-weight', 'bold')

            .text(`${val.y.toFixed(6)}`);

        

        // 逐行出现动画

        row.transition()

            .delay(2000 + i * 300)

            .duration(500)

            .style('opacity', 1);

    });

    

    // 表格整体出现动画

    table.transition()

        .delay(1800)

        .duration(500)

        .style('opacity', 1)

        .on('end', () => {

            // 渲染表格中的MathJax

            if (window.MathJax) {

                MathJax.typesetPromise([table.node()]);

            }

        });

    

    // 添加极限值点 - 最后出现

    const limitPoint = g.append('circle')

        .attr('cx', xScale(100))

        .attr('cy', yScale(Math.E))

        .attr('r', 0)

        .attr('fill', 'red')

        .attr('stroke', 'black')

        .attr('stroke-width', 2);

    

    limitPoint.transition()

        .delay(3000)

        .duration(800)

        .attr('r', 8)

        .transition()

        .duration(300)

        .attr('r', 6);

    

    // 添加收敛动画提示

    const convergenceText = g.append('text')

        .attr('x', width / 2)

        .attr('y', height - 35)

        .attr('text-anchor', 'middle')

        .attr('fill', 'darkblue')

        .style('font-size', '16px')

        .style('font-weight', 'bold')

        .style('opacity', 0)

        .text('当 x → ∞ 时，函数值收敛到 e');

    

    convergenceText.transition()

        .delay(3500)

        .duration(1000)

        .style('opacity', 1);

}



// 第11.1页：两个重要极限

function visualizeImportantLimitsDetailed(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) {

        console.error('Container vis-important-limits-detailed not found');

        return;

    }



    const limits = [

        { name: '重要极限 I<br>$\\frac{\\sin x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sin(x)/x : 1, center: 0, L: 1 },

        { name: '变形 I<br>$\\frac{\\tan x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.tan(x)/x : 1, center: 0, L: 1 },

        { name: '变形 II<br>$\\frac{1-\\cos x}{x^2}$', fn: x => Math.abs(x) > 0.001 ? (1-Math.cos(x))/(x*x) : 0.5, center: 0, L: 0.5 },

        { name: '变形 III<br>$\\frac{\\sin 2x}{x}$', fn: x => Math.abs(x) > 0.001 ? Math.sin(2*x)/x : 2, center: 0, L: 2 },

        { name: '变形 IV<br>$\\frac{\\arcsin x}{x}$', fn: x => Math.abs(x) > 0.001 && Math.abs(x) <= 1 ? Math.asin(x)/x : 1, center: 0, L: 1 },

        { name: '重要极限 II<br>$\\left(1+\\frac{1}{x}\\right)^x$', fn: x => x > 0.1 ? Math.pow(1+1/x, x) : Math.E, center: Infinity, L: Math.E },

        { name: '变形 I<br>$(1+x)^{\\frac{1}{x}}$', fn: x => Math.abs(x) > 0.01 && x > -1 ? Math.pow(1+x, 1/x) : Math.E, center: 0, L: Math.E },

        { name: '变形 II<br>$\\left(1+\\frac{2}{x}\\right)^x$', fn: x => x > 0.1 ? Math.pow(1+2/x, x) : Math.exp(2), center: Infinity, L: Math.exp(2) },

        { name: '变形 III<br>$\\left(1-\\frac{1}{x}\\right)^x$', fn: x => x > 1 ? Math.pow(1-1/x, x) : 1/Math.E, center: Infinity, L: 1/Math.E },

        { name: '变形 IV<br>$\\frac{\\ln(1+x)}{x}$', fn: x => Math.abs(x) > 0.001 && x > -1 ? Math.log(1+x)/x : 1, center: 0, L: 1 },

        { name: '变形 V<br>$\\frac{e^x-1}{x}$', fn: x => Math.abs(x) > 0.001 ? (Math.exp(x)-1)/x : 1, center: 0, L: 1 },

        { name: '变形 VI<br>$\\frac{2^x-1}{x}$', fn: x => Math.abs(x) > 0.001 ? (Math.pow(2,x)-1)/x : Math.log(2), center: 0, L: Math.log(2) }

    ];



    limits.forEach((limit, i) => {

        const drawFunction = (g, width, height) => {

            let xDomain, data;

            if (limit.center === 0) {

                xDomain = [-1, 1];

                data = d3.range(-1, 1, 0.01).filter(x => Math.abs(x) > 0.01)

                    .map(x => ({x: x, y: limit.fn(x)}));

            } else {

                xDomain = [1, 10];

                data = d3.range(1, 10, 0.1)

                    .map(x => ({x: x, y: limit.fn(x)}));

            }



            const yExtent = d3.extent(data, d => d.y);

            const yScale = d3.scaleLinear()

                .domain([Math.min(yExtent[0] - 0.5, limit.L - 1), Math.max(yExtent[1] + 0.5, limit.L + 1)])

                .range([height, 0]);

            const xScale = d3.scaleLinear().domain(xDomain).range([0, width]);



            drawAxes(g, xScale, yScale, width, height);



            const line = d3.line()

                .x(d => xScale(d.x))

                .y(d => yScale(d.y))

                .defined(d => !isNaN(d.y) && isFinite(d.y));



            const path = g.append('path')

                .datum(data)

                .attr('fill', 'none')

                .attr('stroke', 'var(--primary-color)')

                .attr('stroke-width', 2)

                .attr('d', line);

            animatePath(path, 2000, false);



            // 添加重要极限的特殊动画处理

            setTimeout(() => {

                const approachVal = limit.center === 0 ? 0 : (limit.center === Infinity ? Infinity : limit.center);

                animateLimitApproach(g, xScale, yScale, limit.fn, approachVal, limit.L, width, height);

            }, 100);

        };



        const approachVal = limit.center === 0 ? '0' : (limit.center === Infinity ? '∞' : limit.center.toString());

        const { g, width, height, div } = setup(container, i, limit.name, 'both', approachVal);

        div.__chartData = {

            drawFunction,

            annotationData: {

                type: 'limit',

                isSequence: false,

                approachPoint: limit.center,

                limitValue: limit.L,

                leftLimit: limit.L,

                rightLimit: limit.L

            }

        };

        drawFunction(g, width, height);

    });

}





// 第12页：无穷小与无穷大

function visualizeInfinitesimalInfinity(containerId) {

    const setup = setupD3(containerId);

    if (!setup) return;

    const { g, width, height } = setup;

    

    const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);

    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    

    // 坐标轴

    g.append('g')

        .attr('transform', `translate(0, ${yScale(0)})`)

        .call(d3.axisBottom(xScale));

    

    g.append('g')

        .attr('transform', `translate(${xScale(0)}, 0)`)

        .call(d3.axisLeft(yScale));

    

    // 无穷小函数

    const infinitesimals = [

        { fn: x => x, color: '#3498db', label: 'x' },

        { fn: x => x*x, color: '#2ecc71', label: 'x²' },

        { fn: x => x*x*x, color: '#e74c3c', label: 'x³' }

    ];

    

    infinitesimals.forEach(item => {

        const data = d3.range(-2, 2, 0.01)

            .map(x => ({x: x, y: item.fn(x)}))

            .filter(d => !isNaN(d.y) && isFinite(d.y));

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y));

        

        g.append('path')

            .datum(data)

            .attr('d', line)

            .attr('fill', 'none')

            .attr('stroke', item.color)

            .attr('stroke-width', 2);

    });

    

    // 无穷大函数 1/x

    const infinityData1 = d3.range(-2, -0.05, 0.01)

        .map(x => ({x: x, y: Math.min(Math.max(1/x, -5), 5)}));

    const infinityData2 = d3.range(0.05, 2, 0.01)

        .map(x => ({x: x, y: Math.min(Math.max(1/x, -5), 5)}));

    

    const line = d3.line()

        .x(d => xScale(d.x))

        .y(d => yScale(d.y));

    

    g.append('path')

        .datum(infinityData1)

        .attr('d', line)

        .attr('fill', 'none')

        .attr('stroke', 'orange')

        .attr('stroke-width', 2);

    

    g.append('path')

        .datum(infinityData2)

        .attr('d', line)

        .attr('fill', 'none')

        .attr('stroke', 'orange')

        .attr('stroke-width', 2);

    

    // 图例

    const legend = g.append('g')

        .attr('transform', `translate(${width - 150}, 30)`);

    

    legend.append('rect')

        .attr('width', 140)

        .attr('height', 120)

        .attr('fill', 'rgba(0, 0, 0, 0.7)')

        .attr('stroke', 'white')

        .attr('rx', 5);

    

    const items = [

        { color: '#3498db', text: 'x (一阶无穷小)' },

        { color: '#2ecc71', text: 'x² (二阶无穷小)' },

        { color: '#e74c3c', text: 'x³ (三阶无穷小)' },

        { color: 'orange', text: '1/x (无穷大)' }

    ];

    

    items.forEach((item, i) => {

        legend.append('line')

            .attr('x1', 10)

            .attr('x2', 30)

            .attr('y1', 25 + i * 25)

            .attr('y2', 25 + i * 25)

            .attr('stroke', item.color)

            .attr('stroke-width', 2);

        

        legend.append('text')

            .attr('x', 35)

            .attr('y', 30 + i * 25)

            .attr('fill', 'white')

            .style('font-size', '11px')

            .text(item.text);

    });

}



// 第13页：无穷小的比较

function visualizeInfinitesimalComparison(containerId) {

    const setup = setupD3(containerId);

    if (!setup) return;

    const { g, width, height } = setup;

    

    const panel = d3.select('#vis-infinitesimal-comparison')

        .append('div')

        .attr('class', 'interactive-panel draggable-panel');

    

    panel.append('h3').text('无穷小阶的比较');

    

    // 添加拖拽功能

    let isDragging = false;

    let dragOffset = { x: 0, y: 0 };

    

    // 鼠标按下事件

    panel.on('mousedown', function(event) {

        // 只在标题区域触发拖拽

        if (event.target.tagName === 'H3') {

            isDragging = true;

            const rect = this.getBoundingClientRect();

            dragOffset.x = event.clientX - rect.left;

            dragOffset.y = event.clientY - rect.top;

            

            // 添加拖拽样式

            d3.select(this).classed('dragging', true);

            

            // 阻止默认行为

            event.preventDefault();

        }

    });

    

    // 鼠标移动事件

    d3.select(document).on('mousemove.drag', function(event) {

        if (isDragging) {

            const panelNode = panel.node();

            const containerRect = panelNode.parentElement.getBoundingClientRect();

            

            // 计算新位置

            let newX = event.clientX - containerRect.left - dragOffset.x;

            let newY = event.clientY - containerRect.top - dragOffset.y;

            

            // 限制在容器范围内

            const panelRect = panelNode.getBoundingClientRect();

            newX = Math.max(0, Math.min(newX, containerRect.width - panelRect.width));

            newY = Math.max(0, Math.min(newY, containerRect.height - panelRect.height));

            

            // 应用新位置

            panelNode.style.left = newX + 'px';

            panelNode.style.top = newY + 'px';

        }

    });

    

    // 鼠标释放事件

    d3.select(document).on('mouseup.drag', function() {

        if (isDragging) {

            isDragging = false;

            d3.select(panel.node()).classed('dragging', false);

        }

    });

    

    // 创建滑块控制x的值

    const sliderContainer = panel.append('div')

        .attr('class', 'slider-container');

    

    sliderContainer.append('label').text('x值: ');

    const valueDisplay = sliderContainer.append('span')

        .attr('class', 'value-display')

        .text('0.5');

    

    const slider = sliderContainer.append('input')

        .attr('type', 'range')

        .attr('class', 'slider')

        .attr('min', '0.01')

        .attr('max', '1')

        .attr('step', '0.01')

        .attr('value', '0.5');

    

    // 比较表格

    const table = panel.append('table')

        .style('width', '100%')

        .style('margin-top', '20px');

    

    const functions = [

        { name: 'x', fn: x => x, order: 1 },

        { name: 'x²', fn: x => x*x, order: 2 },

        { name: 'x³', fn: x => x*x*x, order: 3 },

        { name: 'sin(x)', fn: x => Math.sin(x), order: 1 },

        { name: '1-cos(x)', fn: x => 1 - Math.cos(x), order: 2 }

    ];

    

    // 表头

    const header = table.append('tr');

    header.append('th').text('函数');

    header.append('th').text('值');

    header.append('th').text('阶');

    

    const rows = functions.map(f => {

        const row = table.append('tr');

        row.append('td').text(f.name);

        row.append('td').attr('class', 'value-cell').text('');

        row.append('td').text(f.order);

        return row;

    });

    

    // 图形区域

    const xScale = d3.scaleLinear().domain([0, 1]).range([0, width]);

    const yScale = d3.scaleLinear().domain([0, 1]).range([height - 50, 0]);

    

    // 坐标轴

    g.append('g')

        .attr('transform', `translate(0, ${height - 50})`)

        .call(d3.axisBottom(xScale));

    

    g.append('g')

        .call(d3.axisLeft(yScale));

    

    // 绘制函数

    functions.forEach((f, i) => {

        const data = d3.range(0, 1, 0.01)

            .map(x => ({x: x, y: f.fn(x)}));

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y));

        

        g.append('path')

            .datum(data)

            .attr('d', line)

            .attr('fill', 'none')

            .attr('stroke', d3.schemeCategory10[i])

            .attr('stroke-width', 2);

    });

    

    // 更新函数

    function update(x) {

        valueDisplay.text(x);

        

        rows.forEach((row, i) => {

            const value = functions[i].fn(x);

            row.select('.value-cell').text(value.toFixed(6));

        });

        

        // 标记当前x位置

        g.selectAll('.current-line').remove();

        g.append('line')

            .attr('class', 'current-line')

            .attr('x1', xScale(x))

            .attr('x2', xScale(x))

            .attr('y1', 0)

            .attr('y2', height - 50)

            .attr('stroke', 'red')

            .attr('stroke-dasharray', '3,3');

        

        // 标记各函数值

        g.selectAll('.current-point').remove();

        functions.forEach((f, i) => {

            g.append('circle')

                .attr('class', 'current-point')

                .attr('cx', xScale(x))

                .attr('cy', yScale(f.fn(x)))

                .attr('r', 4)

                .attr('fill', d3.schemeCategory10[i]);

        });

    }

    

    slider.on('input', function() {

        update(+this.value);

    });

    

    update(0.5);

}



// 第14页：等价无穷小

function visualizeEquivalentInfinitesimal(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) return;

    

    const pairs = [

        { name: '正弦<br>$\\sin x \\sim x$', f1: Math.sin, f2: x => x },

        { name: '正切<br>$\\tan x \\sim x$', f1: Math.tan, f2: x => x },

        { name: '余弦<br>$1-\\cos x \\sim \\frac{x^2}{2}$', f1: x => 1-Math.cos(x), f2: x => x*x/2 },

        { name: '反正弦<br>$\\arcsin x \\sim x$', f1: Math.asin, f2: x => x },

        { name: '反正切<br>$\\arctan x \\sim x$', f1: Math.atan, f2: x => x },

        { name: '指数<br>$e^x-1 \\sim x$', f1: x => Math.exp(x)-1, f2: x => x },

        { name: '对数<br>$\\ln(1+x) \\sim x$', f1: x => Math.log(1+x), f2: x => x },

        { name: '幂函数<br>$(1+x)^2-1 \\sim 2x$', f1: x => Math.pow(1+x, 2)-1, f2: x => 2*x },

        { name: '双曲正弦<br>$\\sinh x \\sim x$', f1: x => Math.sinh(x), f2: x => x },

        { name: '高阶 I<br>$\\sin(x^2) \\sim x^2$', f1: x => Math.sin(x*x), f2: x => x*x },

        { name: '高阶 II<br>$x-\\sin x \\sim \\frac{x^3}{6}$', f1: x => x-Math.sin(x), f2: x => x*x*x/6 },

        { name: '高阶 III<br>$\\tan x-x \\sim \\frac{x^3}{3}$', f1: x => Math.tan(x)-x, f2: x => x*x*x/3 }

    ];

    

    pairs.forEach((pair, i) => {

        const drawFunction = (g, width, height) => {

            const xScale = d3.scaleLinear().domain([-0.5, 0.5]).range([0, width]);

            const yScale = d3.scaleLinear().domain([-0.3, 0.3]).range([height, 0]);



            drawAxes(g, xScale, yScale, width, height);



        const data1 = d3.range(-0.5, 0.5, 0.01)

            .map(x => ({x: x, y: pair.f1(x)}))

            .filter(d => !isNaN(d.y) && isFinite(d.y));

        

        const data2 = d3.range(-0.5, 0.5, 0.01)

            .map(x => ({x: x, y: pair.f2(x)}))

            .filter(d => !isNaN(d.y) && isFinite(d.y));

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y));

        

            const path1 = g.append('path')

            .datum(data1)

            .attr('fill', 'none')

            .attr('stroke', 'var(--primary-color)')

                .attr('stroke-width', 2)

                .attr('d', line);

            animatePath(path1);

        

            const path2 = g.append('path')

            .datum(data2)

            .attr('fill', 'none')

            .attr('stroke', 'var(--accent-color)')

            .attr('stroke-width', 2)

                .attr('stroke-dasharray', '3,3')

                .attr('d', line);

            animatePath(path2);

        };



        const { g, width, height, div } = setup(container, i, pair.name, 'both', 0);

        div.__chartData = {

            drawFunction,

            annotationData: {

                type: 'limit',

                isSequence: false,

                approachPoint: 0,

                limitValue: 1,

                leftLimit: 1,

                rightLimit: 1

            }

        };

        drawFunction(g, width, height);

    });

}





// 第15页：等价无穷小应用

function visualizeEquivalentInfinitesimalApp(containerId) {

    const setup = setupD3(containerId);

    if (!setup) return;

    const { g, width, height } = setup;

    

    const panel = d3.select('#vis-equivalent-infinitesimal-app')

        .append('div')

        .attr('class', 'interactive-panel')

        .style('width', '50%');

    

    panel.append('h3').text('等价无穷小替换应用');

    

    const examples = [

        {

            original: '$$\\lim\\limits_{x \\to 0} \\frac{\\sin 3x \\cdot \\tan 2x}{x^2}$$',

            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{3x \\cdot 2x}{x^2} = 6$$',

            steps: [

                'sin(3x) ~ 3x',

                'tan(2x) ~ 2x',

                '代入得 6'

            ]

        },

        {

            original: '$$\\lim\\limits_{x \\to 0} \\frac{e^x - 1}{\\sin x}$$',

            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{x}{x} = 1$$',

            steps: [

                'e^x - 1 ~ x',

                'sin(x) ~ x',

                '代入得 1'

            ]

        },

        {

            original: '$$\\lim\\limits_{x \\to 0} \\frac{1 - \\cos x}{x^2}$$',

            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{\\frac{x^2}{2}}{x^2} = \\frac{1}{2}$$',

            steps: [

                '1 - cos(x) ~ x²/2',

                '代入得 1/2'

            ]

        },

        {

            original: '$$\\lim\\limits_{x \\to 0} \\frac{\\ln(1+x)}{\\sin x}$$',

            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{x}{x} = 1$$',

            steps: [

                'ln(1+x) ~ x',

                'sin(x) ~ x',

                '代入得 1'

            ]

        },

        {

            original: '$$\\lim\\limits_{x \\to 0} \\frac{\\tan x - x}{x^3}$$',

            replaced: '$$\\lim\\limits_{x \\to 0} \\frac{\\frac{x^3}{3}}{x^3} = \\frac{1}{3}$$',

            steps: [

                'tan(x) - x ~ x³/3',

                '代入得 1/3'

            ]

        }

    ];

    

    let currentExample = 0;

    let autoPlay = true;

    

    // 添加控制按钮

    const buttonContainer = panel.append('div')

        .attr('class', 'button-container');

    

    // 切换按钮

    buttonContainer.append('button')

        .attr('class', 'nav-btn')

        .text('上一个')

        .on('click', () => {

            currentExample = (currentExample - 1 + examples.length) % examples.length;

            showExample();

        });

    

    buttonContainer.append('button')

        .attr('class', 'nav-btn')

        .text('下一个')

        .on('click', () => {

            currentExample = (currentExample + 1) % examples.length;

            showExample();

        });

    

    // 自动播放开关

    buttonContainer.append('button')

        .attr('class', 'nav-btn')

        .text('暂停')

        .on('click', function() {

            autoPlay = !autoPlay;

            d3.select(this).text(autoPlay ? '暂停' : '播放');

            if (autoPlay) {

                showExample();

            }

        });

    

    function showExample() {

        // 清除之前的动画

        currentAnimations.forEach(clear => clear());

        currentAnimations = [];

        

        panel.selectAll('.example-content').remove();

        

        const example = examples[currentExample];

        const content = panel.append('div')

            .attr('class', 'example-content');

        

        // 添加页码显示

        content.append('div')

            .style('text-align', 'center')

            .style('margin-bottom', '15px')

            .style('color', 'var(--accent-color)')

            .style('font-weight', 'bold')

            .text(`例 ${currentExample + 1} / ${examples.length}`);

        

        content.append('div')

            .style('font-size', '1.5rem')

            .style('margin-bottom', '20px')

            .style('text-align', 'center')

            .html(`原式: ${example.original}`);

        

        // 立即渲染数学公式

        if (window.MathJax) {

            MathJax.typesetPromise();

        }

        

        setTimeout(() => {

            content.append('div')

                .attr('class', 'fade-in')

                .style('font-size', '1.3rem')

                .style('margin', '20px 0')

                .style('text-align', 'center')

                .html('应用等价无穷小替换:');

            

            // 步骤只显示一次，不循环

            example.steps.forEach((step, i) => {

                content.append('div')

                    .attr('class', 'fade-in')

                    .style('margin-left', '30px')

                    .style('margin-top', '10px')

                    .style('text-align', 'left')

                    .text(`• ${step}`);

            });

        }, 1000 / globalAnimationSpeed);

        

        setTimeout(() => {

            content.append('div')

                .attr('class', 'fade-in')

                .style('font-size', '1.5rem')

                .style('margin-top', '20px')

                .style('color', 'var(--success-color)')

                .style('text-align', 'center')

                .html(`结果: ${example.replaced}`);

            

            // 重新渲染数学公式

            if (window.MathJax) {

                MathJax.typesetPromise();

            }

        }, 2500 / globalAnimationSpeed);

        

        // 只有在自动播放模式下才继续下一个

        if (autoPlay) {

        currentExample = (currentExample + 1) % examples.length;

        const timeoutId = setTimeout(showExample, 5000 / globalAnimationSpeed);

        currentAnimations.push(() => clearTimeout(timeoutId));

        }

    }

    

    showExample();

}



// 第16页：连续函数

function visualizeContinuousFunctions(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) return;

    

    const functions = [

        { name: '多项式<br>$x^3-3x+1$', fn: x => x*x*x - 3*x + 1 },

        { name: '有理函数<br>$\\frac{x^2+1}{x^2+2}$', fn: x => (x*x + 1)/(x*x + 2) },

        { name: '三角函数<br>$\\sin(2x)$', fn: x => Math.sin(2*x) },

        { name: '指数函数<br>$e^{-x^2}$', fn: x => Math.exp(-x*x) },

        { name: '对数函数<br>$\\ln(x+4)$', fn: x => Math.log(x + 4) },

        { name: '双曲函数<br>$\\tanh(x)$', fn: x => Math.tanh(x) },

        { name: '复合三角<br>$\\sin(\\cos x)$', fn: x => Math.sin(Math.cos(x)) },

        { name: '根式函数<br>$\\sqrt{4-x^2}$', fn: x => Math.abs(x) <= 2 ? Math.sqrt(4 - x*x) : undefined },

        { name: '反三角<br>$\\arcsin(x/2)$', fn: x => Math.abs(x) <= 2 ? Math.asin(x/2) : undefined },

        { name: '绝对值<br>$|\\sin x|$', fn: x => Math.abs(Math.sin(x)) },

        { name: '分段连续<br>$\\begin{cases} e^x, x<0 \\\\ 1, x \\ge 0 \\end{cases}$', fn: x => x < 0 ? Math.exp(x) : 1 },

        { name: '光滑曲线<br>$\\frac{x}{1+x^2}$', fn: x => x/(1 + x*x) },

        { name: '周期函数<br>$\\sin x + \\frac{\\sin 2x}{2}$', fn: x => Math.sin(x) + Math.sin(2*x)/2 },

        { name: 'Sigmoid<br>$\\frac{1}{1+e^{-x}}$', fn: x => 1/(1 + Math.exp(-x)) },

        { name: '高斯函数<br>$e^{-x^2/2}$', fn: x => Math.exp(-x*x/2) }

    ];



    functions.forEach((func, i) => {

        const drawFunction = (g, width, height) => {

    const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);

    const yScale = d3.scaleLinear().domain([-2, 2]).range([height, 0]);

    

            drawAxes(g, xScale, yScale, width, height);



        const data = d3.range(-3, 3, 0.05)

            .map(x => ({x: x, y: func.fn(x)}))

                .filter(d => !isNaN(d.y) && isFinite(d.y));

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y))

            .curve(d3.curveCatmullRom);

        

        const path = g.append('path')

            .datum(data)

            .attr('fill', 'none')

                .attr('stroke', 'var(--primary-color)')

            .attr('stroke-width', 2)

                .attr('d', line);



            animatePath(path, 2000, false);



            // 为第16页所有项添加双边趋近动画

            setTimeout(() => {

                // 选择一个合适的趋近点，通常选择0或函数定义域内的一个点

                const approachPoint = 0;

                const limitValue = func.fn(approachPoint);

                animateLimitApproach(g, xScale, yScale, func.fn, approachPoint, limitValue, width, height);

            }, 100);

        };



        const { g, width, height, div } = setup(container, i, func.name, 'both', '0');

        div.__chartData = {

            drawFunction,

            annotationData: {

                type: 'continuity',

                isSequence: false,

                approachPoint: 0,

                limitValue: func.fn(0),

                leftLimit: func.fn(0),

                rightLimit: func.fn(0),

                functionValue: func.fn(0)

            }

        };

        drawFunction(g, width, height);

    });

}



// 第17页：间断点类型

function visualizeDiscontinuities(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) return;

    

    const discontinuities = [

        {

            name: '可去间断点<br>$\\frac{x^2-1}{x-1}$',

            fn: x => Math.abs(x-1) > 0.01 ? (x*x - 1)/(x - 1) : undefined,

            special: {x: 1, y: 2, type: 'removable'}

        },

        {

            name: '跳跃间断点<br>$\\begin{cases} x+1, x<0 \\\\ x-1, x \\ge 0 \\end{cases}$',

            fn: x => x < 0 ? x + 1 : x - 1,

            special: null

        },

        {

            name: '无穷间断点<br>$1/x^2$',

            fn: x => 1/(x*x),

            special: null

        },

        {

            name: '振荡间断点<br>$\\sin\\left(\\frac{1}{x}\\right)$',

            fn: x => Math.abs(x) > 0.01 ? Math.sin(1/x) : undefined,

            special: null

        },

        {

            name: '混合间断<br>$\\begin{cases} 1/x, x<0 \\\\ \\sqrt{x}, x \\ge 0 \\end{cases}$',

            fn: x => x < 0 ? 1/x : Math.sqrt(x),

            special: null

        },

        {

            name: '周期间断<br>$\\tan x$',

            fn: x => Math.tan(x),

            special: null

        },

        {

            name: '阶梯函数<br>$\\lfloor x \\rfloor$',

            fn: x => Math.floor(x),

            special: null

        },

        {

            name: '符号函数<br>$\\text{sgn}(x)$',

            fn: x => Math.sign(x),

            special: null

        }

    ];

    

    discontinuities.forEach((disc, i) => {

        const drawFunction = (g, width, height) => {

            const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);

            const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);



            drawAxes(g, xScale, yScale, width, height);



        const data = d3.range(-2, 2, 0.01)

            .map(x => ({x: x, y: disc.fn(x)}))

            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y));

        

            const path = g.append('path')

            .datum(data)

            .attr('fill', 'none')

            .attr('stroke', 'var(--danger-color)')

                .attr('stroke-width', 2)

                .attr('d', line);

            animatePath(path, 2000, false);



            // 为第17页所有项添加双边趋近动画

            setTimeout(() => {

                let approachPoint = 0; // 默认趋近点

                let limitValue = 0;

                

                // 根据不同的间断点类型设置趋近点

                if (disc.name.includes('可去间断')) {

                    approachPoint = 1;

                    limitValue = 2;

                } else if (disc.name.includes('阶梯函数') || disc.name.includes('符号函数')) {

                    approachPoint = 0;

                    limitValue = 0;

                } else {

                    approachPoint = 0;

                    limitValue = 0;

                }

                

                animateLimitApproach(g, xScale, yScale, disc.fn, approachPoint, limitValue, width, height);

            }, 100);



        if (disc.special && disc.special.type === 'removable') {

                g.append('circle')

                .attr('cx', xScale(disc.special.x))

                .attr('cy', yScale(disc.special.y))

                .attr('r', 4)

                .attr('fill', 'white')

                .attr('stroke', 'var(--danger-color)')

                .attr('stroke-width', 2);

        }

        };



        let discApproachVal = '0';

        if (disc.name.includes('可去间断')) {

            discApproachVal = '1';

        }

        const { g, width, height, div } = setup(container, i, disc.name, 'both', discApproachVal);



        // 根据间断点类型设置注释数据

        let discontinuityType = 'unknown';

        let leftLimit = '不存在', rightLimit = '不存在';

        let approachPoint = disc.name.includes('可去间断') ? 1 : 0;



        if (disc.name.includes('可去间断')) {

            discontinuityType = '可去间断点';

            leftLimit = '2';

            rightLimit = '2';

        } else if (disc.name.includes('跳跃间断')) {

            discontinuityType = '跳跃间断点';

            leftLimit = '1';

            rightLimit = '-1';

        } else if (disc.name.includes('无穷间断')) {

            discontinuityType = '无穷间断点';

            leftLimit = '+∞';

            rightLimit = '+∞';

        } else if (disc.name.includes('振荡间断')) {

            discontinuityType = '振荡间断点';

            leftLimit = '振荡';

            rightLimit = '振荡';

        }



        div.__chartData = {

            drawFunction,

            annotationData: {

                type: 'limit',

                isSequence: false,

                approachPoint: approachPoint,

                limitValue: null,

                leftLimit: leftLimit,

                rightLimit: rightLimit,

                discontinuityType: discontinuityType

            }

        };

        drawFunction(g, width, height);

    });

}



// 第18页：初等函数连续性

function visualizeElementaryFunctions(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) return;



    const elementaryFunctions = [

        { name: '常数函数<br>$y = c$', fn: x => 1.5 },

        { name: '幂函数<br>$y = x^2$', fn: x => x*x },

        { name: '幂函数<br>$y = x^3$', fn: x => x*x*x },

        { name: '根式函数<br>$y = \\sqrt[3]{x}$', fn: x => Math.cbrt(x) },

        { name: '倒数函数<br>$y = \\frac{1}{x}$', fn: x => 1/x },

        { name: '指数函数<br>$y = e^x$', fn: x => Math.exp(x) },

        { name: '对数函数<br>$y = \\ln x$', fn: x => Math.log(x) },

        { name: '正弦函数<br>$y = \\sin x$', fn: x => Math.sin(x) },

        { name: '余弦函数<br>$y = \\cos x$', fn: x => Math.cos(x) },

        { name: '正切函数<br>$y = \\tan x$', fn: x => Math.tan(x) },

        { name: '反正弦<br>$y = \\arcsin x$', fn: x => Math.asin(x) },

        { name: '反余弦<br>$y = \\arccos x$', fn: x => Math.acos(x) },

        { name: '反正切<br>$y = \\arctan x$', fn: x => Math.atan(x) },

        { name: '双曲正弦<br>$y = \\sinh x$', fn: x => Math.sinh(x) },

        { name: '双曲余弦<br>$y = \\cosh x$', fn: x => Math.cosh(x) }

    ];



    elementaryFunctions.forEach((func, i) => {

        const drawFunction = (g, width, height) => {

            const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);

            const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);



            drawAxes(g, xScale, yScale, width, height);



            const data = d3.range(-3, 3, 0.05)

            .map(x => ({x: x, y: func.fn(x)}))

            .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y));

        

            const path = g.append('path')

            .datum(data)

            .attr('fill', 'none')

            .attr('stroke', 'var(--info-color)')

                .attr('stroke-width', 2)

                .attr('d', line);

            animatePath(path, 2000, false);



            // 为第18页所有项添加双边趋近动画

            setTimeout(() => {

                let approachPoint = 0; // 默认趋近点

                let limitValue = func.fn(0);

                

                // 根据不同的函数类型选择合适的趋近点

                if (func.name.includes('对数函数')) {

                    approachPoint = 1; // 对数函数在x=1处

                    limitValue = func.fn(1);

                } else if (func.name.includes('倒数函数')) {

                    approachPoint = 1; // 避开x=0的奇点

                    limitValue = func.fn(1);

                } else if (func.name.includes('反正弦') || func.name.includes('反余弦')) {

                    approachPoint = 0.5; // 在定义域内

                    limitValue = func.fn(0.5);

                } else {

                    approachPoint = 0;

                    limitValue = func.fn(0);

                }

                

                animateLimitApproach(g, xScale, yScale, func.fn, approachPoint, limitValue, width, height);

            }, 100);

        };



        let funcApproachVal = '0';

        if (func.name.includes('对数函数') || func.name.includes('倒数函数')) {

            funcApproachVal = '1';

        } else if (func.name.includes('反正弦') || func.name.includes('反余弦')) {

            funcApproachVal = '0.5';

        }

        const { g, width, height, div } = setup(container, i, func.name, 'both', funcApproachVal);



        // 根据函数类型设置注释数据

        let approachPoint = 0;

        let limitValue = func.fn(0);

        if (func.name.includes('对数函数')) {

            approachPoint = 1;

            limitValue = func.fn(1);

        } else if (func.name.includes('倒数函数')) {

            approachPoint = 1;

            limitValue = func.fn(1);

        } else if (func.name.includes('反正弦') || func.name.includes('反余弦')) {

            approachPoint = 0.5;

            limitValue = func.fn(0.5);

        }



        div.__chartData = {

            drawFunction,

            annotationData: {

                type: 'continuity',

                isSequence: false,

                approachPoint: approachPoint,

                limitValue: limitValue,

                leftLimit: limitValue,

                rightLimit: limitValue,

                functionValue: limitValue

            }

        };

        drawFunction(g, width, height);

    });

}



// 第19页：连续性判定

function visualizeContinuityDetermination(containerId) {

    const container = getContainer(containerId, 'grid');

    if (!container) return;



    const continuityExamples = [

        { name: '连续<br>$\\sin x$', fn: x => Math.sin(x), a: 0, continuous: true },

        { name: '可去间断<br>$\\frac{x^2-1}{x-1}$', fn: x => Math.abs(x-1) > 0.01 ? (x*x-1)/(x-1) : undefined, a: 1, continuous: false, type: 'removable' },

        { name: '跳跃间断<br>$\\begin{cases} x, x<0 \\\\ x+1, x \\ge 0 \\end{cases}$', fn: x => x < 0 ? x : x + 1, a: 0, continuous: false, type: 'jump' },

        { name: '无穷间断<br>$1/x^2$', fn: x => 1/(x*x), a: 0, continuous: false, type: 'infinite' },

        { name: '振荡间断<br>$\\sin(1/x)$', fn: x => Math.abs(x) > 0.01 ? Math.sin(1/x) : undefined, a: 0, continuous: false, type: 'oscillating' },

        { name: '分段连续<br>$\\begin{cases} x^2, x<1 \\\\ 2x-1, x \\ge 1 \\end{cases}$', fn: x => x < 1 ? x*x : 2*x - 1, a: 1, continuous: true },

        { name: '绝对值连续<br>$|x-1|$', fn: x => Math.abs(x - 1), a: 1, continuous: true },

        { name: '指数连续<br>$e^{-x^2}$', fn: x => Math.exp(-x*x), a: 0, continuous: true },

        { name: '对数间断<br>$\\ln x$', fn: x => x > 0 ? Math.log(x) : undefined, a: 0, continuous: false, type: 'infinite' },

        { name: '复合连续<br>$\\sin(\\sqrt{|x|})$', fn: x => Math.sin(Math.sqrt(Math.abs(x))), a: 0, continuous: true }

    ];



    continuityExamples.forEach((example, i) => {

        const drawFunction = (g, width, height) => {

            const xScale = d3.scaleLinear().domain([example.a - 2, example.a + 2]).range([0, width]);

            const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);



            drawAxes(g, xScale, yScale, width, height);



            const data = d3.range(example.a - 2, example.a + 2, 0.02)

            .map(x => ({x: x, y: example.fn(x)}))

                .filter(d => !isNaN(d.y) && isFinite(d.y) && Math.abs(d.y) < 10);

        

        const line = d3.line()

            .x(d => xScale(d.x))

            .y(d => yScale(d.y));

        

            const color = example.continuous ? 'var(--success-color)' : 'var(--danger-color)';



            const path = g.append('path')

            .datum(data)

            .attr('fill', 'none')

                .attr('stroke', color)

                .attr('stroke-width', 2)

                .attr('d', line);

            animatePath(path, 1500, false);



            // 为第19页所有项添加双边趋近动画

            setTimeout(() => {

                const limitValue = example.continuous ? example.fn(example.a) : (example.type === 'removable' ? 2 : 0);

                animateLimitApproach(g, xScale, yScale, example.fn, example.a, limitValue, width, height);

            }, 100);



        g.append('line')

            .attr('x1', xScale(example.a))

            .attr('y1', 0)

            .attr('x2', xScale(example.a))

                .attr('y2', height)

            .attr('stroke', 'gray')

                .attr('stroke-dasharray', '2,2')

                .attr('opacity', 0.5);



            if (!example.continuous && example.type === 'removable') {

                g.append('circle')

                    .attr('cx', xScale(example.a))

                    .attr('cy', yScale(2))

                    .attr('r', 4)

                    .attr('fill', 'black')

                    .attr('stroke', 'var(--danger-color)')

                    .attr('stroke-width', 2);

            } else if (example.continuous) {

                const pointY = example.fn(example.a);

                if (isFinite(pointY)) {

                    g.append('circle')

                        .attr('cx', xScale(example.a))

                        .attr('cy', yScale(pointY))

                        .attr('r', 3)

                        .attr('fill', 'var(--success-color)');

                }

            }

        };



        const { g, width, height, div } = setup(container, i, example.name, 'both', example.a);



        // 根据连续性设置注释数据

        let limitValue = null;

        let leftLimit = null;

        let rightLimit = null;

        let functionValue = null;



        if (example.continuous) {

            limitValue = example.fn(example.a);

            leftLimit = limitValue;

            rightLimit = limitValue;

            functionValue = limitValue;

        } else {

            if (example.type === 'removable') {

                leftLimit = 2;

                rightLimit = 2;

                limitValue = 2;

                functionValue = null; // 函数值不存在

            } else if (example.type === 'jump') {

                leftLimit = example.a;

                rightLimit = example.a + 1;

                limitValue = null; // 极限不存在

                functionValue = example.a + 1;

            } else if (example.type === 'infinite') {

                leftLimit = '+∞';

                rightLimit = '+∞';

                limitValue = null;

                functionValue = null;

            } else if (example.type === 'oscillating') {

                leftLimit = '振荡';

                rightLimit = '振荡';

                limitValue = null;

                functionValue = null;

            }

        }



        div.__chartData = {

            drawFunction,

            annotationData: {

                type: 'continuity',

                isSequence: false,

                approachPoint: example.a,

                limitValue: limitValue,

                leftLimit: leftLimit,

                rightLimit: rightLimit,

                functionValue: functionValue,

                discontinuityType: example.type || null

            }

        };

        drawFunction(g, width, height);

    });

}



// 第20页：实际应用

function visualizeApplications(containerId) {

    const setup = setupD3(containerId);

    if (!setup) return;

    const { g, width, height } = setup;

    

    // 瞬时速度演示

    const panel = d3.select('#vis-applications')

        .append('div')

        .attr('class', 'interactive-panel');

    

    panel.append('h3').text('极限在实际中的应用');

    

    const applications = [

        { name: '瞬时速度', icon: '🚗' },

        { name: '边际成本', icon: '💰' },

        { name: '图像压缩', icon: '🖼️' }

    ];

    

    const buttonContainer = panel.append('div')

        .attr('class', 'button-container');

    applications.forEach((app, i) => {

        buttonContainer.append('button')

            .attr('class', 'nav-btn')

            .text(`${app.icon} ${app.name}`)

            .on('click', () => showApplication(i));

    });

    

    function showApplication(index) {

        g.selectAll('*').remove();

        

        if (index === 0) {

            // 瞬时速度

            const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);

            const yScale = d3.scaleLinear().domain([0, 130]).range([height - 50, 0]);

            

            g.append('g')

                .attr('transform', `translate(0, ${height - 50})`)

                .call(d3.axisBottom(xScale).tickFormat(d => d + 's'));

            

            g.append('g')

                .call(d3.axisLeft(yScale).tickFormat(d => d + 'm'));

            

            // 位置函数 s(t) = 5t²

            const positionData = d3.range(0, 5, 0.05)

                .map(t => ({t: t, s: 5 * t * t}));

            

            const line = d3.line()

                .x(d => xScale(d.t))

                .y(d => yScale(d.s));

            

            g.append('path')

                .datum(positionData)

                .attr('d', line)

                .attr('fill', 'none')

                .attr('stroke', 'cyan')

                .attr('stroke-width', 3);

            

            // 移动的点

            let t = 0;

            const point = g.append('circle')

                .attr('r', 6)

                .attr('fill', 'red');

            

            const velocityText = g.append('text')

                .attr('x', width - 150)

                .attr('y', 30)

                .attr('fill', 'black')

                .style('font-size', '16px');

            

            function animate() {

                t = (t + 0.02) % 5;

                const s = 5 * t * t;

                const v = 10 * t; // 导数

                

                point

                    .attr('cx', xScale(t))

                    .attr('cy', yScale(s));

                

                velocityText.text(`速度: ${v.toFixed(1)} m/s`);

                

                requestAnimationFrame(animate);

            }

            

            animate();

            currentAnimations.push(() => {});

            

        } else if (index === 1) {

            // 边际成本

            const xScale = d3.scaleLinear().domain([0, 100]).range([0, width]);

            const yScale = d3.scaleLinear().domain([0, 300]).range([height - 50, 0]);

            

            g.append('g')

                .attr('transform', `translate(0, ${height - 50})`)

                .call(d3.axisBottom(xScale).tickFormat(d => d + '个'));

            

            g.append('g')

                .call(d3.axisLeft(yScale).tickFormat(d => '$' + d));

            

            // 成本函数 C(x) = 100 + 2x + 0.01x²

            const costData = d3.range(0, 100, 1)

                .map(x => ({x: x, c: 100 + 2*x + 0.01*x*x}));

            

            const line = d3.line()

                .x(d => xScale(d.x))

                .y(d => yScale(d.c));

            

            g.append('path')

                .datum(costData)

                .attr('d', line)

                .attr('fill', 'none')

                .attr('stroke', 'lime')

                .attr('stroke-width', 3);

            

            g.append('text')

                .attr('x', width / 2)

                .attr('y', 30)

                .attr('text-anchor', 'middle')

                .attr('fill', 'black')

                .text('成本函数: C(x) = 100 + 2x + 0.01x²');

            

        } else if (index === 2) {

            // 图像压缩

            const steps = 10;

            const imageSize = 100;

            

            for (let i = 0; i <= steps; i++) {

                const quality = i / steps;

                const x = (width / (steps + 1)) * (i + 0.5);

                const y = height / 2;

                

                const rect = g.append('rect')

                    .attr('x', x - imageSize/2)

                    .attr('y', y - imageSize/2)

                    .attr('width', imageSize)

                    .attr('height', imageSize)

                    .attr('fill', d3.interpolateViridis(quality))

                    .attr('opacity', 0.3 + quality * 0.7);

                

                g.append('text')

                    .attr('x', x)

                    .attr('y', y + imageSize/2 + 20)

                    .attr('text-anchor', 'middle')

                    .attr('fill', 'black')

                    .style('font-size', '12px')

                    .text(`${(quality * 100).toFixed(0)}%`);

            }

            

            g.append('text')

                .attr('x', width / 2)

                .attr('y', 30)

                .attr('text-anchor', 'middle')

                .attr('fill', 'black')

                .text('渐进式图像压缩：质量逐步逼近原图');

        }

    }

    

    showApplication(0);

}



// 第21页：总结

function visualizeSummary(containerId) {

    const setup = setupD3(containerId);

    if (!setup) return;

    const { g, width, height } = setup;

    

    // 创建思维导图

    const centerX = width / 2;

    const centerY = height / 2;

    

    // 中心节点

    const center = g.append('g')

        .attr('transform', `translate(${centerX}, ${centerY})`);

    

    center.append('circle')

        .attr('r', 0)

        .attr('fill', 'var(--primary-color)')

        .transition()

        .duration(500)

        .attr('r', 60);

    

    center.append('text')

        .attr('text-anchor', 'middle')

        .attr('dy', '0.3em')

        .attr('fill', 'black')

        .style('font-size', '24px')

        .style('font-weight', 'bold')

        .style('opacity', 0)

        .text('极限')

        .transition()

        .delay(500)

        .duration(500)

        .style('opacity', 1);

    

    // 分支

    const branches = [

        { angle: 0, text: '数列极限', color: '#3498db', detail: 'n→∞' },

        { angle: Math.PI/3, text: '函数极限', color: '#2ecc71', detail: 'x→a' },

        { angle: 2*Math.PI/3, text: '左右极限', color: '#e74c3c', detail: '单侧' },

        { angle: Math.PI, text: '运算法则', color: '#f39c12', detail: '四则' },

        { angle: 4*Math.PI/3, text: '重要极限', color: '#9b59b6', detail: '两个' },

        { angle: 5*Math.PI/3, text: '连续性', color: '#1abc9c', detail: '三条件' }

    ];

    

    branches.forEach((branch, i) => {

        const x = Math.cos(branch.angle) * 200;

        const y = Math.sin(branch.angle) * 200;

        

        // 连线

        const line = g.append('line')

            .attr('x1', centerX)

            .attr('y1', centerY)

            .attr('x2', centerX)

            .attr('y2', centerY)

            .attr('stroke', branch.color)

            .attr('stroke-width', 3)

            .style('opacity', 0);

        

        line.transition()

            .delay(1000 + i * 200)

            .duration(500)

            .attr('x2', centerX + x)

            .attr('y2', centerY + y)

            .style('opacity', 1);

        

        // 节点

        const node = g.append('g')

            .attr('transform', `translate(${centerX + x}, ${centerY + y})`)

            .style('opacity', 0);

        

        node.append('circle')

            .attr('r', 40)

            .attr('fill', branch.color);

        

        node.append('text')

            .attr('text-anchor', 'middle')

            .attr('dy', '-0.2em')

            .attr('fill', 'black')

            .style('font-size', '14px')

            .style('font-weight', 'bold')

            .text(branch.text);

        

        node.append('text')

            .attr('text-anchor', 'middle')

            .attr('dy', '1.2em')

            .attr('fill', 'black')

            .style('font-size', '11px')

            .text(branch.detail);

        

        node.transition()

            .delay(1500 + i * 200)

            .duration(500)

            .style('opacity', 1);

    });

    

    // 添加总结文字

    const summaryText = g.append('text')

        .attr('x', centerX)

        .attr('y', height - 30)

        .attr('text-anchor', 'middle')

        .attr('fill', 'black')

        .style('font-size', '16px')

        .style('opacity', 0)

        .text('极限是微分的基础，连续是积分的前提！');

    

    summaryText.transition()

        .delay(3000)

        .duration(1000)

        .style('opacity', 1);

}





</script>

<script>
function scrollToStep(stepId) {
    const target = document.getElementById(`step-${stepId}`);
    if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const steps = Array.from(document.querySelectorAll('.step'));
    const visContainer = d3.select('#sticky-vis-container');
    let activeStep = null;

    function handleStepEnter(step) {
        if (activeStep === step) {
            return;
        }

        activeStep = step;

        // 清空并准备右侧容器
        visContainer.html('');
        visContainer.node().className = ''; // 重置所有样式类

        // 查找当前 step 是否有自定义的右侧内容
        const customContent = step.querySelector('.right-panel-content');

        if (customContent) {
            // 如果有自定义内容 (封面或目录)
            visContainer.classed('custom-content', true); // 添加自定义样式
            visContainer.html(customContent.innerHTML); // 将内容复制到右侧
            visContainer.style('opacity', 1);
        } else {
            // 如果是标准的D3可视化
            visContainer.style('opacity', 1);
            const animationKey = step.dataset.animation;
            const animator = animationMap[animationKey];
            if (typeof animator === 'function') {
                animator('sticky-vis-container');
            }
        }

        // 渲染 MathJax 公式
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([step, visContainer.node()]);
        }
    }

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                steps.forEach(s => s.classList.remove('is-active'));
                entry.target.classList.add('is-active');
                handleStepEnter(entry.target);
            }
        });
    }, {
        rootMargin: '-50% 0px -50% 0px',
        threshold: 0
    });

    steps.forEach(step => observer.observe(step));

    if (steps.length > 0) {
        handleStepEnter(steps[0]);
    }

    if (window.MathJax && window.MathJax.typesetPromise) {
        window.MathJax.typesetPromise();
    }
});

// Lab Menu Toggle Function
function toggleLabMenu() {
    const labMenu = document.getElementById('labMenu');
    labMenu.classList.toggle('show');
}

// Close lab menu when clicking outside
document.addEventListener('click', function(event) {
    const labMenu = document.getElementById('labMenu');
    const labButton = document.querySelector('.lab-menu-button');

    if (!labMenu.contains(event.target) && !labButton.contains(event.target)) {
        labMenu.classList.remove('show');
    }
});
</script>

</body>
</html>