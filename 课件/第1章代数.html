<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一章：函数基础 (交互式课件)</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <!-- 使用统一的MathJax配置文件，避免配置冲突 -->
    <script src="../common-assets/js/mathjax-config.js"></script>
    <script type="text/javascript" id="MathJax-script" async
            src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js">
    </script>

    <style>
        @import url('../common-assets/css/fonts.css');

        :root {
            --chalkboard-bg: transparent;
            --chalk-text: #ecf0f1;
            --visualization-bg: #fdfdfd00;
            --primary-color: #3498db;
            --accent-color: #e67e22;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #9b59b6;
            --text-color: #34495e;
            --heading-font: 'Noto Serif SC', serif;
            --handwriting-font: 'Noto Serif SC', serif;
        }

        body {
            font-family: var(--heading-font);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: auto;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
        }
        
        #presentation-container {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            aspect-ratio: 16 / 9;
            position: relative;
            background: rgba(255, 255, 255, 0);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: auto;
        }

        .slide {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            display: flex;
            transition: opacity 0.6s ease-in-out;
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            z-index: 10;
        }

        /* iframe容器样式 */
        .iframe-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .iframe-nav-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
            background: transparent;
        }

        /* 添加导航提示 */
        .iframe-nav-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1002;
            pointer-events: none;
        }

        .chalkboard {
            flex: 0 0 35%;
            background-color: #2c3e50 !important;
            background-image: url('../common-assets/images/black-felt.png');
            border: 10px solid #8B4513;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.7);
            color: var(--chalk-text, #f0f0f0);
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .chalkboard h2 {
            font-family: var(--handwriting-font);
            font-size: 2.2rem;
            color: #f1c40f;
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
            padding-bottom: 2px;
            margin-bottom: 3px;
        }

        .chalkboard h3 {
            font-family: var(--handwriting-font);
            font-size: 1.5rem;
            color: var(--primary-color);
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .chalkboard p, .chalkboard li {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 15px;
        }
        
        .chalkboard ol {
            padding-left: 25px;
        }

        .chalkboard ul {
            list-style-type: '→ ';
            padding-left: 20px;
        }

        .math-formula {
            font-size: 1.3rem;
            color: #1abc9c;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin: 15px 0;
            line-height: 1.5;
        }

        .highlight {
            color: var(--warning-color);
            font-weight: bold;
        }

        .visualization {
            flex: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            position: relative;
            box-sizing: border-box;
        }

        .visualization.full-width {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }
        
        .visualization.white-bg {
            background: white;
        }

        /* 翻页按钮样式 */
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            user-select: none;
            min-width: 30px;
            text-align: center;
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* 页码指示器 */
        .page-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* 返回面板样式 */
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }

        /* 首页导航按钮样式 */
        .home-nav-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        .home-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            text-decoration: none;
            color: white;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .home-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .home-nav-btn .btn-icon {
            font-size: 1.2rem;
            margin-bottom: 8px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .home-nav-btn .btn-text {
            font-size: 1.1rem;
            font-weight: 500;
        }

        /* 翻页按钮样式 */
        .nav-buttons {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        .nav-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            backdrop-filter: blur(10px);
        }

        .nav-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.5);
        }

        .nav-btn:disabled {
            background: rgba(149, 165, 166, 0.5);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* 页面指示器样式 */
        .page-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* 全局动画控制面板样式 */
        .global-animation-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        .global-control-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: normal;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
            min-width: 50px;
            text-align: center;
        }

        .global-control-btn:hover {
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .global-control-btn:active {
            transform: scale(0.95);
        }

        .global-control-btn.pause {
            background: rgba(255, 107, 107, 0.3);
            border-color: rgba(255, 107, 107, 0.4);
        }

        .global-control-btn.pause:hover {
            background: rgba(255, 107, 107, 0.5);
        }

        /* 浮动菜单样式 */
        #floating-menu {
            position: fixed;
            bottom: 20px;
            right: 200px;
            z-index: 9999;
            font-family: var(--heading-font);
        }

        /* 章节目录菜单样式 */
        #chapter-menu {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            font-family: var(--heading-font);
        }

        .menu-toggle {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: normal;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
            min-width: 50px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-toggle:hover {
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .menu-toggle:active {
            transform: scale(0.95);
        }

        .menu-toggle .menu-icon {
            font-size: 12px;
            font-weight: normal;
            transition: transform 0.3s ease;
        }

        .menu-toggle.active .menu-icon {
            transform: rotate(45deg);
        }

        .menu-content {
            position: absolute;
            bottom: 50px;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 10px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: all 0.3s ease;
            min-width: 220px;
            max-height: 400px;
            overflow-y: auto;
        }

        .menu-content.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* 自定义滚动条样式 */
        .menu-content::-webkit-scrollbar {
            width: 6px;
        }

        .menu-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }

        .menu-content::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 3px;
        }

        .menu-content::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            text-decoration: none;
            color: #333;
            transition: all 0.3s ease;
            border-radius: 10px;
            margin: 0 8px;
        }

        .menu-item:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateX(5px);
        }

        .menu-item .menu-icon {
            font-size: 12px;
            margin-right: 8px;
            width: 16px;
            text-align: center;
        }

        .menu-item .menu-text {
            font-size: 13px;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link return-sub" href="index.html">← 返回课件目录</a>
        <a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
    </div>

    <div id="presentation-container">
        
        <!-- 幻灯片0：标题页 -->
        <div class="slide active">
            <div class="chalkboard" style="flex: 1; text-align: center;">
                <h2 style="font-size: 4rem; border: none;">第一章</h2>
                <p style="font-size: 2.5rem; color: white;">代数与函数</p>
                
                <div class="home-nav-buttons">
                    <a href="../index.html" class="home-nav-btn">
                        <span class="btn-icon">HOME</span>
                        <span class="btn-text">主页</span>
                    </a>
                    <a href="../故事书/index.html" class="home-nav-btn">
                        <span class="btn-icon">STORY</span>
                        <span class="btn-text">故事书</span>
                    </a>
                    <a href="../习题/index.html" class="home-nav-btn">
                        <span class="btn-icon">EXERCISE</span>
                        <span class="btn-text">习题</span>
                    </a>
                    <a href="../网页资源/index.html" class="home-nav-btn">
                        <span class="btn-icon">RESOURCE</span>
                        <span class="btn-text">网页资源</span>
                    </a>
                </div>
            </div>
        </div>

        <!-- 幻灯片1：目录页 -->
        <div class="slide">
            <div class="chalkboard" style="flex: 1; text-align: center; overflow-y: auto; align-items: flex-start; justify-content: flex-start;">
                <div style="writing-mode: vertical-rl; text-orientation: mixed; font-size: 3rem; border: none; margin-bottom: 1.5rem; height: 8rem; display: flex; align-items: flex-start; justify-content: center;">
                    目录
                </div>
                
                <div style="width: 100%; max-width: 1200px; text-align: left; padding: 2rem; margin: 0 auto;">
                    <div style="background: rgba(255,255,255,0.1); padding: 1.2rem; border-radius: 10px; margin-bottom: 1.5rem;">
                        <h3 style="color: #e74c3c; font-size: 1.5rem; margin-bottom: 0.8rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.3rem;">第一节：集合与函数概念</h3>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 1.1 集合与区间</p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 1.2 函数的概念 (定义、定义域、值域)</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.1); padding: 1.2rem; border-radius: 10px; margin-bottom: 1.5rem;">
                        <h3 style="color: #3498db; font-size: 1.5rem; margin-bottom: 0.8rem; border-bottom: 2px solid #3498db; padding-bottom: 0.3rem;">第二节：基本初等函数</h3>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 2.1 幂函数 & 指数运算</p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 2.2 指数函数</p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 2.3 对数函数 & 对数运算</p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 2.4 三角函数与反三角函数</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.1); padding: 1.2rem; border-radius: 10px; margin-bottom: 1.5rem;">
                        <h3 style="color: #2ecc71; font-size: 1.5rem; margin-bottom: 0.8rem; border-bottom: 2px solid #2ecc71; padding-bottom: 0.3rem;">第三节：函数的基本性质</h3>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 3.1 单调性 • 3.2 奇偶性 • 3.3 周期性 • 3.4 有界性</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.1); padding: 1.2rem; border-radius: 10px;">
                        <h3 style="color: #f1c40f; font-size: 1.5rem; margin-bottom: 0.8rem; border-bottom: 2px solid #f1c40f; padding-bottom: 0.3rem;">第四节：函数的运算</h3>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 4.1 反函数 • 4.2 复合函数</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 幻灯片2：视频介绍页 -->
        <div class="slide">
            <div class="chalkboard" style="flex: 1; text-align: center; padding: 1rem; overflow: hidden; display: flex; flex-direction: column; justify-content: center;">
                <div style="position: relative; width: 100%; max-width: 400px; height: 0; padding-bottom: 28%; margin: 0 auto;">
                    <iframe 
                        src="https://player.bilibili.com/player.html?bvid=BV1ph4y1g75E&t=22.7&autoplay=0&high_quality=1" 
                        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);"
                        allowfullscreen>
                    </iframe>
                </div>
            </div>
        </div>

        <!-- 第一节：集合与函数概念 -->
        
        <!-- 幻灯片3：集合与常量变量 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>集合、常量与变量</h2>
                
                <h3>集合</h3>
                <p>指具有某种<span class="highlight">特定性质</span>的、确定的、可以区分的事物的<span class="highlight">全体</span>。</p>
                <p>例如：所有正整数的集合 {1, 2, 3, ...}</p>
                
                <h3>常量</h3>
                <p>在问题研究过程中，<span class="highlight">取值始终保持不变</span>的量。</p>
                <ul>
                    <li>例如：圆周率 $\pi \approx 3.14159$，自然常数 $e \approx 2.718$</li>
                    <li>在 $y=2x+1$ 中，数字 $2$ 和 $1$ 都是常量</li>
                </ul>
                
                <h3>变量</h3>
                <p>在一定范围内，<span class="highlight">可以取不同数值</span>的量。</p>
                <ul>
                    <li>例如：时间 $t$，温度 $T$，速度 $v$</li>
                    <li>在 $y=2x+1$ 中，$x$ 和 $y$ 都是变量</li>
                </ul>
            </div>
            <div class="visualization" id="vis-variables"></div>
        </div>

        <!-- 幻灯片4：区间表示法 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>区间表示法</h2>
                
                <h3>闭区间 [a, b]</h3>
                <p>包括端点 $a$ 和 $b$。$a \le x \le b$</p>
                
                <h3>开区间 (a, b)</h3>
                <p>不包括端点 $a$ 和 $b$。$a < x < b$</p>
                
                <h3>半开半闭区间</h3>
                <p>$[a, b)$：包括 $a$，不包括 $b$。$a \le x < b$</p>
                <p>$(a, b]$：不包括 $a$，包括 $b$。$a < x \le b$</p>
            </div>
            <div class="visualization" id="vis-intervals"></div>
        </div>

        <!-- 幻灯片5：函数定义 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>函数</h2>
                <p>函数是一种<span class="highlight">特殊的对应关系</span>，就像一个"加工机器"。</p>
                <p>对于每一个输入的数值 $x$（来自一个指定的集合 A），这台机器都能产出<span class="highlight">唯一确定</span>的输出数值 $y$（来自集合 B）。</p>
                <div class="math-formula">
                    $y = f(x)$
                </div>
                <ul>
                    <li>$x$：自变量 (Input)</li>
                    <li>$f$：对应法则 (Rule / Machine)</li>
                    <li>$y$：因变量 (Output)</li>
                </ul>
            </div>
            <div class="visualization" id="vis-function-machine"></div>
        </div>

        <!-- 幻灯片6：定义域 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>定义域</h3>
                <p>思考：要让函数表达式有意义，$x$ 可以取哪些值？</p>
                <ul>
                    <li>分母不能为零</li>
                    <li>偶次根号下的数必须大于等于零</li>
                    <li>对数的真数必须大于零</li>
                </ul>
                <p>$f(x) = \frac{1}{x-2}$，分母 $x-2 \neq 0$，所以定义域是 $x \neq 2$</p>
                <p>$g(x) = \sqrt{x-3}$，根号下 $x-3 \ge 0$，所以定义域是 $x \ge 3$</p>
            </div>
            <div class="visualization" id="vis-domain"></div>
        </div>

        <!-- 幻灯片7：值域 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>值域</h3>
                <p>当 $x$ 取遍定义域中的所有值时，对应的 $y$ 值组成了值域。</p>
                <ul>
                    <li>观察法：对于简单函数，直接观察图像</li>
                    <li>配方法：对于二次函数</li>
                    <li>反函数法：求反函数的定义域</li>
                </ul>
                <p>$f(x) = x^2$。因为平方永远是非负数，所以值域是 $y \ge 0$</p>
                <p>$g(x) = \sin(x)$。正弦函数的值在 -1 和 1 之间波动，所以值域是 $[-1, 1]$</p>
            </div>
            <div class="visualization" id="vis-range"></div>
        </div>

        <!-- 第二节：基本初等函数 -->
        
        <!-- 幻灯片8：基本初等函数介绍 -->
        <div class="slide">
            <div class="visualization full-width" id="vis-elementary-intro"></div>
        </div>

        <!-- 幻灯片9：常数与幂函数 (iframe) -->
        <div class="slide">
            <div class="iframe-container">
                <iframe id="iframe-power-constant" src="常数函数与幂函数.html" style="width: 100%; height: 100%; border: none;"></iframe>
                <div class="iframe-nav-overlay" data-slide="9"></div>
            </div>
        </div>

        <!-- 幻灯片10：指数定义 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>指数</h2>
                <h3>定义</h3>
                <p>指数表示一个数（底数）连续乘以自身多少次。</p>
                <div class="math-formula">
                    $a^n = \underbrace{a \times a \times \dots \times a}_{n \text{ 个}}$
                </div>
                <p>其中，$a$ 是 <span class="highlight">底数</span>，$n$ 是 <span class="highlight">指数</span>。</p>
                <h3>例子</h3>
                <p>$2^3 = 2 \times 2 \times 2 = 8$</p>
                <p>$10^4 = 10 \times 10 \times 10 \times 10 = 10000$</p>
            </div>
            <div class="visualization" id="vis-exponents"></div>
        </div>

        <!-- 幻灯片11：指数运算法则1 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>乘法法则</h3>
                <div class="formula-rule">
                    $a^m \cdot a^n = a^{m+n}$
                </div>
                <p>同底数幂相乘，<span class="highlight">底数不变，指数相加</span>。</p>
                <p>例：$2^3 \cdot 2^4 = 2^{3+4} = 2^7 = 128$</p>
                
                <h3>除法法则</h3>
                <div class="formula-rule">
                    $\frac{a^m}{a^n} = a^{m-n}$
                </div>
                <p>同底数幂相除，<span class="highlight">底数不变，指数相减</span>。</p>
                <p>例：$\frac{5^7}{5^3} = 5^{7-3} = 5^4 = 625$</p>
            </div>
            <div class="visualization" id="vis-exponent-rules-1"></div>
        </div>

        <!-- 幻灯片12：指数运算法则2 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>幂的幂法则</h3>
                <div class="formula-rule">
                    $(a^m)^n = a^{m \cdot n}$
                </div>
                <p>幂的幂，<span class="highlight">底数不变，指数相乘</span>。</p>
                <p>例：$(3^2)^4 = 3^{2 \times 4} = 3^8$</p>
                
                <h3>乘积的幂法则</h3>
                <div class="formula-rule">
                    $(ab)^n = a^n \cdot b^n$
                </div>
                <p>积的幂等于<span class="highlight">幂的积</span>。</p>
                <p>例：$(2 \times 3)^4 = 2^4 \times 3^4 = 16 \times 81$</p>
            </div>
            <div class="visualization" id="vis-exponent-rules-2"></div>
        </div>

        <!-- 幻灯片13：零指数与负指数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>零指数</h3>
                <div class="formula-rule">
                    $a^0 = 1$ （$a \neq 0$）
                </div>
                <p>任何非零数的零次方都等于 <span class="highlight">1</span>。</p>
                <p>可以通过 $\frac{a^m}{a^m} = a^{m-m} = a^0$ 来理解。</p>
                
                <h3>负指数</h3>
                <div class="formula-rule">
                    $a^{-n} = \frac{1}{a^n}$
                </div>
                <p>负指数表示<span class="highlight">倒数</span>。</p>
                <p>可以从 $\frac{a^0}{a^n} = a^{0-n} = a^{-n}$ 推导出来。</p>
            </div>
            <div class="visualization" id="vis-special-exponents"></div>
        </div>

        <!-- 幻灯片14：分数指数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>分数指数</h3>
                <p>分数指数是<span class="highlight">开方运算</span>的另一种写法。</p>
                <div class="formula-rule">
                    $a^{\frac{1}{n}} = \sqrt[n]{a}$
                </div>
                <p>读作：$a$ 的 $n$ 分之一次方等于 $a$ 的 $n$ 次方根。</p>
                <p>• $27^{\frac{1}{3}} = \sqrt[3]{27} = 3$</p>
                <p>• $16^{\frac{1}{4}} = \sqrt[4]{16} = 2$</p>
                <p>• $8^{\frac{1}{3}} = \sqrt[3]{8} = 2$</p>
                <p>指数 $\frac{1}{n}$ 表示：<span class="highlight">"什么数的 $n$ 次方等于底数？"</span></p>
            </div>
            <div class="visualization" id="vis-fractional-exponents"></div>
        </div>

        <!-- 幻灯片15：指数函数 (iframe) -->
        <div class="slide">
            <div class="iframe-container">
                <iframe id="iframe-exp" src="指数函数可视化.html" style="width: 100%; height: 100%; border: none;"></iframe>
                <div class="iframe-nav-overlay" data-slide="15"></div>
            </div>
        </div>

        <!-- 幻灯片16：对数发展历史 -->
        <div class="slide">
            <div class="visualization full-width" id="vis-log-history"></div>
        </div>

        <!-- 幻灯片17：对数定义 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>对数</h2>
                <p>对数是<strong>指数</strong>的逆运算。</p>
                <p>如果 $b^y = x$，那么 $\log_b(x) = y$</p>
                <ul>
                    <li>$b$ 是底数</li>
                    <li>$x$ 是真数</li>
                    <li>$y$ 就是以$b$为底$x$的对数</li>
                </ul>
                <p>对数 $y$ 回答了一个问题："底数 $b$ 需要自身相乘多少次才能得到 $x$？"</p>
                <p>将复杂的大数<strong>乘除</strong>运算，转化为简单的<strong>加减</strong>运算。</p>
            </div>
            <div class="visualization" id="vis-log-definition">
                <svg id="animation2" width="100%" height="100%"></svg>
            </div>
        </div>

        <!-- 幻灯片18：对数函数 (iframe) -->
        <div class="slide">
            <div class="iframe-container">
                <iframe id="iframe-log" src="对数函数可视化.html" style="width: 100%; height: 100%; border: none;"></iframe>
                <div class="iframe-nav-overlay" data-slide="18"></div>
            </div>
        </div>

        <!-- 幻灯片19：对数运算法则 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>乘积的对数</h3>
                <p>$\log_b(xy) = \log_b(x) + \log_b(y)$</p>
                <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                    <strong>例：</strong>$\log_2(8 \times 4) = \log_2(8) + \log_2(4) = 3 + 2 = 5$<br>
                    验证：$2^5 = 32 = 8 \times 4$ ✓
                </p>

                <h3>商的对数</h3>
                <p>$\log_b(\frac{x}{y}) = \log_b(x) - \log_b(y)$</p>
                <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                    <strong>例：</strong>$\log_2(\frac{16}{4}) = \log_2(16) - \log_2(4) = 4 - 2 = 2$<br>
                    验证：$2^2 = 4 = \frac{16}{4}$ ✓
                </p>

                <h3>幂的对数</h3>
                <p>$\log_b(x^n) = n \cdot \log_b(x)$</p>

                <h3>换底公式</h3>
                <p>$\log_b(x) = \frac{\log_a(x)}{\log_a(b)}$</p>
            </div>
            <div class="visualization" id="vis-log-properties"></div>
        </div>

        <!-- 幻灯片20：常用对数系统 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>常用对数系统</h3>
                <div style="margin: 20px 0;">
                    <h3 style="color: #e74c3c;">常用对数（lg）</h3>
                    <p>以10为底的对数：$\lg(x) = \log_{10}(x)$</p>
                    <ul>
                        <li>$\lg(10) = 1$</li>
                        <li>$\lg(100) = 2$</li>
                        <li>$\lg(1000) = 3$</li>
                    </ul>
                </div>
                <div style="margin: 20px 0;">
                    <h3 style="color: #27ae60;">自然对数（ln）</h3>
                    <p>以$e$为底的对数：$\ln(x) = \log_e(x)$</p>
                    <p>其中 $e \approx 2.718...$（欧拉数）</p>
                    <ul>
                        <li>$\ln(e) = 1$</li>
                        <li>$\ln(e^2) = 2$</li>
                        <li>$\ln(1) = 0$</li>
                    </ul>
                </div>
            </div>
            <div class="visualization" id="vis-common-logs">
                <svg id="animation5" width="100%" height="100%"></svg>
            </div>
        </div>

        <!-- 幻灯片21：对数运算可视化 -->
        <div class="slide">
            <div class="visualization full-width white-bg" id="vis-log-operations">
                <svg id="animation3" width="100vw" height="100vh"></svg>
            </div>
        </div>

        <!-- 幻灯片22：三角函数 (iframe) -->
        <div class="slide">
            <div class="iframe-container">
                <iframe id="iframe-trig" src="三角函数.html" style="width: 100%; height: 100%; border: none;"></iframe>
                <div class="iframe-nav-overlay" data-slide="22"></div>
            </div>
        </div>

        <!-- 幻灯片23：反三角函数 (iframe) -->
        <div class="slide">
            <div class="iframe-container">
                <iframe id="iframe-inv-trig" src="反三角函数可视化.html" style="width: 100%; height: 100%; border: none;"></iframe>
                <div class="iframe-nav-overlay" data-slide="23"></div>
            </div>
        </div>

        <!-- 第三节：函数的基本性质 -->
        
        <!-- 幻灯片24：函数性质介绍 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>函数的基本性质</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                    <div>
                        <h4><span class="highlight">单调性</span></h4>
                        <p>描述函数图像是"上坡"还是"下坡"</p>
                    </div>
                    <div>
                        <h4><span class="highlight">奇偶性</span></h4>
                        <p>描述函数图像的对称性</p>
                    </div>
                    <div>
                        <h4><span class="highlight">周期性</span></h4>
                        <p>描述函数图像的重复性</p>
                    </div>
                    <div>
                        <h4><span class="highlight">有界性</span></h4>
                        <p>描述函数值的范围限制</p>
                    </div>
                </div>
            </div>
            <div class="visualization" id="vis-properties-intro"></div>
        </div>

        <!-- 幻灯片25：单调递增 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>单调递增</h3>
                <p>在一个区间内，如果函数值 $y$ <span class="highlight">随着 $x$ 的增大而增大</span>，那么函数在该区间上是单调递增的。</p>
                <p>几何上看，图像是<span class="highlight">从左到右上升的（上坡）</span>。</p>
                <div class="math-formula">
                    若 $x_1 < x_2$，则 $f(x_1) < f(x_2)$
                </div>
            </div>
            <div class="visualization" id="vis-monotonicity-inc"></div>
        </div>

        <!-- 幻灯片26：单调递减 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>单调递减</h3>
                <p>在一个区间内，如果函数值 $y$ <span class="highlight">随着 $x$ 的增大而减小</span>，那么函数在该区间上是单调递减的。</p>
                <p>几何上看，图像是<span class="highlight">从左到右下降的（下坡）</span>。</p>
                <div class="math-formula">
                    若 $x_1 < x_2$，则 $f(x_1) > f(x_2)$
                </div>
            </div>
            <div class="visualization" id="vis-monotonicity-dec"></div>
        </div>

        <!-- 幻灯片27：单调区间 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>单调区间</h3>
                <p>函数的单调性在不同区间可能呈现不同特征。</p>
                <p>分析函数性质时，需要明确划分其单调递增和单调递减的区间范围。</p>
                <p>$f(x) = x^2$</p>
                <ul>
                    <li>在区间 $(-\infty, 0]$ 上，函数<span class="highlight">单调递减</span>。</li>
                    <li>在区间 $[0, +\infty)$ 上，函数<span class="highlight">单调递增</span>。</li>
                </ul>
                <p>点 $x=0$ 是它的"转折点"。</p>
            </div>
            <div class="visualization" id="vis-monotonicity-intervals"></div>
        </div>

        <!-- 幻灯片28：奇偶性介绍 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>奇偶性</h3>
                <p>奇偶性描述的是函数图像关于<span class="highlight">坐标轴或原点</span>的对称性。</p>
                <p>判断奇偶性的前提是：函数的<span class="highlight">定义域必须关于原点对称</span>。</p>
                <ul>
                    <li><strong>偶函数</strong>：图像关于 Y 轴对称</li>
                    <li><strong>奇函数</strong>：图像关于原点对称</li>
                </ul>
            </div>
            <div class="visualization" id="vis-parity-intro"></div>
        </div>

        <!-- 幻灯片29：偶函数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>偶函数</h3>
                <p>如果对于定义域内的任意 $x$，都满足：</p>
                <div class="math-formula">
                    $f(-x) = f(x)$
                </div>
                <p>那么 $f(x)$ 就是一个偶函数。</p>
                <p>函数图像关于 <span class="highlight">Y 轴对称</span>。就像镜子一样。</p>
                <p>例：$f(x) = x^2$, $f(x) = |x|$, $f(x) = \cos(x)$</p>
            </div>
            <div class="visualization" id="vis-even-function"></div>
        </div>

        <!-- 幻灯片30：奇函数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>奇函数</h3>
                <p>如果对于定义域内的任意 $x$，都满足：</p>
                <div class="math-formula">
                    $f(-x) = -f(x)$
                </div>
                <p>那么 $f(x)$ 就是一个奇函数。</p>
                <p>函数图像关于 <span class="highlight">原点 (0,0) 对称</span>。图像旋转180度后会与原图重合。</p>
                <p>例：$f(x) = x$, $f(x) = x^3$, $f(x) = \sin(x)$</p>
            </div>
            <div class="visualization" id="vis-odd-function"></div>
        </div>

        <!-- 幻灯片31：有界性 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>有界性</h3>
                <p>如果存在一个正数 M，使得函数 f(x) 在其整个定义域上，恒有 <span class="highlight">|f(x)| ≤ M</span> 成立，那么就称 f(x) 为有界函数。</p>
                <p>通俗地说，函数的图像被两条水平线"夹住"了，既不会跑到"天上去"，也不会掉到"无底洞"。</p>
                <p>例如：</p>
                <ul>
                    <li>$y = \sin(x)$ 和 $y = \cos(x)$ 都是有界函数，因为它们的值域都在 $[-1, 1]$ 之间</li>
                    <li>$y = x^2$ 在 $(-\infty, +\infty)$ 上无界，但在任何有限区间 $[a, b]$ 上有界</li>
                </ul>
            </div>
            <div class="visualization" id="vis-boundedness"></div>
        </div>

        <!-- 第四节：函数的运算 -->
        
        <!-- 幻灯片32：反函数定义 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>反函数</h3>
                <p>如果函数 $f$ 把 $x$ 变成了 $y$，那么它的反函数 $f^{-1}$ 就是把 $y$ <span class="highlight">变回</span> $x$ 的操作。</p>
                <div class="math-formula">
                    若 $y = f(x)$，则 $x = f^{-1}(y)$
                </div>
                <p><span class="highlight">注意</span>：只有单调函数（严格一对一的函数）才有反函数。</p>
            </div>
            <div class="visualization" id="vis-inverse-machine"></div>
        </div>

        <!-- 幻灯片33：反函数图像 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>反函数与原函数</h3>
                <ul>
                    <li>原函数 $f(x)$ 的<span class="highlight">定义域</span>是反函数 $f^{-1}(x)$ 的<span class="highlight">值域</span>。</li>
                    <li>原函数 $f(x)$ 的<span class="highlight">值域</span>是反函数 $f^{-1}(x)$ 的<span class="highlight">定义域</span>。</li>
                </ul>
                <p>函数 $y=f(x)$ 和它的反函数 $y=f^{-1}(x)$ 的图像关于直线 <span class="highlight">$y=x$ 对称</span>。</p>
            </div>
            <div class="visualization" id="vis-inverse-graph"></div>
        </div>

        <!-- 幻灯片34：指对数互为反函数 (iframe) -->
        <div class="slide">
            <div class="iframe-container">
                <iframe id="iframe-inverse" src="指对数互为反函数.html" style="width: 100%; height: 100%; border: none;"></iframe>
                <div class="iframe-nav-overlay" data-slide="34"></div>
            </div>
        </div>

        <!-- 幻灯片35：复合函数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>复合函数</h3>
                <p>如果 $u=g(x)$，而 $y=f(u)$，那么 $y=f(g(x))$ 就是一个复合函数。</p>
                <ul>
                    <li>$g(x)$ 是<span class="highlight">内层函数</span>。</li>
                    <li>$f(u)$ 是<span class="highlight">外层函数</span>。</li>
                </ul>
                <p>计算时，要<span class="highlight">由内向外</span>，层层计算。</p>
                <p>1. 先算内层函数：$u = g(x)$</p>
                <p>2. 再把结果 $u$ 代入外层函数：$y = f(u)$</p>
            </div>
            <div class="visualization" id="vis-composite-machine"></div>
        </div>

        <!-- 翻页按钮 -->
        <div class="nav-buttons">
            <button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">‹</button>
            <button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">›</button>
        </div>

        <div class="page-indicator" id="page-indicator">1 / 36</div>
</div>

<!-- 全局动画控制面板 -->
<div class="global-animation-controls" id="globalAnimationControls">
    <button class="global-control-btn" id="globalPlayPauseBtn">暂停</button>
    <button class="global-control-btn" id="globalSpeedBtn">1.0x</button>
</div>

<!-- 浮动菜单按钮 -->
<div id="floating-menu">
    <div id="menu-toggle" class="menu-toggle">
        <span class="menu-icon">☰</span>
    </div>
    <div id="menu-content" class="menu-content">
        <a href="../网页资源/lab 1-1.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">指数运算实验室</span>
        </a>
        <a href="../网页资源/lab 1-2.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">对数运算实验室</span>
        </a>
        <a href="../网页资源/lab 1-3.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">区间分类实验室</span>
        </a>
        <a href="../网页资源/lab 1-4.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">函数概念实验室</span>
        </a>
        <a href="../网页资源/lab 1-5.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">函数性质实验室</span>
        </a>
        <a href="../网页资源/lab 1-6.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">基本初等函数实验室</span>
        </a>
        <a href="../网页资源/lab 1-7.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">复合函数实验室</span>
        </a>
        <a href="../网页资源/lab 1-8.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">函数艺术与运动</span>
        </a>
        <a href="../网页资源/lab 1-9.html" target="_blank" class="menu-item">
            <span class="menu-icon">LAB</span>
            <span class="menu-text">函数游戏</span>
        </a>
    </div>
</div>

<!-- 章节目录菜单 -->
<div id="chapter-menu">
    <div id="chapter-toggle" class="menu-toggle">
        <span class="menu-icon">📚</span>
    </div>
    <div id="chapter-content" class="menu-content">
        <a href="#" class="menu-item" onclick="goToSlide(0); toggleChapterMenu();">
            <span class="menu-icon">🏠</span>
            <span class="menu-text">标题页</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(1); toggleChapterMenu();">
            <span class="menu-icon">📋</span>
            <span class="menu-text">目录</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(3); toggleChapterMenu();">
            <span class="menu-icon">1</span>
            <span class="menu-text">集合、常量与变量</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(4); toggleChapterMenu();">
            <span class="menu-icon">2</span>
            <span class="menu-text">区间表示法</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(5); toggleChapterMenu();">
            <span class="menu-icon">3</span>
            <span class="menu-text">函数基础</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(6); toggleChapterMenu();">
            <span class="menu-icon">4</span>
            <span class="menu-text">定义域与值域</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(10); toggleChapterMenu();">
            <span class="menu-icon">5</span>
            <span class="menu-text">指数运算</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(16); toggleChapterMenu();">
            <span class="menu-icon">6</span>
            <span class="menu-text">对数运算</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(24); toggleChapterMenu();">
            <span class="menu-icon">7</span>
            <span class="menu-text">函数性质</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(32); toggleChapterMenu();">
            <span class="menu-icon">8</span>
            <span class="menu-text">反函数</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(35); toggleChapterMenu();">
            <span class="menu-icon">9</span>
            <span class="menu-text">复合函数</span>
        </a>
    </div>
</div>

<script>
        // ========== 基础导航功能 ==========
        let slides, totalSlides, counter, currentSlide = 0;
        let currentAnimation;

        // 全局动画控制变量
        let globalAnimationPlaying = true;
        let globalAnimationSpeed = 1.0;
        let currentAnimationFunction = null;

        const animationState = {
            isPaused: false,
            speed: 1,
            resumeCallback: null,
        };

        function nextSlide() {
            if (!slides || totalSlides === 0) return;
            currentSlide = (currentSlide + 1) % totalSlides;
            showSlide(currentSlide);
        }

        function previousSlide() {
            if (!slides || totalSlides === 0) return;
            currentSlide = (currentSlide - 1 + totalSlides) % totalSlides;
            showSlide(currentSlide);
        }

        function showSlide(index) {
            if (!slides || index < 0 || index >= totalSlides) return;
            
            slides.forEach(slide => slide.classList.remove('active'));
            currentSlide = index;
            slides[currentSlide].classList.add('active');
            
            counter.textContent = `${currentSlide + 1} / ${totalSlides}`;
            updateNavButtons();
            
            // 更新控制面板可见性
            updateControlPanelVisibility();
            
            // 运行当前幻灯片的可视化
            runVisualization(currentSlide);
            
            // 渲染数学公式
            setTimeout(() => renderMathJax(slides[currentSlide]), 50);
        }

        function updateNavButtons() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            if (prevBtn && nextBtn) {
                prevBtn.disabled = (currentSlide === 0);
                nextBtn.disabled = (currentSlide === totalSlides - 1);
            }
        }

        // 全局动画控制函数
        function initGlobalAnimationControls() {
            const playPauseBtn = document.getElementById('globalPlayPauseBtn');
            const speedBtn = document.getElementById('globalSpeedBtn');

            // 速度选项：0.5x, 1x, 1.5x, 2x, 3x, 4x, 6x
            const speedOptions = [0.5, 1, 1.5, 2, 3, 4, 6];
            let currentSpeedIndex = 1; // 默认1x

            // 播放/暂停按钮
            playPauseBtn.addEventListener('click', () => {
                globalAnimationPlaying = !globalAnimationPlaying;
                playPauseBtn.textContent = globalAnimationPlaying ? '暂停' : '播放';
                playPauseBtn.className = globalAnimationPlaying ? 'global-control-btn' : 'global-control-btn pause';

                // 更新动画状态
                animationState.isPaused = !globalAnimationPlaying;
            });

            // 速度按钮（循环切换）
            speedBtn.addEventListener('click', () => {
                currentSpeedIndex = (currentSpeedIndex + 1) % speedOptions.length;
                globalAnimationSpeed = speedOptions[currentSpeedIndex];
                speedBtn.textContent = globalAnimationSpeed.toFixed(1) + 'x';
                animationState.speed = globalAnimationSpeed;
            });
        }

        // 更新控制面板可见性
        function updateControlPanelVisibility() {
            const controlPanel = document.getElementById('globalAnimationControls');
            const currentSlideElement = slides[currentSlide];

            // 检查当前页面是否有动画
            const hasAnimation = currentSlideElement && (
                currentSlideElement.querySelector('.visualization') ||
                currentSlideElement.querySelector('iframe')
            );

            controlPanel.style.display = hasAnimation ? 'flex' : 'none';
        }

        // 初始化悬浮菜单
        function initFloatingMenus() {
            // 浮动菜单功能
            const menuToggle = document.getElementById('menu-toggle');
            const menuContent = document.getElementById('menu-content');
            
            if (menuToggle && menuContent) {
                menuToggle.addEventListener('click', function(e) {
                    e.stopPropagation();
                    menuToggle.classList.toggle('active');
                    menuContent.classList.toggle('active');
                });
                
                // 点击页面其他地方关闭菜单
                document.addEventListener('click', function(e) {
                    if (!menuToggle.contains(e.target) && !menuContent.contains(e.target)) {
                        menuToggle.classList.remove('active');
                        menuContent.classList.remove('active');
                    }
                });
                
                // 防止菜单内容点击时关闭菜单
                menuContent.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }

            // 章节目录菜单功能
            const chapterToggle = document.getElementById('chapter-toggle');
            const chapterContent = document.getElementById('chapter-content');
            
            if (chapterToggle && chapterContent) {
                chapterToggle.addEventListener('click', function(e) {
                    e.stopPropagation();
                    chapterToggle.classList.toggle('active');
                    chapterContent.classList.toggle('active');
                });
                
                // 点击页面其他地方关闭菜单
                document.addEventListener('click', function(e) {
                    if (!chapterToggle.contains(e.target) && !chapterContent.contains(e.target)) {
                        chapterToggle.classList.remove('active');
                        chapterContent.classList.remove('active');
                    }
                });
                
                // 防止菜单内容点击时关闭菜单
                chapterContent.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
        }

        // 章节目录菜单切换函数
        function toggleChapterMenu() {
            const chapterToggle = document.getElementById('chapter-toggle');
            const chapterContent = document.getElementById('chapter-content');
            
            if (chapterToggle && chapterContent) {
                chapterToggle.classList.toggle('active');
                chapterContent.classList.toggle('active');
            }
        }

        // 跳转到指定幻灯片
        function goToSlide(index) {
            if (index >= 0 && index < totalSlides) {
                showSlide(index);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            slides = document.querySelectorAll('.slide');
            totalSlides = slides.length;
            counter = document.getElementById('page-indicator');
            
            // 初始化全局动画控制
            initGlobalAnimationControls();
            
            // 初始化悬浮菜单
            initFloatingMenus();
            
            showSlide(0);
            
            // 键盘导航
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ' ||
                    e.key === 'PageDown' || e.key === 'Enter') {
                    e.preventDefault();
                    nextSlide();
                }
                else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp' ||
                         e.key === 'PageUp' || e.key === 'Backspace') {
                    e.preventDefault();
                    previousSlide();
                }
                else if (e.key === 'Home') {
                    e.preventDefault();
                    showSlide(0);
                }
                else if (e.key === 'End') {
                    e.preventDefault();
                    showSlide(totalSlides - 1);
                }
            });
            
            // 鼠标滚轮导航
            document.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY > 0) {
                    nextSlide();
                } else {
                    previousSlide();
                }
            }, { passive: false });
        });

        // ========== MathJax 渲染函数 ==========
        const renderMathJax = async (container) => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                try {
                    await window.MathJax.typesetPromise([container]);
                } catch (error) {
                    console.warn('MathJax rendering failed:', error);
                }
            }
        };

        const renderMathJaxInContainer = async (containerId) => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                try {
                    const container = document.getElementById(containerId);
                    if (container) {
                        await window.MathJax.typesetPromise([container]);
                    }
                } catch (error) {
                    console.warn('MathJax container rendering failed:', error);
                }
            }
        };

        // ========== D3.js 辅助函数 ==========
        function setupD3(containerId, margins = {top: 40, right: 40, bottom: 40, left: 40}) {
            const container = d3.select(`#${containerId}`);
            if (container.empty()) {
                console.error("Container not found:", containerId);
                return null;
            }
            container.html('');

            const bounds = container.node().getBoundingClientRect();
            if (bounds.width === 0 || bounds.height === 0) return null;

            const svg = container.append('svg')
                .attr('width', bounds.width)
                .attr('height', bounds.height);

            const width = bounds.width - margins.left - margins.right;
            const height = bounds.height - margins.top - margins.bottom;

            const g = svg.append('g')
                .attr('transform', `translate(${margins.left}, ${margins.top})`);

            return { container, svg, g, width, height };
        }

        function drawAxes(g, xScale, yScale, width, height) {
            g.append('g')
                .attr('transform', `translate(0, ${yScale(0)})`)
                .call(d3.axisBottom(xScale).ticks(10))
                .call(g => g.select(".domain").attr("stroke-width", 1.5).attr("stroke", "#333"))
                .call(g => g.selectAll(".tick line").remove());

            g.append('g')
                .attr('transform', `translate(${xScale(0)}, 0)`)
                .call(d3.axisLeft(yScale).ticks(10))
                .call(g => g.select(".domain").attr("stroke-width", 1.5).attr("stroke", "#333"))
                .call(g => g.selectAll(".tick line").remove());
        }

        function animatePath(path) {
            if (!path.node()) return;
            const totalLength = path.node().getTotalLength();
            path.attr("stroke-dasharray", totalLength + " " + totalLength)
                .attr("stroke-dashoffset", totalLength)
                .transition()
                .duration(2000)
                .ease(d3.easeLinear)
                .attr("stroke-dashoffset", 0);
        }

        // ========== 可视化函数 ==========
        
        // 幻灯片3：常量与变量可视化
        function visualizeVariables(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;

            // 常量示例（π）
            g.append("circle")
                .attr("cx", width * 0.25)
                .attr("cy", height * 0.5)
                .attr("r", 10)
                .attr("fill", "var(--danger-color)");
            
            g.append("text")
                .attr("x", width * 0.25)
                .attr("y", height * 0.5 + 40)
                .text("常量 π")
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em");

            // 变量示例（动态移动的点）
            g.append("line")
                .attr("x1", width * 0.6)
                .attr("y1", height * 0.5)
                .attr("x2", width * 0.9)
                .attr("y2", height * 0.5)
                .attr("stroke", "#ccc")
                .attr("stroke-width", 2);
            
            const variablePoint = g.append("circle")
                .attr("cy", height * 0.5)
                .attr("r", 10)
                .attr("fill", "var(--primary-color)");
            
            g.append("text")
                .attr("x", width * 0.75)
                .attr("y", height * 0.5 + 40)
                .text("变量 x")
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em");

            function movePoint() {
                variablePoint.attr("cx", width * 0.6)
                    .transition().duration(2000).attr("cx", width * 0.9)
                    .transition().duration(2000).attr("cx", width * 0.6)
                    .on("end", movePoint);
            }
            movePoint();
        }

        // 幻灯片4：区间可视化
        function visualizeIntervals(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            
            const axisY = height * 0.2;

            // 闭区间
            g.append("line").attr("x1", 0).attr("y1", axisY).attr("x2", width).attr("y2", axisY).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY).attr("x2", width*0.4).attr("y2", axisY).attr("stroke", "var(--success-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY).attr("r", 5).attr("fill", "var(--success-color)");
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY).attr("r", 5).attr("fill", "var(--success-color)");
            g.append("text").attr("x", width*0.25).attr("y", axisY + 40).text("闭区间 [a, b]").attr("text-anchor", "middle");

            // 开区间
            const axisY2 = height * 0.5;
            g.append("line").attr("x1", 0).attr("y1", axisY2).attr("x2", width).attr("y2", axisY2).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY2).attr("x2", width*0.4).attr("y2", axisY2).attr("stroke", "var(--warning-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY2).attr("r", 5).attr("fill", "white").attr("stroke", "var(--warning-color)").attr("stroke-width", 2);
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY2).attr("r", 5).attr("fill", "white").attr("stroke", "var(--warning-color)").attr("stroke-width", 2);
            g.append("text").attr("x", width*0.25).attr("y", axisY2 + 40).text("开区间 (a, b)").attr("text-anchor", "middle");

            // 半开区间
            const axisY3 = height * 0.8;
            g.append("line").attr("x1", 0).attr("y1", axisY3).attr("x2", width).attr("y2", axisY3).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY3).attr("x2", width*0.4).attr("y2", axisY3).attr("stroke", "var(--info-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY3).attr("r", 5).attr("fill", "var(--info-color)");
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY3).attr("r", 5).attr("fill", "white").attr("stroke", "var(--info-color)").attr("stroke-width", 2);
            g.append("text").attr("x", width*0.25).attr("y", axisY3 + 40).text("半开区间 [a, b)").attr("text-anchor", "middle");
        }

        // 幻灯片5：函数机器可视化
        function visualizeFunctionMachine(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            // 函数机器
            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };
            
            svg.append("rect")
                .attr("x", machine.x - machine.width / 2)
                .attr("y", machine.y - machine.height / 2)
                .attr("width", machine.width)
                .attr("height", machine.height)
                .attr("rx", 10)
                .attr("fill", "#4a90e2")
                .attr("stroke", "#357ABD")
                .attr("stroke-width", 3);

            svg.append("text")
                .text("f(x) = 2x + 1")
                .attr("x", machine.x)
                .attr("y", machine.y)
                .attr("text-anchor", "middle")
                .attr("dy", ".3em")
                .attr("fill", "white")
                .style("font-size", "18px")
                .style("font-weight", "bold");

            // 输入漏斗
            svg.append("path")
                .attr("d", `M ${machine.x - 50} ${machine.y - machine.height/2 - 50} 
                           L ${machine.x - 25} ${machine.y - machine.height/2} 
                           H ${machine.x + 25} 
                           L ${machine.x + 50} ${machine.y - machine.height/2 - 50} Z`)
                .attr("fill", "#a2cffe");

            // 输出管道
            svg.append("rect")
                .attr("x", machine.x - 25)
                .attr("y", machine.y + machine.height/2)
                .attr("width", 50)
                .attr("height", 30)
                .attr("fill", "#a2cffe");

            // 动画：数字通过机器
            function animateNumber() {
                const input = Math.floor(Math.random() * 10) - 5;
                const output = 2 * input + 1;

                const inputText = svg.append("text")
                    .text(input)
                    .attr("x", machine.x)
                    .attr("y", machine.y - machine.height/2 - 60)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#333")
                    .style("font-size", "20px")
                    .style("font-weight", "bold");

                inputText.transition()
                    .duration(1000)
                    .attr("y", machine.y)
                    .style("opacity", 0)
                    .remove();

                setTimeout(() => {
                    const outputText = svg.append("text")
                        .text(output)
                        .attr("x", machine.x)
                        .attr("y", machine.y + machine.height/2 + 30)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#2ecc71")
                        .style("font-size", "20px")
                        .style("font-weight", "bold")
                        .style("opacity", 0);

                    outputText.transition()
                        .duration(500)
                        .style("opacity", 1)
                        .transition()
                        .delay(1500)
                        .duration(500)
                        .style("opacity", 0)
                        .remove();
                }, 1000);
            }

            // 每2秒运行一次动画
            animateNumber();
            setInterval(animateNumber, 3000);
        }

        // 幻灯片6：定义域可视化
        function visualizeDomain(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            const svg = container.append("svg").attr("width", width).attr("height", height);

            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };

            // 函数机器
            svg.append("rect")
                .attr("x", machine.x - machine.width / 2)
                .attr("y", machine.y - machine.height / 2)
                .attr("width", machine.width)
                .attr("height", machine.height)
                .attr("rx", 10)
                .attr("fill", "#4a90e2")
                .attr("stroke", "#357ABD")
                .attr("stroke-width", 3);

            svg.append("text")
                .text("f(x) = √(x-2)")
                .attr("x", machine.x)
                .attr("y", machine.y)
                .attr("text-anchor", "middle")
                .attr("dy", ".3em")
                .attr("fill", "white")
                .style("font-size", "18px")
                .style("font-weight", "bold");

            // 数轴
            const numLineY = height - 50;
            const scaleX = d3.scaleLinear().domain([-2, 10]).range([50, width - 50]);
            
            svg.append("line")
                .attr("x1", scaleX.range()[0])
                .attr("y1", numLineY)
                .attr("x2", scaleX.range()[1])
                .attr("y2", numLineY)
                .attr("stroke", "#333");

            // 定义域高亮
            svg.append("rect")
                .attr("x", scaleX(2))
                .attr("y", numLineY - 10)
                .attr("width", scaleX(10) - scaleX(2))
                .attr("height", 20)
                .attr("fill", "#50e3c2")
                .attr("opacity", 0.5);

            svg.append("text")
                .text("定义域: x ≥ 2")
                .attr("x", scaleX(6))
                .attr("y", numLineY - 25)
                .attr("text-anchor", "middle")
                .style("font-weight", "bold")
                .style("fill", "#2c3e50");

            // 粒子动画
            function generateParticle() {
                const value = Math.floor(Math.random() * 12) - 1;
                const isValid = value >= 2;
                
                const particle = svg.append("g")
                    .attr("transform", `translate(${width * 0.2}, ${height * 0.2})`);

                particle.append("circle")
                    .attr("r", 15)
                    .attr("fill", isValid ? "#50e3c2" : "#e74c3c");
                
                particle.append("text")
                    .text(value)
                    .attr("text-anchor", "middle")
                    .attr("dy", ".3em")
                    .attr("fill", "white")
                    .style("font-size", "14px");

                particle.transition()
                    .duration(2000)
                    .attr("transform", `translate(${machine.x}, ${machine.y - machine.height/2 - 20})`);

                if (isValid) {
                    particle.transition()
                        .delay(2000)
                        .duration(1000)
                        .attr("transform", `translate(${machine.x}, ${machine.y + machine.height/2 + 20})`)
                        .style("opacity", 0)
                        .remove();
                } else {
                    particle.transition()
                        .delay(2000)
                        .duration(1000)
                        .attr("transform", `translate(${machine.x + 100}, ${machine.y - machine.height - 50})`)
                        .style("opacity", 0)
                        .remove();
                }
            }

            setInterval(generateParticle, 1500);
        }

        // 幻灯片7：值域可视化
        function visualizeRange(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            const svg = container.append("svg").attr("width", width).attr("height", height);

            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };

            svg.append("rect")
                .attr("x", machine.x - machine.width / 2)
                .attr("y", machine.y - machine.height / 2)
                .attr("width", machine.width)
                .attr("height", machine.height)
                .attr("rx", 10)
                .attr("fill", "#4a90e2");

            svg.append("text")
                .text("f(x) = x²")
                .attr("x", machine.x)
                .attr("y", machine.y)
                .attr("text-anchor", "middle")
                .attr("dy", ".3em")
                .attr("fill", "white")
                .style("font-size", "20px");

            // 值域轴
            const numLineX = width - 100;
            const scaleY = d3.scaleLinear().domain([-2, 10]).range([height - 50, 50]);
            
            svg.append("line")
                .attr("x1", numLineX)
                .attr("y1", scaleY.range()[0])
                .attr("x2", numLineX)
                .attr("y2", scaleY.range()[1])
                .attr("stroke", "#333");

            // 值域高亮
            svg.append("rect")
                .attr("x", numLineX - 10)
                .attr("y", scaleY(10))
                .attr("width", 20)
                .attr("height", scaleY(0) - scaleY(10))
                .attr("fill", "#f5a623")
                .attr("opacity", 0.5);

            svg.append("text")
                .text("值域: y ≥ 0")
                .attr("x", numLineX)
                .attr("y", scaleY(10) - 10)
                .attr("text-anchor", "middle")
                .style("font-weight", "bold")
                .style("fill", "#2c3e50");

            // 粒子动画
            function generateParticle() {
                const value = (Math.random() * 6) - 3;
                const outputValue = value * value;

                const particle = svg.append("g")
                    .attr("transform", `translate(${50}, ${machine.y})`);

                particle.append("circle")
                    .attr("r", 15)
                    .attr("fill", "#50e3c2");
                
                particle.append("text")
                    .text(value.toFixed(1))
                    .attr("text-anchor", "middle")
                    .attr("dy", ".3em")
                    .attr("fill", "white");

                particle.transition()
                    .duration(1500)
                    .attr("transform", `translate(${machine.x - machine.width/2 - 20}, ${machine.y})`)
                    .transition()
                    .duration(500)
                    .style("opacity", 0)
                    .remove()
                    .on("end", () => {
                        const outputParticle = svg.append("g")
                            .attr("transform", `translate(${machine.x + machine.width/2 + 20}, ${machine.y})`);
                        
                        outputParticle.append("circle")
                            .attr("r", 15)
                            .attr("fill", "#f5a623");
                        
                        outputParticle.append("text")
                            .text(outputValue.toFixed(1))
                            .attr("text-anchor", "middle")
                            .attr("dy", ".3em")
                            .attr("fill", "white");

                        outputParticle.transition()
                            .duration(1500)
                            .attr("transform", `translate(${numLineX}, ${scaleY(outputValue)})`)
                            .transition()
                            .duration(500)
                            .attr("r", 5)
                            .style("opacity", 0.7);
                    });
            }

            setInterval(generateParticle, 2000);
        }

        // 幻灯片8：基本初等函数星系可视化
        function visualizeElementaryIntro(containerId) {
            const setup = setupD3(containerId, { top: 0, right: 0, bottom: 0, left: 0 });
            if (!setup) return;
            const { container, svg, g, width, height } = setup;

            // 设置星空背景
            svg.style('background', 'radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%)');

            const centerX = width / 2;
            const centerY = height / 2;

            // 创建星空背景
            function createStarField() {
                const starCount = 50;
                const stars = [];

                for (let i = 0; i < starCount; i++) {
                    stars.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        radius: Math.random() * 1.5 + 0.5,
                        opacity: Math.random() * 0.6 + 0.4
                    });
                }

                const starGroup = g.append('g').attr('class', 'star-field');
                starGroup.selectAll('.star')
                    .data(stars)
                    .enter()
                    .append('circle')
                    .attr('class', 'star')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', d => d.radius)
                    .attr('fill', 'white')
                    .attr('opacity', d => d.opacity);
            }

            createStarField();

            // 添加标题
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 60)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .style('font-size', '48px')
                .style('font-weight', 'bold')
                .text('基本初等函数星系');

            // 定义行星数据
            const planetsData = [
                { name: "幂函数", color: "#e74c3c", radius: 22, orbitRadius: 100, speed: 0.002 },
                { name: "指数函数", color: "#3498db", radius: 25, orbitRadius: 160, speed: 0.0015 },
                { name: "对数函数", color: "#2ecc71", radius: 25, orbitRadius: 220, speed: 0.0012 },
                { name: "三角函数", color: "#f1c40f", radius: 28, orbitRadius: 280, speed: 0.001 },
                { name: "反三角函数", color: "#9b59b6", radius: 20, orbitRadius: 340, speed: 0.0008 },
                { name: "常数函数", color: "#bdc3c7", radius: 18, orbitRadius: 60, speed: 0.0025 }
            ];

            // 绘制轨道
            g.selectAll(".orbit")
                .data(planetsData)
                .enter().append("circle")
                .attr("class", "orbit")
                .attr("cx", centerX)
                .attr("cy", centerY)
                .attr("r", d => d.orbitRadius)
                .attr("fill", "none")
                .attr("stroke", "rgba(255, 255, 255, 0.3)")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "5, 5");

            // 绘制中央太阳
            const sun = g.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);

            sun.append("circle")
                .attr("r", 45)
                .attr("fill", "#f1c40f");

            sun.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.35em")
                .attr("fill", "#333")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .text("初等函数");

            // 创建行星
            const planets = g.selectAll(".planet")
                .data(planetsData)
                .enter().append("g")
                .attr("class", "planet");

            planets.append("circle")
                .attr("r", d => d.radius)
                .attr("fill", d => d.color)
                .attr("stroke", d => d.color)
                .attr("stroke-width", 1)
                .attr("stroke-opacity", 0.5);

            planets.append("text")
                .attr("dy", d => d.radius + 15)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .text(d => d.name);

            // 行星运行动画
            let angle = 0;
            function animate() {
                angle += 0.01;
                planets.attr("transform", d => {
                    const planetAngle = angle * d.speed;
                    const x = centerX + d.orbitRadius * Math.cos(planetAngle);
                    const y = centerY + d.orbitRadius * Math.sin(planetAngle);
                    return `translate(${x}, ${y})`;
                });
                requestAnimationFrame(animate);
            }
            animate();
        }

        // 幻灯片10：指数定义可视化
        function visualizeExponents(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            
            const data = [
                { x: 0, y: 1, label: "2^0" },
                { x: 1, y: 2, label: "2^1" },
                { x: 2, y: 4, label: "2^2" },
                { x: 3, y: 8, label: "2^3" }
            ];
            
            const xScale = d3.scaleLinear().domain([-1, 4]).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);
            
            // 绘制柱状图
            g.selectAll("rect")
                .data(data)
                .enter().append("rect")
                .attr("x", d => xScale(d.x) - width/10)
                .attr("y", height)
                .attr("width", width/5)
                .attr("height", 0)
                .attr("fill", "var(--primary-color)")
                .transition().duration(1000).delay((d, i) => i * 300)
                .attr("y", d => yScale(d.y))
                .attr("height", d => height - yScale(d.y));
            
            // 添加标签
            g.selectAll(".label")
                .data(data)
                .enter().append("text")
                .attr("class", "label")
                .attr("x", d => xScale(d.x))
                .attr("y", d => yScale(d.y) - 10)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em")
                .attr("fill", "var(--text-color)")
                .style("opacity", 0)
                .text(d => d.y)
                .transition().duration(500).delay((d, i) => 1000 + i * 300)
                .style("opacity", 1);
        }

        // 幻灯片11：指数运算法则1可视化
        function visualizeExponentRules1(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;

            const mulY = height * 0.25;
            
            // 乘法法则动画
            const mulGroup = g.append("g");
            const mulText = mulGroup.append("text")
                .attr("x", width / 2)
                .attr("y", mulY - 30)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.8em")
                .attr("fill", "var(--text-color)");
            
            mulText.append("tspan").text("2³ × 2² = 2⁵");

            // 动画圆圈
            const circles1 = g.selectAll(".c1")
                .data(d3.range(3))
                .enter().append("circle")
                .attr("class", "c1")
                .attr("cy", mulY)
                .attr("cx", (d, i) => width * 0.2 + i * 40)
                .attr("r", 15)
                .attr("fill", "var(--primary-color)");
            
            const circles2 = g.selectAll(".c2")
                .data(d3.range(2))
                .enter().append("circle")
                .attr("class", "c2")
                .attr("cy", mulY)
                .attr("cx", (d, i) => width * 0.8 - i * 40)
                .attr("r", 15)
                .attr("fill", "var(--accent-color)");
            
            // 合并动画
            circles1.transition().delay(1000).duration(1500)
                .attr("cx", (d, i) => width/2 - 100 + i * 40);
            
            circles2.transition().delay(1000).duration(1500)
                .attr("cx", (d, i) => width/2 + 20 + i * 40);

            // 除法法则
            const divY = height * 0.75;
            g.append("line")
                .attr("x1", 0).attr("y1", height/2)
                .attr("x2", width).attr("y2", height/2)
                .attr("stroke", "#ddd").attr("stroke-width", 2);
            
            const divText = g.append("text")
                .attr("x", width / 2)
                .attr("y", divY - 50)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.8em")
                .attr("fill", "var(--text-color)")
                .text("5⁴ ÷ 5² = 5²");
        }

        // 幻灯片12：指数运算法则2可视化
        function visualizeExponentRules2(containerId) {
            const setup = setupD3(containerId, {top: 0, right: 0, bottom: 0, left: 0});
            if (!setup) return;
            const { svg, g, width, height } = setup;

            svg.style("background", "transparent");

            // 标题
            g.append("text")
                .attr("x", width/2)
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .attr("font-size", "2em")
                .attr("font-weight", "300")
                .attr("fill", "#2d3436")
                .text("(2³)⁴ = ?");

            // 大圆圈动画
            setTimeout(() => {
                const bigCircle = g.append("circle")
                    .attr("cx", width/2)
                    .attr("cy", height/2)
                    .attr("r", 0)
                    .attr("fill", "#74b9ff")
                    .attr("stroke", "#0984e3")
                    .attr("stroke-width", 3)
                    .style("opacity", 0.8);

                bigCircle.transition()
                    .duration(1000)
                    .attr("r", 60);

                g.append("text")
                    .attr("x", width/2)
                    .attr("y", height/2 + 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "1.8em")
                    .attr("font-weight", "bold")
                    .attr("fill", "white")
                    .text("2³")
                    .style("opacity", 0)
                    .transition()
                    .delay(800)
                    .duration(600)
                    .style("opacity", 1);
            }, 1000);

            // 分散成4个小圆
            setTimeout(() => {
                const positions = [
                    {x: width/2, y: height/2 - 120},
                    {x: width/2 + 120, y: height/2},
                    {x: width/2, y: height/2 + 120},
                    {x: width/2 - 120, y: height/2}
                ];

                positions.forEach((pos, i) => {
                    const bubble = g.append("circle")
                        .attr("cx", width/2)
                        .attr("cy", height/2)
                        .attr("r", 15)
                        .attr("fill", "#74b9ff")
                        .attr("stroke", "#0984e3")
                        .attr("stroke-width", 2)
                        .style("opacity", 0);

                    bubble.transition()
                        .delay(500 + i * 150)
                        .duration(100)
                        .style("opacity", 0.8)
                        .transition()
                        .duration(800)
                        .attr("cx", pos.x)
                        .attr("cy", pos.y)
                        .attr("r", 35);

                    g.append("text")
                        .attr("x", width/2)
                        .attr("y", height/2)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "1.2em")
                        .attr("font-weight", "bold")
                        .attr("fill", "white")
                        .text("2³")
                        .style("opacity", 0)
                        .transition()
                        .delay(600 + i * 150)
                        .duration(800)
                        .attr("x", pos.x)
                        .attr("y", pos.y + 5)
                        .style("opacity", 1);
                });
            }, 3000);

            // 最终结果
            setTimeout(() => {
                g.append("text")
                    .attr("x", width/2)
                    .attr("y", height - 50)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "2.2em")
                    .attr("font-weight", "bold")
                    .attr("fill", "#e74c3c")
                    .text("(2³)⁴ = 2¹² = 4096")
                    .style("opacity", 0)
                    .transition()
                    .duration(800)
                    .style("opacity", 1);
            }, 6000);
        }

        // 幻灯片13：零指数与负指数可视化  
// 幻灯片13（第14页）：零指数与负指数可视化 - 增强版
function visualizeSpecialExponentsNew(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

        const sectionHeight = height / 2;
        const sectionWidth = width;

        // --- Section 1: Zero Exponent ---
    const zeroGroup = g.append("g");
        const scaleGroup = zeroGroup.append("g")
            .attr("transform", `translate(${sectionWidth / 2}, ${sectionHeight * 0.6})`);

        scaleGroup.append("polygon").attr("points", "-10,0 10,0 0,15").attr("fill", "#555");
        const beam = scaleGroup.append("line").attr("x1", -100).attr("x2", 100).attr("stroke", "#555").attr("stroke-width", 4);
        const leftPan = scaleGroup.append("text").attr("x", -70).attr("y", -15).attr("font-size", "1.5em").attr("text-anchor", "middle");
        const rightPan = scaleGroup.append("text").attr("x", 70).attr("y", -15).attr("font-size", "1.5em").attr("text-anchor", "middle");

        // 零指数动画 - 立即开始
        leftPan.append("tspan").text("a³").style("opacity", 0).transition().delay(0).duration(500).style("opacity", 1);
        rightPan.append("tspan").text("a³").style("opacity", 0).transition().delay(0).duration(500).style("opacity", 1);

        setTimeout(() => {
            leftPan.html("a³ ÷ a³");
            rightPan.html("a³ ÷ a³");
        }, 800);

        setTimeout(() => {
            beam.transition().duration(500).attr("transform", "rotate(5)").transition().duration(500).attr("transform", "rotate(-5)").transition().duration(500).attr("transform", "rotate(0)");
            leftPan.html("a⁰").attr("font-size", "1.5em").attr("fill", "var(--danger-color)");
            rightPan.html("1").attr("font-size", "1.5em").attr("fill", "var(--success-color)");
        }, 1500);

        // --- Section 2: Negative Exponent ---
        g.append("line").attr("x1", 0).attr("y1", sectionHeight).attr("x2", width).attr("y2", sectionHeight).attr("stroke", "#ddd");
        const negGroup2 = g.append("g").attr("transform", `translate(0, ${sectionHeight})`);
        // 负指数动画 - 1秒后开始
        const negTitle = negGroup2.append("text").attr("x", sectionWidth/2).attr("y", sectionHeight * 0.2).attr("text-anchor", "middle").attr("font-size", "1.5em").text("a² ÷ a⁵ = ?").style("opacity", 0).transition().delay(1000).duration(500).style("opacity", 1);

const fraction = negGroup2.append("g").attr("transform", `translate(${sectionWidth/2}, ${sectionHeight * 0.6})`).style("opacity", 0);
const numerator = fraction.selectAll(".num").data("aa".split("")).enter().append("text").attr("class", "num").text("a").attr("x", (d,i) => -25 + i * 25).attr("y", -15).attr("font-size", "1.5em");

const denominator = fraction.selectAll(".den").data("aaaaa".split("")).enter().append("text").attr("class", "den").text("a").attr("x", (d,i) => -60 + i * 25).attr("y", 25).attr("font-size", "1.5em");


    // ========== 负指数部分 ==========
    const negGroup = g.append("g")
        .attr("transform", `translate(0, ${height/2 + 30})`);

    // 标题
    const negTitleFO = negGroup.append("foreignObject")
        .attr("x", 0)
        .attr("y", 200)
        .attr("width", width)
        .attr("height", 60)
        .html(`<div style="text-align: center; font-size: 24px; font-weight: bold; color: #e74c3c;">
            负指数定律：$a^{-n} = \\frac{1}{a^n}$
        </div>`);

    // 创建交互式示例
    const exampleY = 80;
    const examples = [
        { base: 2, exp: -1, value: 1/2 },
        { base: 2, exp: -2, value: 1/4 },
        { base: 2, exp: -3, value: 1/8 }
    ];

    examples.forEach((ex, i) => {
        const exGroup = negGroup.append("g")
            .attr("transform", `translate(${width * (0.25 + i * 0.25)}, ${exampleY})`);

        // 背景圆
        exGroup.append("circle")
            .attr("r", 45)
            .attr("fill", "#e74c3c")
            .attr("fill-opacity", 0.1)
            .attr("stroke", "#e74c3c")
            .attr("stroke-width", 2)
            .style("opacity", 0)
            .transition()
            .delay(5000 + i * 300)
            .duration(600)
            .style("opacity", 1);

        // 公式
        const formulaFO = exGroup.append("foreignObject")
            .attr("x", -40)
            .attr("y", -20)
            .attr("width", 80)
            .attr("height", 40)
            .html(`<div style="text-align: center; font-size: 18px; color: #c0392b;">
                $2^{${ex.exp}}$
            </div>`)
            .style("opacity", 0);

        formulaFO.transition()
            .delay(5300 + i * 300)
            .duration(600)
            .style("opacity", 1);

        // 可视化分数饼图
        const pieRadius = 25;
        const pieY = 60;

    const arc = d3.arc()
        .innerRadius(0)
            .outerRadius(pieRadius);

        const denominator = Math.pow(2, -ex.exp);
        const pieData = d3.pie()(Array(denominator).fill(1));
        
        const pieGroup = exGroup.append("g")
            .attr("transform", `translate(0, ${pieY})`);
    
    pieGroup.selectAll("path")
        .data(pieData)
        .enter()
        .append("path")
        .attr("d", arc)
            .attr("fill", (d, j) => j === 0 ? "#e74c3c" : "#fce4ec")
        .attr("stroke", "#fff")
            .attr("stroke-width", 1)
        .style("opacity", 0)
        .transition()
            .delay(5600 + i * 300)
            .duration(600)
        .style("opacity", 1);

        // 数值标签
        const valueFO = exGroup.append("foreignObject")
            .attr("x", -40)
            .attr("y", pieY + pieRadius + 10)
            .attr("width", 180)
            .attr("height", 30)
            .html(`<div style="text-align: center; font-size: 14px; color: #7f8c8d;">
                $= \\frac{1}{${denominator}} = ${ex.value}$
            </div>`)
            .style("opacity", 0);

        valueFO.transition()
            .delay(6000 + i * 300)
        .duration(600)
        .style("opacity", 1);
    });

    // 渲染所有MathJax公式
    setTimeout(() => {
        renderMathJaxInContainer(containerId);
    }, 100);
}
 // 幻灯片14（第15页）：分数指数可视化 - 修复版
        function visualizeFractionalExponents(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    // 清除之前的内容
    g.selectAll("*").remove();

    // 标题
    const titleFO = g.append("foreignObject")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", 50)
        .html(`<div style="text-align: center; font-size: 28px; font-weight: bold; color: #2c3e50; padding-top: 10px;">
            分数指数的意义：$a^{\\frac{m}{n}} = \\sqrt[n]{a^m}$
        </div>`);

    // 创建三个交互式示例
    const examples = [
        { base: 27, numerator: 1, denominator: 3, result: 3, color: "#e74c3c" },
        { base: 16, numerator: 1, denominator: 2, result: 4, color: "#3498db" },
        { base: 8, numerator: 2, denominator: 3, result: 4, color: "#2ecc71" }
    ];

    const cardSpacing = width / 3;

    examples.forEach((ex, i) => {
        const cardGroup = g.append("g")
            .attr("transform", `translate(${cardSpacing * (i + 0.5)}, ${height * 0.5})`);

        // 主圆形背景
        const mainCircle = cardGroup.append("circle")
            .attr("r", 0)
            .attr("fill", ex.color)
            .attr("fill-opacity", 0.15)
            .attr("stroke", ex.color)
            .attr("stroke-width", 3)
            .transition()
            .delay(500 + i * 300)
            .duration(800)
            .attr("r", 80);

        // 步骤1：原始表达式
        const step1FO = cardGroup.append("foreignObject")
            .attr("x", -60)
            .attr("y", -120)
            .attr("width", 120)
            .attr("height", 40)
            .html(`<div style="text-align: center; font-size: 20px; color: ${ex.color}; font-weight: bold;">
                $${ex.base}^{\\frac{${ex.numerator}}{${ex.denominator}}}$
            </div>`)
            .style("opacity", 0);

        step1FO.transition()
            .delay(800 + i * 300)
            .duration(600)
            .style("opacity", 1);

        // 步骤2：根式表示
        const step2FO = cardGroup.append("foreignObject")
            .attr("x", -60)
            .attr("y", -30)
            .attr("width", 120)
            .attr("height", 40)
            .html(`<div style="text-align: center; font-size: 20px; color: #2c3e50;">
                $\\sqrt[${ex.denominator}]{${ex.base}^{${ex.numerator}}}$
            </div>`)
            .style("opacity", 0);

        step2FO.transition()
            .delay(2000 + i * 300)
            .duration(600)
            .style("opacity", 1);

        // 步骤3：结果
        const resultGroup = cardGroup.append("g")
            .attr("transform", "translate(0, 80)");

        const resultCircle = resultGroup.append("circle")
            .attr("r", 0)
            .attr("fill", ex.color)
            .attr("stroke", "#fff")
            .attr("stroke-width", 3);

        resultCircle.transition()
            .delay(3200 + i * 300)
            .duration(600)
            .attr("r", 35);

        const resultText = resultGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.3em")
            .style("font-size", "28px")
            .style("font-weight", "bold")
            .style("fill", "white")
            .text(ex.result)
            .style("opacity", 0);

        resultText.transition()
            .delay(3500 + i * 300)
            .duration(400)
            .style("opacity", 1);

        // 脉动动画
        function pulse() {
            resultCircle.transition()
                .duration(1500)
                .attr("r", 40)
                .transition()
                .duration(1500)
                .attr("r", 35)
                .on("end", pulse);
        }
        setTimeout(() => pulse(), 4000 + i * 300);
    });

    // 底部总结
    const summaryFO = g.append("foreignObject")
        .attr("x", 50)
        .attr("y", height - 60)
        .attr("width", width - 100)
        .attr("height", 50)
        .html(`<div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.9); border-radius: 10px; border: 2px solid #95a5a6;">
            <span style="font-size: 16px; color: #2c3e50;">
                <strong>记忆技巧：</strong> 分数指数中，<span style="color: #e74c3c;">分母是根次</span>，<span style="color: #3498db;">分子是幂次</span>
            </span>
        </div>`)
        .style("opacity", 0);

    summaryFO.transition()
        .delay(5000)
        .duration(800)
        .style("opacity", 1);

    // 渲染MathJax
    setTimeout(() => {
        renderMathJaxInContainer(containerId);
    }, 100);
}


        // 幻灯片16：对数历史可视化 - 增强版
        function visualizeLogHistory(containerId) {
            const setup = setupD3(containerId, { top: 0, right: 0, bottom: 0, left: 0 });
            if (!setup) return;
            const { svg, g, width, height } = setup;

            // 深色背景渐变
            svg.style('background', 'radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0c29 100%)');

            // 动态星空效果
            const stars = g.append("g").attr("class", "stars");
            for(let i = 0; i < 80; i++) {
                const star = stars.append("circle")
                    .attr("cx", Math.random() * width)
                    .attr("cy", Math.random() * height)
                    .attr("r", Math.random() * 2 + 0.5)
                    .attr("fill", "white")
                    .attr("opacity", Math.random() * 0.9 + 0.1);
                
                // 添加闪烁动画
                star.transition()
                    .duration((Math.random() * 3000) + 1000)
                    .attr("opacity", Math.random() * 0.3 + 0.1)
                    .transition()
                    .duration((Math.random() * 2000) + 500)
                    .attr("opacity", Math.random() * 0.9 + 0.1)
                    .on("end", function repeat() {
                        d3.select(this)
                            .transition()
                            .duration((Math.random() * 3000) + 1000)
                            .attr("opacity", Math.random() * 0.3 + 0.1)
                            .transition()
                            .duration((Math.random() * 2000) + 500)
                            .attr("opacity", Math.random() * 0.9 + 0.1)
                            .on("end", repeat);
                    });
            }

            // 添加流星效果
            function createMeteor() {
                const meteor = g.append("circle")
                    .attr("r", 0)
                    .attr("fill", "white")
                    .attr("opacity", 0);
                
                meteor.transition()
                    .duration(0)
                    .attr("cx", Math.random() * width)
                    .attr("cy", Math.random() * height * 0.3)
                    .attr("r", 3)
                    .attr("opacity", 1)
                    .transition()
                    .duration(2000)
                    .attr("cx", Math.random() * width)
                    .attr("cy", height + 50)
                    .attr("opacity", 0)
                    .remove();
            }

            // 定期创建流星
            setInterval(createMeteor, 3000);

            // 标题带发光效果
            const title = g.append("text")
                .attr("x", width/2)
                .attr("y", 80)
                .attr("text-anchor", "middle")
                .style("font-size", "42px")
                .style("font-weight", "bold")
                .style("fill", "#f1c40f")
                .style("text-shadow", "0 0 20px #f1c40f, 0 0 40px #f1c40f")
                .text("对数的历史长河")
                .style("opacity", 0)
                .transition()
                .duration(1500)
                .style("opacity", 1);

            // 流动的时间线
            const timeline = g.append("line")
                .attr("x1", width * 0.1)
                .attr("y1", height/2)
                .attr("x2", width * 0.9)
                .attr("y2", height/2)
                .attr("stroke", "url(#timelineGradient)")
                .attr("stroke-width", 4)
                .style("opacity", 0);

            // 添加时间线渐变
            const defs = svg.append("defs");
            const timelineGradient = defs.append("linearGradient")
                .attr("id", "timelineGradient");
            timelineGradient.append("stop").attr("offset", "0%").style("stop-color", "#3498db");
            timelineGradient.append("stop").attr("offset", "50%").style("stop-color", "#f1c40f");
            timelineGradient.append("stop").attr("offset", "100%").style("stop-color", "#e74c3c");

            timeline.transition()
                .delay(800)
                .duration(2000)
                .style("opacity", 0.8);

            // 历史事件（更丰富的信息）
            const events = [
                { 
                    year: 1614, 
                    title: "对数诞生", 
                    desc: "纳皮尔发明对数", 
                    detail: "《奇妙对数表》出版",
                    x: 0.15, 
                    icon: "📜", 
                    color: "#e74c3c",
                    impact: "革命性突破"
                },
                { 
                    year: 1617, 
                    title: "对数表", 
                    desc: "布里格斯制作常用对数表", 
                    detail: "以10为底的对数",
                    x: 0.3, 
                    icon: "📊", 
                    color: "#3498db",
                    impact: "实用化"
                },
                { 
                    year: 1620, 
                    title: "航海应用", 
                    desc: "对数简化航海计算", 
                    detail: "天文导航革命",
                    x: 0.45, 
                    icon: "⚓", 
                    color: "#2ecc71",
                    impact: "航海时代"
                },
                { 
                    year: 1622, 
                    title: "计算尺", 
                    desc: "滑尺计算器发明", 
                    detail: "机械计算工具",
                    x: 0.6, 
                    icon: "📏", 
                    color: "#f39c12",
                    impact: "计算工具"
                },
                { 
                    year: 1970, 
                    title: "计算器时代", 
                    desc: "电子计算器普及", 
                    detail: "对数功能内置",
                    x: 0.75, 
                    icon: "🖩", 
                    color: "#9b59b6",
                    impact: "数字化"
                },
                { 
                    year: 2024, 
                    title: "AI时代", 
                    desc: "对数在机器学习中的应用", 
                    detail: "深度学习基础",
                    x: 0.9, 
                    icon: "🤖", 
                    color: "#1abc9c",
                    impact: "智能时代"
                }
            ];

            events.forEach((event, i) => {
                const eventGroup = g.append("g")
                    .attr("transform", `translate(${width * event.x}, ${height/2})`)
                    .attr("class", "event-group");

                // 时间点（带脉冲效果）
                const timePoint = eventGroup.append("circle")
                    .attr("r", 0)
                    .attr("fill", event.color)
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 3)
                    .style("filter", `drop-shadow(0 0 10px ${event.color})`);

                timePoint.transition()
                    .delay(1500 + i * 300)
                    .duration(800)
                    .attr("r", 15)
                    .transition()
                    .duration(1000)
                    .attr("r", 12);

                // 脉冲环效果
                const pulseRing = eventGroup.append("circle")
                    .attr("r", 0)
                    .attr("fill", "none")
                    .attr("stroke", event.color)
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.6);

                pulseRing.transition()
                    .delay(2000 + i * 300)
                    .duration(1500)
                    .attr("r", 25)
                    .attr("opacity", 0)
                    .transition()
                    .duration(0)
                    .attr("r", 0)
                    .attr("opacity", 0.6)
                    .on("end", function repeat() {
                        d3.select(this)
                            .transition()
                            .duration(2000)
                            .attr("r", 25)
                            .attr("opacity", 0)
                            .transition()
                            .duration(0)
                            .attr("r", 0)
                            .attr("opacity", 0.6)
                            .on("end", repeat);
                    });

                // 事件卡片（带悬停效果）
                const card = eventGroup.append("g")
                    .attr("transform", `translate(0, ${i % 2 === 0 ? -120 : 120})`)
                    .attr("class", "event-card")
                    .style("cursor", "pointer");

                const cardRect = card.append("rect")
                    .attr("x", -75)
                    .attr("y", -45)
                    .attr("width", 150)
                    .attr("height", 90)
                    .attr("rx", 15)
                    .attr("fill", event.color)
                    .attr("fill-opacity", 0.9)
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 2)
                    .style("filter", `drop-shadow(0 5px 15px rgba(0,0,0,0.3))`)
                    .style("opacity", 0);

                cardRect.transition()
                    .delay(1800 + i * 300)
                    .duration(800)
                    .style("opacity", 1);

                // 悬停效果
                card.on("mouseover", function() {
                    d3.select(this).select("rect")
                        .transition()
                        .duration(200)
                        .attr("fill-opacity", 1)
                        .attr("transform", "scale(1.05)");
                }).on("mouseout", function() {
                    d3.select(this).select("rect")
                        .transition()
                        .duration(200)
                        .attr("fill-opacity", 0.9)
                        .attr("transform", "scale(1)");
                });

                // 图标
                card.append("text")
                    .attr("y", -15)
                    .attr("text-anchor", "middle")
                    .style("font-size", "28px")
                    .text(event.icon)
                    .style("opacity", 0)
                    .transition()
                    .delay(2000 + i * 300)
                    .duration(500)
                    .style("opacity", 1);

                // 年份
                card.append("text")
                    .attr("y", 5)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("font-weight", "bold")
                    .style("fill", "white")
                    .text(event.year)
                    .style("opacity", 0)
                    .transition()
                    .delay(2100 + i * 300)
                    .duration(500)
                    .style("opacity", 1);

                // 描述
                card.append("text")
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("fill", "white")
                    .text(event.desc)
                    .style("opacity", 0)
                    .transition()
                    .delay(2200 + i * 300)
                    .duration(500)
                    .style("opacity", 1);

                // 连接线（带流动效果）
                const connection = eventGroup.append("line")
                    .attr("x1", 0)
                    .attr("y1", 0)
                    .attr("x2", 0)
                    .attr("y2", 0)
                    .attr("stroke", event.color)
                    .attr("stroke-width", 3)
                    .attr("stroke-dasharray", "5, 5")
                    .style("opacity", 0);

                connection.transition()
                    .delay(1700 + i * 300)
                    .duration(800)
                    .attr("y2", i % 2 === 0 ? -85 : 85)
                    .style("opacity", 0.8);

                // 流动动画
                connection.transition()
                    .delay(2500 + i * 300)
                    .duration(2000)
                    .attr("stroke-dashoffset", -20)
                    .transition()
                    .duration(2000)
                    .attr("stroke-dashoffset", 0)
                    .on("end", function repeat() {
                        d3.select(this)
                            .transition()
                            .duration(2000)
                            .attr("stroke-dashoffset", -20)
                            .transition()
                            .duration(2000)
                            .attr("stroke-dashoffset", 0)
                            .on("end", repeat);
                    });
            });

            // 底部说明（带打字机效果）
            const bottomText = g.append("text")
                .attr("x", width/2)
                .attr("y", height - 30)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("fill", "#ecf0f1")
                .style("text-shadow", "0 0 10px #ecf0f1")
                .style("opacity", 0);

            const textContent = "对数：将复杂的乘除运算转化为简单的加减运算，推动人类计算历史的革命";
            let currentText = "";
            let index = 0;

            bottomText.transition()
                .delay(5000)
                .duration(500)
                .style("opacity", 1)
                .on("end", function typeWriter() {
                    if (index < textContent.length) {
                        currentText += textContent[index];
                        bottomText.text(currentText);
                        index++;
                        setTimeout(typeWriter, 80);
                    }
                });

            // 添加交互式时间轴控制
            const controls = g.append("g")
                .attr("transform", `translate(${width/2}, ${height - 80})`)
                .style("opacity", 0);

            controls.transition()
                .delay(8000)
                .duration(1000)
                .style("opacity", 1);

            // 播放/暂停按钮
            const playButton = controls.append("circle")
                .attr("r", 20)
                .attr("fill", "#3498db")
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .style("cursor", "pointer");

            controls.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.3em")
                .style("font-size", "16px")
                .style("fill", "white")
                .text("▶");

            playButton.on("click", function() {
                // 重新播放动画
                location.reload();
            });
        }

        // 幻灯片17：对数定义可视化
        function visualizeLogDefinition(containerId) {
            const svg = d3.select("#animation2");
            if(svg.empty()) return;
            svg.selectAll("*").remove();
            
            const bounds = svg.node().getBoundingClientRect();
            const width = bounds.width, height = bounds.height;
            const centerX = width / 2;
            
            svg.append("text")
                .attr("x", centerX)
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .text("求 log₂(8) = ?");
            
            svg.append("text")
                .attr("x", centerX)
                .attr("y", 80)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("也就是，2的几次方等于8？");

            // 指数过程
            const expGroup = svg.append("g");
            expGroup.append("text")
                .attr("x", 50)
                .attr("y", 150)
                .text("指数过程:")
                .style("font-size", "16px")
                .style("font-weight", "bold");

            // 绘制路径
            let pathData = "M 150 145";
            for (let i = 1; i <= 3; i++) {
                pathData += ` L ${150 + i * 100} 145`;
            }

            const expPath = expGroup.append("path")
                .attr("d", pathData)
                .attr("stroke", "#3498db")
                .attr("stroke-width", 2)
                .attr("fill", "none");

            // 路径动画
            const totalLength = expPath.node().getTotalLength();
            expPath.attr("stroke-dasharray", `${totalLength} ${totalLength}`)
                .attr("stroke-dashoffset", totalLength)
                .transition()
                .duration(2000)
                .ease(d3.easeLinear)
                .attr("stroke-dashoffset", 0);

            // 添加节点
            [1, 2, 4, 8].forEach((val, i) => {
                const node = expGroup.append("g")
                    .attr("transform", `translate(${150 + i * 100}, 145)`)
                    .style("opacity", 0);
                
                node.append("circle")
                    .attr("r", 15)
                    .attr("fill", "#3498db");
                
                node.append("text")
                    .text(val)
                    .attr("y", 40)
                    .attr("text-anchor", "middle")
                    .style("fill", "#2c3e50");
                
                node.transition()
                    .delay(1000 + i * 500)
                    .duration(500)
                    .style("opacity", 1);
            });

            // 答案
            setTimeout(() => {
                svg.append("text")
                    .attr("x", centerX)
                    .attr("y", 300)
                    .attr("text-anchor", "middle")
                    .style("font-size", "24px")
                    .style("fill", "#e74c3c")
                    .style("font-weight", "bold")
                    .text("log₂(8) = 3")
                    .style("opacity", 0)
                    .transition()
                    .duration(500)
                    .style("opacity", 1);
            }, 4000);
        }

        // 幻灯片19：对数性质可视化
        function visualizeLogProperties(containerId) {
            const container = d3.select(`#${containerId}`);
            if(container.empty()) return;
            container.html('');

            const svg = container.append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .style('margin-top', '-60px');

            const bounds = container.node().getBoundingClientRect();
            const width = bounds.width, height = bounds.height;
            const centerX = width / 2;

            const properties = [
                { 
                    title: "乘法在对数世界变成加法",
                    formula: "log(x·y) = log(x) + log(y)",
                    y: height*0.2,
                    color1: "#3498db",
                    color2: "#e74c3c"
                },
                { 
                    title: "除法在对数世界变成减法",
                    formula: "log(x/y) = log(x) - log(y)",
                    y: height*0.5,
                    color1: "#27ae60",
                    color2: "#f39c12"
                },
                { 
                    title: "幂在对数世界变成乘法",
                    formula: "log(x^n) = n·log(x)",
                    y: height*0.8,
                    color1: "#9b59b6",
                    color2: "#e67e22"
                }
            ];

            properties.forEach((prop, index) => {
                const propGroup = svg.append("g")
                    .attr("transform", `translate(${centerX}, ${prop.y})`);

                // 两个圆圈表示运算
                const circle1 = propGroup.append("circle")
                    .attr("cx", -80)
                    .attr("r", 35)
                    .attr("fill", prop.color1)
                    .attr("opacity", 1);
                
                const circle2 = propGroup.append("circle")
                    .attr("cx", 80)
                    .attr("r", 35)
                    .attr("fill", prop.color2)
                    .attr("opacity", 1);

                // 标题
                propGroup.append("text")
                    .attr("x", -200)
                    .attr("y", 0)
                    .attr("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("font-weight", "bold")
                    .text(prop.title);

                // 公式
                propGroup.append("text")
                    .attr("x", -200)
                    .attr("y", 30)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .text(prop.formula);

                // 动画
                function animateProperty() {
                    circle1.transition().duration(2000)
                        .attr("cx", 0)
                        .transition().duration(1000)
                        .attr("cx", -80);
                    
                    circle2.transition().duration(2000)
                        .attr("cx", 0)
                        .transition().duration(1000)
                        .attr("cx", 80);
                }
                
                setTimeout(() => {
                    animateProperty();
                    setInterval(animateProperty, 6000);
                }, index * 1000);
            });
        }

        // 幻灯片20：常用对数系统可视化
        function visualizeCommonLogs(containerId) {
            const svg = d3.select("#animation5");
            if(svg.empty()) return;
            svg.selectAll("*").remove();
            
            const bounds = svg.node().getBoundingClientRect();
            const width = bounds.width, height = bounds.height;
            const centerX = width / 2;

            svg.append("text")
                .attr("x", centerX)
                .attr("y", 40)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("font-weight", "bold")
                .text("常用对数与自然对数对比");

            // 常用对数示例
            const lgGroup = svg.append("g")
                .attr("transform", `translate(${width*0.1}, 80)`);
            
            lgGroup.append("text")
                .text("常用对数 (lg)")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .style("fill", "#e74c3c");
            
            [{input: "10", output: "1"}, {input: "100", output: "2"}, {input: "1000", output: "3"}]
                .forEach((ex, i) => {
                    const y = 30 + i * 40;
                    const g = lgGroup.append("g").style("opacity", 0);
                    
                    g.append("rect")
                        .attr("y", y)
                        .attr("width", 150)
                        .attr("height", 30)
                        .attr("fill", "#ffebee")
                        .attr("stroke", "#e74c3c")
                        .attr("rx", 5);
                    
                    g.append("text")
                        .text(`lg(${ex.input}) = ${ex.output}`)
                        .attr("x", 75)
                        .attr("y", y + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px");
                    
                    g.transition()
                        .delay(500 + i * 300)
                        .duration(500)
                        .style("opacity", 1);
                });

            // 自然对数示例
            const lnGroup = svg.append("g")
                .attr("transform", `translate(${width*0.9 - 150}, 80)`);
            
            lnGroup.append("text")
                .text("自然对数 (ln)")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .style("fill", "#27ae60");
            
            [{input: "e", output: "1"}, {input: "e²", output: "2"}, {input: "1", output: "0"}]
                .forEach((ex, i) => {
                    const y = 30 + i * 40;
                    const g = lnGroup.append("g").style("opacity", 0);
                    
                    g.append("rect")
                        .attr("y", y)
                        .attr("width", 150)
                        .attr("height", 30)
                        .attr("fill", "#e8f5e8")
                        .attr("stroke", "#27ae60")
                        .attr("rx", 5);
                    
                    g.append("text")
                        .text(`ln(${ex.input}) = ${ex.output}`)
                        .attr("x", 75)
                        .attr("y", y + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px");
                    
                    g.transition()
                        .delay(1500 + i * 300)
                        .duration(500)
                        .style("opacity", 1);
                });
        }
  /**
     * 第9页：对数运算法则可视化
     * 功能：动画演示对数运算法则的应用
     * 内容：乘积、商、幂的对数运算法则
     * 动画：数字变换，运算过程展示，支持播放控制
     * 教学目标：掌握对数运算的基本法则
     */

function visualizeLogOperations(containerId) {
        const svg = d3.select("#animation3");
        if(svg.empty()) return;
        svg.selectAll("*").remove();

        const width = 1100, height = 800;
        const margin = {top: 220, right: 50, bottom: 120, left: 50};
        const innerWidth = width - margin.left - margin.right;

        const g = svg.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

        // 创建背景区域
        const upperBg = g.append("rect")
            .attr("x", -30)
            .attr("y", -60)
            .attr("width", innerWidth + 60)
            .attr("height", 100)
            .attr("fill", "#ecf8ff")
            .attr("rx", 10)
            .style("opacity", 0.3);

        const lowerBg = g.append("rect")
            .attr("x", -30)
            .attr("y", 90)
            .attr("width", innerWidth + 60)
            .attr("height", 100)
            .attr("fill", "#f0f9e8")
            .attr("rx", 10)
            .style("opacity", 0.3);

    const numbers = [2, 4, 8, 16, 32, 64, 128, 256, 512];
    const logs = [1, 2, 3, 4, 5, 6, 7, 8, 9];

        const scaleNumbers = d3.scalePoint().domain(numbers).range([0, innerWidth]).padding(0.5);
        const scaleLogs = d3.scalePoint().domain(logs).range([0, innerWidth]).padding(0.5);

        // 数字轴
        const numberAxis = g.append("g").attr("class", "number-axis");
        numberAxis.call(d3.axisBottom(scaleNumbers));
        numberAxis.selectAll("text").style("font-size", "14px").style("font-weight", "bold");

        // 为数字轴添加节点 - 显示2的幂次方
    numbers.forEach((num, i) => {
            const nodeG = numberAxis.append("g")
                .attr("class", "number-node")
                .attr("transform", `translate(${scaleNumbers(num)}, 0)`);
            nodeG.append("circle")
                .attr("r", 18)
                .attr("cy", -30)
                .attr("fill", "#3498db")
            .attr("fill-opacity", 0.2)
                .attr("stroke", "#3498db")
            .attr("stroke-width", 2);

            // 使用外置文本标签来显示公式
            const textElement = nodeG.append("foreignObject")
                .attr("x", -15)
                .attr("y", -38)
                .attr("width", 30)
                .attr("height", 20)
                .html(`<div style="font-size: 12px; text-align: center; color: #2c3e50; font-weight: bold;">$2^{${i+1}}$</div>`);

            // 渲染这个节点的数学公式
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(() => {
                    window.MathJax.typesetPromise([textElement.node()]).catch(error => {
                        console.warn('MathJax rendering failed for number node:', error);
                    });
                }, 50);
            }
        });

        // 对数轴
        const logAxis = g.append("g").attr("transform", `translate(0, 150)`).attr("class", "log-axis");
        logAxis.call(d3.axisBottom(scaleLogs));
        logAxis.selectAll("text").style("font-size", "14px").style("font-weight", "bold");

        // 为对数轴添加节点
        logs.forEach(log => {
            const nodeG = logAxis.append("g")
                .attr("class", "number-node")
                .attr("transform", `translate(${scaleLogs(log)}, 0)`);
            nodeG.append("rect")
                .attr("x", -25)
                .attr("y", -42)
                .attr("width", 50)
                .attr("height", 24)
                .attr("fill", "#2ecc71")
            .attr("fill-opacity", 0.2)
                .attr("stroke", "#2ecc71")
                .attr("stroke-width", 2)
                .attr("rx", 5);

            // 使用外置文本标签来显示公式
            const textElement = nodeG.append("foreignObject")
                .attr("x", -25)
                .attr("y", -38)
                .attr("width", 50)
                .attr("height", 20)
                .html(`<div style="font-size: 10px; text-align: center; color: #2c3e50; font-weight: bold;">$\\log_2(${Math.pow(2, log)})$</div>`);

            // 渲染这个节点的数学公式
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(() => {
                    window.MathJax.typesetPromise([textElement.node()]).catch(error => {
                        console.warn('MathJax rendering failed for log node:', error);
                    });
                }, 50);
            }
        });

        g.append("text")
            .attr("x", -40)
            .attr("y", -95)
            .attr("class", "world-description")
            .attr("text-anchor", "start")
            .style("font-weight", "bold")
            .text("(乘法、除法、幂运算)");

        g.append("text")
            .attr("x", -40)
            .attr("y", 225)
            .attr("class", "world-description")
            .attr("text-anchor", "start")
            .style("font-weight", "bold")
            .text("(加法、减法、乘法)");

        // 添加垂直连接线（虚线）
        numbers.forEach((num, i) => {
            g.append("line")
                .attr("x1", scaleNumbers(num))
                .attr("y1", 20)
                .attr("x2", scaleLogs(logs[i]))
                .attr("y2", 130)
                .attr("stroke", "#9b59b6")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .style("opacity", 0.3);
        });

        // 渲染数学公式
        setTimeout(async () => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                try {
                    // 先渲染整个SVG
                    await window.MathJax.typesetPromise([svg.node()]);
                    // 再专门渲染SVG中的公式
                    await renderMathJaxInSVG(svg.node());
                } catch (error) {
                    console.warn('MathJax rendering failed:', error);
                }
            }
        }, 200);

        const operations = [
            { type: 'multiply', num1: 16, num2: 32, log1: 4, log2: 5, title: '乘法运算', desc: '16 × 32 = ?' },
            { type: 'divide', num1: 256, num2: 16, log1: 8, log2: 4, title: '除法运算', desc: '256 ÷ 16 = ?' },
            { type: 'power', num1: 8, num2: 3, log1: 3, log2: 3, title: '幂运算', desc: '8³ = ?' }
        ];

        async function animateOperation(op) {
            return new Promise(resolve => {
                svg.selectAll(".animation-element").remove();

                let logResult, numResult, opSymbol, logOpSymbol, logFormula, numFormula;
                switch(op.type) {
                    case 'multiply':
                        logResult = op.log1 + op.log2;
                        numResult = op.num1 * op.num2;
                        opSymbol = '×';
                        logOpSymbol = '+';
                        logFormula = `${op.num1}\\times ${op.num2}=2^{${op.log1}}\\times 2^{${op.log2}}=2^{(${op.log1}+${op.log2})}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1} \\times ${op.num2} = ${numResult}`;
                        break;
                    case 'divide':
                        logResult = op.log1 - op.log2;
                        numResult = op.num1 / op.num2;
                        opSymbol = '÷';
                        logOpSymbol = '−';
                        logFormula = `${op.num1}\\div ${op.num2}=\\frac{2^{${op.log1}}}{2^{${op.log2}}}=2^{(${op.log1}-${op.log2})}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1} \\div ${op.num2} = ${numResult}`;
                        break;
                    case 'power':
                        logResult = op.log1 * op.log2;
                        numResult = Math.pow(op.num1, op.num2);
                        opSymbol = '^';
                        logOpSymbol = '×';
                        logFormula = `${op.num1}^{${op.num2}}=(2^{${op.log1}})^{${op.num2}}=2^{${op.log1}\\times ${op.log2}}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1}^{${op.num2}} = ${numResult}`;
                        break;
                }

                const animGroup = g.append("g").attr("class", "animation-element");

                // 问题框
                const questionBox = animGroup.append("g");
                questionBox.append("rect")
                    .attr("x", innerWidth/2 - 150)
                    .attr("y", -130)
                    .attr("width", 300)
                    .attr("height", 50)
                    .attr("class", "operation-box");

                const mainText = questionBox.append("text")
                    .attr("x", innerWidth/2)
                    .attr("y", -100)
                .attr("text-anchor", "middle")
                    .style("font-size", "24px")
                    .style("font-weight", "bold");

                async function step1() {
                    await waitForResume();
                    mainText.text(op.desc)
                .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1000)));
                }

                async function step2() {
                    await waitForResume();
                    // 创建移动的圆点
                    const mover1 = animGroup.append("circle")
                        .attr("r", 10)
                        .attr("fill", "#e67e22")
                        .attr("cx", scaleNumbers(op.num1))
                        .attr("cy", 0)
                        .attr("class", "highlight-path");

                    let mover2;
                    if (op.type !== 'power') {
                        mover2 = animGroup.append("circle")
                            .attr("r", 10)
                            .attr("fill", "#3498db")
                            .attr("cx", scaleNumbers(op.num2))
                            .attr("cy", 0)
                            .attr("class", "highlight-path");
                    }

                    // 下移动画
                    const pathDown1 = animGroup.append("path")
                        .attr("d", `M${scaleNumbers(op.num1)},0 Q${scaleNumbers(op.num1)},75 ${scaleLogs(op.log1)},150`)
                        .attr("stroke", "#e67e22")
                        .attr("stroke-width", 2)
                .attr("fill", "none")
                        .attr("class", "highlight-path");

                    const len1 = pathDown1.node().getTotalLength();
                    pathDown1.attr("stroke-dasharray", len1 + " " + len1)
                        .attr("stroke-dashoffset", len1)
                        .transition().delay(scaledDelay(500)).duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                    mover1.transition().delay(scaledDelay(500)).duration(scaledDuration(1000))
                        .attr("cx", scaleLogs(op.log1))
                        .attr("cy", 150);

                    if (mover2) {
                        const pathDown2 = animGroup.append("path")
                            .attr("d", `M${scaleNumbers(op.num2)},0 Q${scaleNumbers(op.num2)},75 ${scaleLogs(op.log2)},150`)
                            .attr("stroke", "#3498db")
                            .attr("stroke-width", 2)
                            .attr("fill", "none")
                            .attr("class", "highlight-path");

                        const len2 = pathDown2.node().getTotalLength();
                        pathDown2.attr("stroke-dasharray", len2 + " " + len2)
                            .attr("stroke-dashoffset", len2)
                            .transition().delay(scaledDelay(500)).duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                        mover2.transition().delay(scaledDelay(500)).duration(scaledDuration(1000))
                            .attr("cx", scaleLogs(op.log2))
                            .attr("cy", 150);
                    }

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step3() {
                    await waitForResume();
                    // 显示对数公式
                    const formulaG = animGroup.append("g");
                    formulaG.append("rect")
                        .attr("x", innerWidth/2 - 180)
                        .attr("y", 200)
                        .attr("width", 360)
                    .attr("height", 40)
                        .attr("fill", "#e8f4f8")
                        .attr("stroke", "#2980b9")
                        .attr("stroke-width", 2)
                        .attr("rx", 8);

                    let latexFormula = (logFormula || "")
                        .replace(/×/g, "\\times")
                        .replace(/÷/g, "\\div")
                        .replace(/−/g, "-");

                    const formulaFO = formulaG.append("foreignObject")
                        .attr("x", innerWidth/2 - 180)
                        .attr("y", 200)
                        .attr("width", 360)
                        .attr("height", 40)
                        .style("opacity", 0);

                    formulaFO.html(`<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:16px;font-weight:bold;color:#2980b9;text-align:center;line-height:40px;">$${latexFormula}$</div>`);

                    if (window.MathJax && window.MathJax.typesetPromise) {
                        try {
                            await window.MathJax.typesetPromise([formulaFO.node()]);
                        } catch (error) {
                            console.warn('MathJax rendering failed:', error);
                        }
                    }

                    formulaFO.transition().duration(scaledDuration(1000)).style("opacity", 1);
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step4() {
                    await waitForResume();
                    // 移动到结果位置
                    const mover1 = animGroup.select("circle");
                    mover1.transition().duration(scaledDuration(1000))
                        .attr("cx", scaleLogs(logResult))
                        .attr("fill", "#2ecc71");

                    const mover2 = animGroup.selectAll("circle").filter((d, i) => i === 1);
                    if (!mover2.empty()) {
                        mover2.transition().duration(scaledDuration(1000))
                            .attr("cx", scaleLogs(logResult))
                            .style("opacity", 0);
                    }

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step5() {
                    await waitForResume();
                    // 上移动画
                    const pathUp = animGroup.append("path")
                        .attr("d", `M${scaleLogs(logResult)},150 Q${scaleLogs(logResult)},75 ${scaleNumbers(numResult)},0`)
                        .attr("stroke", "#2ecc71")
                        .attr("stroke-width", 2)
                        .attr("fill", "none")
                        .attr("class", "highlight-path");

                    const lenUp = pathUp.node().getTotalLength();
                    pathUp.attr("stroke-dasharray", lenUp + " " + lenUp)
                        .attr("stroke-dashoffset", lenUp)
                        .transition().duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                    const mover1 = animGroup.select("circle");
                    mover1.transition().duration(scaledDuration(1000))
                        .attr("cy", 0)
                        .attr("cx", scaleNumbers(numResult));

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1000)));
                }

                async function step6() {
                    await waitForResume();
                    // 显示最终结果
                    const resultBox = animGroup.append("g");
                    resultBox.append("rect")
                        .attr("x", innerWidth/2 + 300)
                        .attr("y", -130)
                        .attr("width", 200)
                        .attr("height", 50)
                        .attr("class", "result-box")
                        .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);

                    resultBox.append("text")
                        .attr("x", innerWidth/2 + 400)
                        .attr("y", -100)
        .attr("text-anchor", "middle")
                        .style("font-size", "26px")
        .style("font-weight", "bold")
                        .style("fill", "white")
                        .text(`答案: ${numResult}`)
        .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(2000)));
                    resolve();
                }

                // 依次执行所有步骤
                (async () => {
                    await step1();
                    await step2();
                    await step3();
                    await step4();
                    await step5();
                    await step6();
                })();
            });
        }

        async function cycleAnimations() {
            animationState.cycleActive = true;
            currentAnimation = {
                interrupt: () => {
                    animationState.cycleActive = false;
                    svg.selectAll("*").interrupt();
                }
            };

            while (animationState.cycleActive) {
                for (let i = 0; i < operations.length; i++) {
                    if (!animationState.cycleActive) break;
                    animationState.currentOperationIndex = i;
                    await animateOperation(operations[i]);
                    if (!animationState.cycleActive) break;
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(2000)));
                }
            }
        }

        cycleAnimations();

        // 确保SVG中的公式正确渲染
        const ensureSVGMathRendering = () => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(async () => {
                    try {
                        await renderMathJaxInSVG(svg.node());
                    } catch (error) {
                        console.warn('SVG Math rendering failed:', error);
                    }
                }, 500);
            }
        };

        // 监听SVG内容变化，自动重新渲染公式
        const observer = new MutationObserver(() => {
            ensureSVGMathRendering();
        });

        observer.observe(svg.node(), {
            childList: true,
            subtree: true
        });
    }

// 幻灯片21（显示第22页）：对数运算可视化 - 增强版
function visualizeLogOperations(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    // 清除之前的内容
    g.selectAll("*").remove();

    const innerWidth = width - 100;
    const innerHeight = height - 100;

    // 创建背景区域
    const upperBg = g.append("rect")
        .attr("x", 20)
        .attr("y", 20)
        .attr("width", innerWidth)
        .attr("height", 120)
        .attr("fill", "#ecf8ff")
        .attr("rx", 10)
        .style("opacity", 0.3);

    const lowerBg = g.append("rect")
        .attr("x", 20)
        .attr("y", 200)
        .attr("width", innerWidth)
        .attr("height", 120)
        .attr("fill", "#f0f9e8")
        .attr("rx", 10)
        .style("opacity", 0.3);

    const numbers = [2, 4, 8, 16, 32, 64, 128, 256, 512];
    const logs = [1, 2, 3, 4, 5, 6, 7, 8, 9];

    const scaleNumbers = d3.scalePoint().domain(numbers).range([50, innerWidth - 50]).padding(0.5);
    const scaleLogs = d3.scalePoint().domain(logs).range([50, innerWidth - 50]).padding(0.5);

    // 数字轴
    const numberAxis = g.append("g").attr("class", "number-axis").attr("transform", "translate(0, 80)");
    numberAxis.call(d3.axisBottom(scaleNumbers));
    numberAxis.selectAll("text").style("font-size", "14px").style("font-weight", "bold");

    // 为数字轴添加节点 - 显示2的幂次方
    numbers.forEach((num, i) => {
        const nodeG = numberAxis.append("g")
            .attr("class", "number-node")
            .attr("transform", `translate(${scaleNumbers(num)}, 0)`);
        nodeG.append("circle")
            .attr("r", 18)
            .attr("cy", -30)
            .attr("fill", "#3498db")
            .attr("fill-opacity", 0.2)
            .attr("stroke", "#3498db")
            .attr("stroke-width", 2);

        // 使用外置文本标签来显示公式
        const textElement = nodeG.append("foreignObject")
            .attr("x", -15)
            .attr("y", -38)
            .attr("width", 30)
            .attr("height", 20)
            .html(`<div style="font-size: 12px; text-align: center; color: #2c3e50; font-weight: bold;">$2^{${i+1}}$</div>`);

        // 渲染这个节点的数学公式
        if (window.MathJax && window.MathJax.typesetPromise) {
            setTimeout(() => {
                window.MathJax.typesetPromise([textElement.node()]).catch(error => {
                    console.warn('MathJax rendering failed for number node:', error);
                });
            }, 50);
        }
    });

    // 对数轴
    const logAxis = g.append("g").attr("transform", `translate(0, 260)`).attr("class", "log-axis");
    logAxis.call(d3.axisBottom(scaleLogs));
    logAxis.selectAll("text").style("font-size", "14px").style("font-weight", "bold");

    // 为对数轴添加节点
    logs.forEach(log => {
        const nodeG = logAxis.append("g")
            .attr("class", "number-node")
            .attr("transform", `translate(${scaleLogs(log)}, 0)`);
        nodeG.append("rect")
            .attr("x", -25)
            .attr("y", -42)
            .attr("width", 50)
            .attr("height", 24)
            .attr("fill", "#2ecc71")
            .attr("fill-opacity", 0.2)
            .attr("stroke", "#2ecc71")
            .attr("stroke-width", 2)
            .attr("rx", 5);

        // 使用外置文本标签来显示公式
        const textElement = nodeG.append("foreignObject")
            .attr("x", -25)
            .attr("y", -38)
            .attr("width", 50)
            .attr("height", 20)
            .html(`<div style="font-size: 10px; text-align: center; color: #2c3e50; font-weight: bold;">$\\log_2(${Math.pow(2, log)})$</div>`);

        // 渲染这个节点的数学公式
        if (window.MathJax && window.MathJax.typesetPromise) {
            setTimeout(() => {
                window.MathJax.typesetPromise([textElement.node()]).catch(error => {
                    console.warn('MathJax rendering failed for log node:', error);
                });
            }, 50);
        }
    });

    g.append("text")
        .attr("x", 20)
        .attr("y", 40)
        .attr("class", "world-description")
        .attr("text-anchor", "start")
        .style("font-weight", "bold")
        .style("font-size", "18px")
        .text("(乘法、除法、幂运算)");

    g.append("text")
        .attr("x", 20)
        .attr("y", 220)
        .attr("class", "world-description")
        .attr("text-anchor", "start")
        .style("font-weight", "bold")
        .style("font-size", "18px")
        .text("(加法、减法、乘法)");

    // 添加垂直连接线（虚线）
    numbers.forEach((num, i) => {
        g.append("line")
            .attr("x1", scaleNumbers(num))
            .attr("y1", 100)
            .attr("x2", scaleLogs(logs[i]))
            .attr("y2", 220)
            .attr("stroke", "#9b59b6")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3,3")
            .style("opacity", 0.3);
    });

    // 渲染数学公式
    setTimeout(async () => {
        if (window.MathJax && window.MathJax.typesetPromise) {
            try {
                // 先渲染整个SVG
                await window.MathJax.typesetPromise([svg.node()]);
                // 再专门渲染SVG中的公式
                await renderMathJaxInContainer(containerId);
            } catch (error) {
                console.warn('MathJax rendering failed:', error);
            }
        }
    }, 200);

    const operations = [
        { type: 'multiply', num1: 16, num2: 32, log1: 4, log2: 5, title: '乘法运算', desc: '16 × 32 = ?' },
        { type: 'divide', num1: 256, num2: 16, log1: 8, log2: 4, title: '除法运算', desc: '256 ÷ 16 = ?' },
        { type: 'power', num1: 8, num2: 3, log1: 3, log2: 3, title: '幂运算', desc: '8³ = ?' }
    ];

    async function animateOperation(op) {
        return new Promise(resolve => {
            g.selectAll(".animation-element").remove();

            let logResult, numResult, opSymbol, logOpSymbol, logFormula, numFormula;
            switch(op.type) {
                case 'multiply':
                    logResult = op.log1 + op.log2;
                    numResult = op.num1 * op.num2;
                    opSymbol = '×';
                    logOpSymbol = '+';
                    logFormula = `${op.num1}\\times ${op.num2}=2^{${op.log1}}\\times 2^{${op.log2}}=2^{(${op.log1}+${op.log2})}=2^{${logResult}}=${numResult}`;
                    numFormula = `${op.num1} \\times ${op.num2} = ${numResult}`;
                    break;
                case 'divide':
                    logResult = op.log1 - op.log2;
                    numResult = op.num1 / op.num2;
                    opSymbol = '÷';
                    logOpSymbol = '−';
                    logFormula = `${op.num1}\\div ${op.num2}=\\frac{2^{${op.log1}}}{2^{${op.log2}}}=2^{(${op.log1}-${op.log2})}=2^{${logResult}}=${numResult}`;
                    numFormula = `${op.num1} \\div ${op.num2} = ${numResult}`;
                    break;
                case 'power':
                    logResult = op.log1 * op.log2;
                    numResult = Math.pow(op.num1, op.num2);
                    opSymbol = '^';
                    logOpSymbol = '×';
                    logFormula = `${op.num1}^{${op.num2}}=(2^{${op.log1}})^{${op.num2}}=2^{${op.log1}\\times ${op.log2}}=2^{${logResult}}=${numResult}`;
                    numFormula = `${op.num1}^{${op.num2}} = ${numResult}`;
                    break;
            }

            const animGroup = g.append("g").attr("class", "animation-element");

            // 问题框
            const questionBox = animGroup.append("g");
            questionBox.append("rect")
                .attr("x", innerWidth/2 - 150)
                .attr("y", 20)
                .attr("width", 300)
                .attr("height", 50)
                .attr("fill", "#e8f4f8")
                .attr("stroke", "#2980b9")
                .attr("stroke-width", 2)
                .attr("rx", 8);

            const mainText = questionBox.append("text")
                .attr("x", innerWidth/2)
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .style("font-size", "24px")
                .style("font-weight", "bold")
                .style("fill", "#2980b9");

            async function step1() {
                mainText.text(op.desc)
                    .style("opacity", 0)
                    .transition().duration(1000).style("opacity", 1);
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            async function step2() {
                // 创建移动的圆点
                const mover1 = animGroup.append("circle")
                    .attr("r", 10)
                    .attr("fill", "#e67e22")
                    .attr("cx", scaleNumbers(op.num1))
                    .attr("cy", 80)
                    .attr("class", "highlight-path");

                let mover2;
                if (op.type !== 'power') {
                    mover2 = animGroup.append("circle")
                        .attr("r", 10)
                        .attr("fill", "#3498db")
                        .attr("cx", scaleNumbers(op.num2))
                        .attr("cy", 80)
                        .attr("class", "highlight-path");
                }

                // 下移动画
                const pathDown1 = animGroup.append("path")
                    .attr("d", `M${scaleNumbers(op.num1)},80 Q${scaleNumbers(op.num1)},140 ${scaleLogs(op.log1)},260`)
                    .attr("stroke", "#e67e22")
                    .attr("stroke-width", 2)
                    .attr("fill", "none")
                    .attr("class", "highlight-path");

                const len1 = pathDown1.node().getTotalLength();
                pathDown1.attr("stroke-dasharray", len1 + " " + len1)
                    .attr("stroke-dashoffset", len1)
                    .transition().delay(500).duration(1000).attr("stroke-dashoffset", 0);

                mover1.transition().delay(500).duration(1000)
                    .attr("cx", scaleLogs(op.log1))
                    .attr("cy", 260);

                if (mover2) {
                    const pathDown2 = animGroup.append("path")
                        .attr("d", `M${scaleNumbers(op.num2)},80 Q${scaleNumbers(op.num2)},140 ${scaleLogs(op.log2)},260`)
                        .attr("stroke", "#3498db")
                        .attr("stroke-width", 2)
                        .attr("fill", "none")
                        .attr("class", "highlight-path");

                    const len2 = pathDown2.node().getTotalLength();
                    pathDown2.attr("stroke-dasharray", len2 + " " + len2)
                        .attr("stroke-dashoffset", len2)
                        .transition().delay(500).duration(1000).attr("stroke-dashoffset", 0);

                    mover2.transition().delay(500).duration(1000)
                        .attr("cx", scaleLogs(op.log2))
                        .attr("cy", 260);
                }

                await new Promise(resolve => setTimeout(resolve, 1500));
            }

            async function step3() {
                // 显示对数公式
                const formulaG = animGroup.append("g");
                formulaG.append("rect")
                    .attr("x", innerWidth/2 - 180)
                    .attr("y", 320)
                    .attr("width", 360)
                    .attr("height", 40)
                    .attr("fill", "#e8f4f8")
                    .attr("stroke", "#2980b9")
                    .attr("stroke-width", 2)
                    .attr("rx", 8);

                let latexFormula = (logFormula || "")
                    .replace(/×/g, "\\times")
                    .replace(/÷/g, "\\div")
                    .replace(/−/g, "-");

                const formulaFO = formulaG.append("foreignObject")
                    .attr("x", innerWidth/2 - 180)
                    .attr("y", 320)
                    .attr("width", 360)
                    .attr("height", 40)
                    .style("opacity", 0);

                formulaFO.html(`<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:16px;font-weight:bold;color:#2980b9;text-align:center;line-height:40px;">$${latexFormula}$</div>`);

                if (window.MathJax && window.MathJax.typesetPromise) {
                    try {
                        await window.MathJax.typesetPromise([formulaFO.node()]);
        } catch (error) {
                        console.warn('MathJax rendering failed:', error);
                    }
                }

                formulaFO.transition().duration(1000).style("opacity", 1);
                await new Promise(resolve => setTimeout(resolve, 1500));
            }

            async function step4() {
                // 移动到结果位置
                const mover1 = animGroup.select("circle");
                mover1.transition().duration(1000)
                    .attr("cx", scaleLogs(logResult))
                    .attr("fill", "#2ecc71");

                const mover2 = animGroup.selectAll("circle").filter((d, i) => i === 1);
                if (!mover2.empty()) {
                    mover2.transition().duration(1000)
                        .attr("cx", scaleLogs(logResult))
                        .style("opacity", 0);
                }

                await new Promise(resolve => setTimeout(resolve, 1500));
            }

            async function step5() {
                // 上移动画
                const pathUp = animGroup.append("path")
                    .attr("d", `M${scaleLogs(logResult)},260 Q${scaleLogs(logResult)},140 ${scaleNumbers(numResult)},80`)
                    .attr("stroke", "#2ecc71")
                    .attr("stroke-width", 2)
                    .attr("fill", "none")
                    .attr("class", "highlight-path");

                const lenUp = pathUp.node().getTotalLength();
                pathUp.attr("stroke-dasharray", lenUp + " " + lenUp)
                    .attr("stroke-dashoffset", lenUp)
                    .transition().duration(1000).attr("stroke-dashoffset", 0);

                const mover1 = animGroup.select("circle");
                mover1.transition().duration(1000)
                    .attr("cy", 80)
                    .attr("cx", scaleNumbers(numResult));

                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            async function step6() {
                // 显示最终结果
                const resultBox = animGroup.append("g");
                resultBox.append("rect")
                    .attr("x", innerWidth/2 + 300)
                    .attr("y", 20)
                    .attr("width", 200)
                    .attr("height", 50)
                    .attr("fill", "#2ecc71")
                    .attr("stroke", "#27ae60")
                    .attr("stroke-width", 2)
                    .attr("rx", 8)
                    .style("opacity", 0)
                    .transition().duration(1000).style("opacity", 1);

                resultBox.append("text")
                    .attr("x", innerWidth/2 + 400)
                    .attr("y", 50)
                    .attr("text-anchor", "middle")
                    .style("font-size", "26px")
                    .style("font-weight", "bold")
                    .style("fill", "white")
                    .text(`答案: ${numResult}`)
                    .style("opacity", 0)
                    .transition().duration(1000).style("opacity", 1);

                await new Promise(resolve => setTimeout(resolve, 2000));
                resolve();
            }

            // 依次执行所有步骤
            (async () => {
                await step1();
                await step2();
                await step3();
                await step4();
                await step5();
                await step6();
            })();
        });
    }

    // 循环播放动画
    let currentOpIndex = 0;
    function cycleAnimations() {
        if (currentOpIndex < operations.length) {
            animateOperation(operations[currentOpIndex]).then(() => {
                currentOpIndex = (currentOpIndex + 1) % operations.length;
                setTimeout(cycleAnimations, 2000);
            });
        }
    }

    // 开始动画
    setTimeout(cycleAnimations, 1000);
    
    // 添加解释说明（纯文本描述）
    const explanationFO = g.append("foreignObject")
        .attr("x", 50)
        .attr("y", height - 120)
        .attr("width", width - 100)
        .attr("height", 500)
        .html(`<div style="color: #2c3e50; font-size: 18px; line-height: 1.8; text-align: center; padding: 20px;">
            <div style="font-size: 20px; color: #34495e;">
                如果我们有一把尺子，上面全部是关于2的幂次方（2¹, 2², 2³, 2⁴...），那么对数就是这把尺子的"刻度读数"。
                当我们要计算16×32时，我们不需要直接相乘，而是先找到16和32在尺子上的位置（分别是4和5），
                然后简单相加得到9，最后再回到尺子上找到2⁹=512。这就是对数将复杂乘法转化为简单加法的神奇过程！
            </div>
        </div>`)
        .style("opacity", 0);

    // 延迟显示解释，确保动画先开始
    explanationFO.transition()
        .delay(3000)
        .duration(1000)
        .style("opacity", 1);
    
    // 渲染MathJax
    setTimeout(() => {
        renderMathJaxInContainer(containerId);
    }, 100);
}

// 幻灯片24：函数性质介绍可视化
function visualizePropertiesIntro(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const properties = [
        { name: "单调性", x: width * 0.25, y: height * 0.25, color: "#e74c3c" },
        { name: "奇偶性", x: width * 0.75, y: height * 0.25, color: "#3498db" },
        { name: "周期性", x: width * 0.25, y: height * 0.75, color: "#2ecc71" },
        { name: "有界性", x: width * 0.75, y: height * 0.75, color: "#f39c12" }
    ];

    properties.forEach((prop, i) => {
        const group = g.append("g")
            .attr("transform", `translate(${prop.x}, ${prop.y})`)
            .style("opacity", 0);

        group.append("circle")
            .attr("r", 60)
            .attr("fill", prop.color)
            .attr("fill-opacity", 0.3)
            .attr("stroke", prop.color)
            .attr("stroke-width", 3);

        group.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.3em")
            .style("font-size", "20px")
            .style("font-weight", "bold")
            .text(prop.name);

        group.transition()
            .delay(i * 300)
            .duration(800)
            .style("opacity", 1);
    });
}

// 幻灯片25：单调递增可视化
function visualizeMonotonicityInc(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画递增函数 y = x
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(d))
        .curve(d3.curveMonotoneX);

    const data = d3.range(-4, 4.1, 0.1);
    
    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#2ecc71")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    animatePath(path);

    // 添加上升箭头
    g.append("text")
        .attr("x", xScale(3))
        .attr("y", yScale(3) - 20)
        .text("↗")
        .style("font-size", "30px")
        .style("fill", "#2ecc71");
}

// 幻灯片26：单调递减可视化
function visualizeMonotonicityDec(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画递减函数 y = -x
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(-d))
        .curve(d3.curveMonotoneX);

    const data = d3.range(-4, 4.1, 0.1);
    
    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    animatePath(path);

    // 添加下降箭头
    g.append("text")
        .attr("x", xScale(3))
        .attr("y", yScale(-3) + 40)
        .text("↘")
        .style("font-size", "30px")
        .style("fill", "#e74c3c");
}

// 幻灯片27：单调区间可视化
// 幻灯片27（显示第28页）：单调区间可视化 - 增强版
function visualizeMonotonicityIntervals(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-4, 4]).range([40, width - 40]);
    const yScale = d3.scaleLinear().domain([-2, 10]).range([height - 40, 40]);

    // 坐标轴
    drawAxes(g, xScale, yScale, width, height);

    // 画 y = (x-1)²
    const data = d3.range(-3, 5, 0.05);
    const parabola = d3.line()
        .x(d => xScale(d))
        .y(d => yScale((d - 1) * (d - 1)))
        .curve(d3.curveBasis);

    // 分段着色
    const leftData = data.filter(d => d <= 1);
    const rightData = data.filter(d => d >= 1);

    // 递减部分（红色）
    const leftPath = g.append("path")
        .datum(leftData)
        .attr("d", parabola)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 4)
        .attr("fill", "none")
        .style("filter", "drop-shadow(0 2px 4px rgba(231, 76, 60, 0.3))");

    // 递增部分（绿色）
    const rightPath = g.append("path")
        .datum(rightData)
        .attr("d", parabola)
        .attr("stroke", "#2ecc71")
        .attr("stroke-width", 4)
        .attr("fill", "none")
        .style("filter", "drop-shadow(0 2px 4px rgba(46, 204, 113, 0.3))");

    // 动画绘制曲线
    [leftPath, rightPath].forEach((path, i) => {
        const totalLength = path.node().getTotalLength();
        path.attr("stroke-dasharray", totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition()
            .delay(i * 800)
            .duration(1500)
            .ease(d3.easeLinear)
            .attr("stroke-dashoffset", 0);
    });

    // 转折点（带脉冲效果）
    const criticalPoint = g.append("circle")
        .attr("cx", xScale(1))
        .attr("cy", yScale(0))
        .attr("r", 0)
        .attr("fill", "#f39c12")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3)
        .style("filter", "drop-shadow(0 0 10px #f39c12)");

    criticalPoint.transition()
        .delay(2500)
        .duration(800)
        .attr("r", 12);

    // 脉冲环效果
    const pulseRing = g.append("circle")
        .attr("cx", xScale(1))
        .attr("cy", yScale(0))
        .attr("r", 0)
        .attr("fill", "none")
        .attr("stroke", "#f39c12")
        .attr("stroke-width", 2)
        .attr("opacity", 0.6);

    pulseRing.transition()
        .delay(3300)
        .duration(1500)
        .attr("r", 25)
        .attr("opacity", 0)
        .transition()
        .duration(0)
        .attr("r", 0)
        .attr("opacity", 0.6)
        .on("end", function repeat() {
            d3.select(this)
                .transition()
                .duration(2000)
                .attr("r", 25)
                .attr("opacity", 0)
                .transition()
                .duration(0)
                .attr("r", 0)
                .attr("opacity", 0.6)
                .on("end", repeat);
        });

    // 动态标注
    const decreaseLabel = g.append("g")
        .attr("transform", `translate(${xScale(-1)}, ${yScale(6)})`);

    decreaseLabel.append("rect")
        .attr("x", -30)
        .attr("y", -15)
        .attr("width", 60)
        .attr("height", 30)
        .attr("rx", 15)
        .attr("fill", "#e74c3c")
        .attr("fill-opacity", 0.9)
        .style("opacity", 0);

    decreaseLabel.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.3em")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .style("fill", "white")
        .text("递减↘")
        .style("opacity", 0);

    const increaseLabel = g.append("g")
        .attr("transform", `translate(${xScale(2.5)}, ${yScale(6)})`);

    increaseLabel.append("rect")
        .attr("x", -30)
        .attr("y", -15)
        .attr("width", 60)
        .attr("height", 30)
        .attr("rx", 15)
        .attr("fill", "#2ecc71")
        .attr("fill-opacity", 0.9)
        .style("opacity", 0);

    increaseLabel.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.3em")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .style("fill", "white")
        .text("递增↗")
        .style("opacity", 0);

    // 动画显示标注
    [decreaseLabel, increaseLabel].forEach((label, i) => {
        label.selectAll("*")
            .transition()
            .delay(1000 + i * 400)
            .duration(600)
            .style("opacity", 1);
    });

    // 转折点标注
    const criticalLabel = g.append("g")
        .attr("transform", `translate(${xScale(1)}, ${yScale(0) + 40})`);

    criticalLabel.append("rect")
        .attr("x", -50)
        .attr("y", -12)
        .attr("width", 100)
        .attr("height", 24)
        .attr("rx", 12)
        .attr("fill", "#f39c12")
        .attr("fill-opacity", 0.9)
        .style("opacity", 0);

    criticalLabel.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.3em")
        .style("font-size", "14px")
        .style("font-weight", "bold")
        .style("fill", "white")
        .text("转折点 (1, 0)")
        .style("opacity", 0);

    criticalLabel.selectAll("*")
        .transition()
        .delay(3500)
        .duration(600)
        .style("opacity", 1);

    // 函数表达式
    const title = g.append("text")
        .attr("x", width/2)
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .style("font-size", "24px")
        .style("font-weight", "bold")
        .style("fill", "#2c3e50")
        .text("y = (x - 1)²")
        .style("opacity", 0)
        .transition()
        .delay(4000)
        .duration(800)
        .style("opacity", 1);

    // 添加交互式点
    function addInteractivePoint(x) {
        const point = g.append("circle")
            .attr("cx", xScale(x))
            .attr("cy", yScale((x - 1) * (x - 1)))
            .attr("r", 6)
            .attr("fill", "#3498db")
            .attr("stroke", "#fff")
            .attr("stroke-width", 2)
            .style("cursor", "pointer")
            .style("opacity", 0);

        point.transition()
            .delay(4500)
            .duration(500)
            .style("opacity", 1);

        // 悬停效果
        point.on("mouseover", function() {
            d3.select(this)
                .transition()
                .duration(200)
                .attr("r", 10)
                .attr("fill", "#e74c3c");

            // 显示坐标
            const tooltip = g.append("text")
                .attr("x", xScale(x) + 10)
                .attr("y", yScale((x - 1) * (x - 1)) - 10)
                .style("font-size", "12px")
                .style("fill", "#2c3e50")
                .style("font-weight", "bold")
                .text(`(${x}, ${((x - 1) * (x - 1)).toFixed(2)})`)
                .style("opacity", 0);

            tooltip.transition()
                .duration(200)
                .style("opacity", 1);
        }).on("mouseout", function() {
            d3.select(this)
                .transition()
                .duration(200)
                .attr("r", 6)
                .attr("fill", "#3498db");

            g.selectAll("text").filter(function() {
                return d3.select(this).text().includes("(" + x + ",");
            }).remove();
        });
    }

    // 添加几个关键点
    setTimeout(() => {
        addInteractivePoint(-2);
        addInteractivePoint(0);
        addInteractivePoint(1);
        addInteractivePoint(3);
    }, 4500);

    // 添加切线动画
    function showTangentAt(x) {
        const slope = 2 * (x - 1); // 导数为 2(x-1)
        const y = (x - 1) * (x - 1);
        
        // 切线
        const tangentLine = g.append("line")
            .attr("x1", xScale(x - 1))
            .attr("y1", yScale(y - slope))
            .attr("x2", xScale(x + 1))
            .attr("y2", yScale(y + slope))
            .attr("stroke", "#9b59b6")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5, 5")
            .style("opacity", 0);

        tangentLine.transition()
            .delay(6000)
            .duration(800)
            .style("opacity", 1);

        // 切线标签
        g.append("text")
            .attr("x", xScale(x + 0.5))
            .attr("y", yScale(y + slope) - 10)
            .style("font-size", "12px")
            .style("fill", "#9b59b6")
            .style("font-weight", "bold")
            .text(`斜率 = ${slope.toFixed(1)}`)
            .style("opacity", 0)
            .transition()
            .delay(6500)
            .duration(600)
            .style("opacity", 1);
    }

    // 在转折点显示切线
    setTimeout(() => {
        showTangentAt(1);
    }, 6000);
}

// 幻灯片28：奇偶性介绍可视化
function visualizeParityIntro(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    // 偶函数示例
    const evenGroup = g.append("g")
        .attr("transform", `translate(${width * 0.25}, ${height * 0.5})`);
    
    evenGroup.append("rect")
        .attr("x", -80)
        .attr("y", -80)
        .attr("width", 160)
        .attr("height", 160)
        .attr("fill", "#3498db")
        .attr("fill-opacity", 0.2)
        .attr("stroke", "#3498db")
        .attr("stroke-width", 2);
    
    evenGroup.append("text")
        .attr("text-anchor", "middle")
        .text("偶函数")
        .style("font-size", "20px");
    
    evenGroup.append("text")
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .text("Y轴对称")
        .style("font-size", "16px")
        .style("fill", "#666");

    // 奇函数示例
    const oddGroup = g.append("g")
        .attr("transform", `translate(${width * 0.75}, ${height * 0.5})`);
    
    oddGroup.append("circle")
        .attr("r", 80)
        .attr("fill", "#e74c3c")
        .attr("fill-opacity", 0.2)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2);
    
    oddGroup.append("text")
        .attr("text-anchor", "middle")
        .text("奇函数")
        .style("font-size", "20px");
    
    oddGroup.append("text")
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .text("原点对称")
        .style("font-size", "16px")
        .style("fill", "#666");
}

// 幻灯片29：偶函数可视化
function visualizeEvenFunction(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-2, 10]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画 y = x^2 (偶函数)
    const data = d3.range(-4, 4.1, 0.1);
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(d * d))
        .curve(d3.curveBasis);

    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#3498db")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    animatePath(path);

    // 标记对称点
    [-2, 2].forEach(x => {
        g.append("circle")
            .attr("cx", xScale(x))
            .attr("cy", yScale(x * x))
            .attr("r", 5)
            .attr("fill", "#e74c3c");
    });

    // Y轴对称线
    g.append("line")
        .attr("x1", xScale(0))
        .attr("y1", 0)
        .attr("x2", xScale(0))
        .attr("y2", height)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5, 5");
}

// 幻灯片30：奇函数可视化
function visualizeOddFunction(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画 y = x^3 (奇函数)
    const data = d3.range(-2, 2.1, 0.1);
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(d * d * d))
        .curve(d3.curveBasis);

    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    animatePath(path);

    // 标记对称点
    [-1.5, 1.5].forEach(x => {
        g.append("circle")
            .attr("cx", xScale(x))
            .attr("cy", yScale(x * x * x))
            .attr("r", 5)
            .attr("fill", "#3498db");
    });

    // 原点
    g.append("circle")
        .attr("cx", xScale(0))
        .attr("cy", yScale(0))
        .attr("r", 6)
        .attr("fill", "#f39c12")
        .attr("stroke", "#333")
        .attr("stroke-width", 2);
}

// 幻灯片31：有界性可视化
function visualizeBoundedness(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-10, 10]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-2, 2]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画 sin(x)
    const data = d3.range(-10, 10.1, 0.1);
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(Math.sin(d)))
        .curve(d3.curveBasis);

    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#3498db")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    // 上界线
    g.append("line")
        .attr("x1", 0)
        .attr("y1", yScale(1))
        .attr("x2", width)
        .attr("y2", yScale(1))
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "10, 5");

    // 下界线
    g.append("line")
        .attr("x1", 0)
        .attr("y1", yScale(-1))
        .attr("x2", width)
        .attr("y2", yScale(-1))
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "10, 5");

    // 标注
    g.append("text")
        .attr("x", width - 50)
        .attr("y", yScale(1) - 10)
        .text("上界: 1")
        .style("fill", "#e74c3c");

    g.append("text")
        .attr("x", width - 50)
        .attr("y", yScale(-1) + 20)
        .text("下界: -1")
        .style("fill", "#e74c3c");
}

// 幻灯片32：反函数机器可视化
// 幻灯片32（显示第33页）：反函数机器可视化 - 增强版
// 幻灯片32（显示第33页）：反函数机器可视化 - 修复版
function visualizeInverseMachine(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    // 清除之前的内容
    g.selectAll("*").remove();

    // 标题
    const titleFO = g.append("foreignObject")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", 60)
        .html(`<div style="text-align: center; font-size: 30px; font-weight: bold; color: #2c3e50; padding-top: 20px;">
            反函数：互逆的操作
        </div>`);

    const centerY = height / 2;

    // 机器1：正向函数
    const machine1 = g.append("g")
        .attr("transform", `translate(${width * 0.25}, ${centerY})`);

    const box1 = machine1.append("rect")
        .attr("x", -80)
        .attr("y", -60)
        .attr("width", 160)
        .attr("height", 120)
        .attr("rx", 15)
        .attr("fill", "#3498db")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3)
        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.2))")
        .style("opacity", 0);

    box1.transition()
        .duration(800)
        .style("opacity", 1);

    const machine1FO = machine1.append("foreignObject")
        .attr("x", -70)
        .attr("y", -40)
        .attr("width", 140)
        .attr("height", 80)
        .html(`<div style="text-align: center; color: white;">
            <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">$f(x)$</div>
            <div style="font-size: 18px;">$y = 2x + 3$</div>
        </div>`)
        .style("opacity", 0);

    machine1FO.transition()
        .delay(200)
        .duration(600)
        .style("opacity", 1);

    // 机器2：反函数
    const machine2 = g.append("g")
        .attr("transform", `translate(${width * 0.75}, ${centerY})`);

    const box2 = machine2.append("rect")
        .attr("x", -80)
        .attr("y", -60)
        .attr("width", 160)
        .attr("height", 120)
        .attr("rx", 15)
        .attr("fill", "#e74c3c")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3)
        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.2))")
        .style("opacity", 0);

    box2.transition()
        .delay(400)
        .duration(800)
        .style("opacity", 1);

    const machine2FO = machine2.append("foreignObject")
        .attr("x", -70)
        .attr("y", -40)
        .attr("width", 140)
        .attr("height", 180)
        .html(`<div style="text-align: center; color: white;">
            <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">$f^{-1}(x)$</div>
            <div style="font-size: 18px;">$x = \\frac{y-3}{2}$</div>
        </div>`)
        .style("opacity", 0);

    machine2FO.transition()
        .delay(600)
        .duration(600)
        .style("opacity", 1);

    // 动画演示
    function animateInverse() {
        const inputValue = 2;
        const outputValue = 2 * inputValue + 3; // f(2) = 7
        
        // 创建数字小球
        const ball = g.append("g")
            .attr("class", "demo-ball");

        const circle = ball.append("circle")
            .attr("cx", width * 0.1)
            .attr("cy", centerY)
            .attr("r", 25)
            .attr("fill", "#2c3e50")
            .style("opacity", 0);

        const ballText = ball.append("text")
            .attr("x", width * 0.1)
            .attr("y", centerY)
            .attr("text-anchor", "middle")
            .attr("dy", "0.3em")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .style("fill", "white")
            .text(inputValue)
            .style("opacity", 0);

        // 显示输入
        circle.transition().duration(400).style("opacity", 1);
        ballText.transition().duration(400).style("opacity", 1);

        // 后续动画逻辑...
    }

    // 底部说明
    const explanationFO = g.append("foreignObject")
        .attr("x", 50)
        .attr("y", height - 60)
        .attr("width", width - 100)
        .attr("height", 50)
        .html(`<div style="text-align: center; font-size: 18px; color: #7f8c8d;">
            <strong>关键性质：</strong> $f(f^{-1}(x)) = x$ 且 $f^{-1}(f(x)) = x$
        </div>`)
                        .style("opacity", 0);

    explanationFO.transition()
        .delay(3000)
        .duration(1000)
        .style("opacity", 1);

    // 渲染MathJax
    setTimeout(() => {
        renderMathJaxInContainer(containerId);
    }, 100);
}

// 幻灯片33：反函数图像可视化
function visualizeInverseGraph(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // y = x 对称线
    g.append("line")
        .attr("x1", xScale(-5))
        .attr("y1", yScale(-5))
        .attr("x2", xScale(5))
        .attr("y2", yScale(5))
        .attr("stroke", "#95a5a6")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5, 5");

    // 原函数 y = 2x
    const data = d3.range(-2.5, 2.6, 0.1);
    const lineF = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(2 * d));

    g.append("path")
        .datum(data)
        .attr("d", lineF)
        .attr("stroke", "#3498db")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    // 反函数 y = x/2
    const lineInv = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(d / 2));

    g.append("path")
        .datum(data)
        .attr("d", lineInv)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    // 标注
    g.append("text")
        .attr("x", xScale(2))
        .attr("y", yScale(4) - 10)
        .text("f(x) = 2x")
        .style("fill", "#3498db");

    g.append("text")
        .attr("x", xScale(4))
        .attr("y", yScale(2) + 20)
        .text("f⁻¹(x) = x/2")
        .style("fill", "#e74c3c");
}

// 幻灯片35：复合函数机器可视化
// 幻灯片35（显示第36页）：复合函数机器可视化 - 增强版
function visualizeCompositeMachine(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    const centerY = height / 2;

    // 三个处理阶段
    const stages = [
        { x: width * 0.15, label: "输入", formula: "x", color: "#95a5a6", isIO: true },
        { x: width * 0.35, label: "内层函数", formula: "g(x) = x + 1", color: "#3498db", isIO: false },
        { x: width * 0.55, label: "外层函数", formula: "f(u) = u²", color: "#e74c3c", isIO: false },
        { x: width * 0.75, label: "输出", formula: "y", color: "#2ecc71", isIO: true }
    ];

    stages.forEach((stage, i) => {
        const stageGroup = g.append("g")
            .attr("transform", `translate(${stage.x}, ${centerY})`);

        if (stage.isIO) {
            // 输入输出用圆形
            stageGroup.append("circle")
                .attr("r", 50)
                .attr("fill", stage.color)
                .attr("fill-opacity", 0.2)
                .attr("stroke", stage.color)
                .attr("stroke-width", 3)
                .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.1))");

            stageGroup.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.3em")
                .style("font-size", "24px")
                .style("font-weight", "bold")
                .style("fill", stage.color)
                .text(stage.formula);
        } else {
            // 函数用矩形
            stageGroup.append("rect")
                .attr("x", -70)
                .attr("y", -50)
                .attr("width", 140)
                .attr("height", 200)
                .attr("rx", 15)
                .attr("fill", stage.color)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.2))");

            stageGroup.append("text")
                .attr("text-anchor", "middle")
                .attr("y", -15)
                .style("font-size", "18px")
                .style("font-weight", "bold")
                .style("fill", "white")
                .text(stage.label);

            stageGroup.append("text")
                .attr("text-anchor", "middle")
                .attr("y", 15)
                .style("font-size", "16px")
                .style("fill", "white")
                .text(stage.formula);
        }
    });

    // 连接线
    for (let i = 0; i < stages.length - 1; i++) {
        const x1 = stages[i].x + (stages[i].isIO ? 50 : 70);
        const x2 = stages[i + 1].x - (stages[i + 1].isIO ? 50 : 70);
        
        const line = g.append("line")
            .attr("x1", x1)
            .attr("y1", centerY)
            .attr("x2", x2)
            .attr("y2", centerY)
            .attr("stroke", "#7f8c8d")
            .attr("stroke-width", 3)
            .attr("stroke-dasharray", "5, 5")
            .style("opacity", 0.8);

        // 流动动画
        line.transition()
            .delay(i * 500)
            .duration(2000)
            .attr("stroke-dashoffset", -20)
            .transition()
            .duration(2000)
            .attr("stroke-dashoffset", 0)
            .on("end", function repeat() {
                d3.select(this)
                    .transition()
                    .duration(2000)
                    .attr("stroke-dashoffset", -20)
                    .transition()
                    .duration(2000)
                    .attr("stroke-dashoffset", 0)
                    .on("end", repeat);
            });
    }

    // 动画演示
    function animateComposition() {
        const value = Math.floor(Math.random() * 4) + 1;
        
        // 显示初始值
        const valueText = g.append("text")
            .attr("x", stages[0].x)
            .attr("y", centerY - 80)
            .attr("text-anchor", "middle")
            .style("font-size", "32px")
            .style("font-weight", "bold")
            .style("fill", "#2c3e50")
            .text(value)
            .style("opacity", 0);

        valueText.transition()
            .duration(500)
            .style("opacity", 1);

        // 经过g(x)
        setTimeout(() => {
            const intermediate = value + 1;
            valueText.transition()
                .duration(800)
                .attr("x", stages[1].x)
                .text(`${value} → ${intermediate}`)
                .style("fill", "#3498db");
        }, 1000);

        // 经过f(u)
        setTimeout(() => {
            const intermediate = value + 1;
            const final = intermediate * intermediate;
            valueText.transition()
                .duration(800)
                .attr("x", stages[2].x)
                .text(`${intermediate} → ${final}`)
                .style("fill", "#e74c3c");
        }, 2200);

        // 最终结果
        setTimeout(() => {
            const final = (value + 1) * (value + 1);
            valueText.transition()
                .duration(800)
                .attr("x", stages[3].x)
                .text(final)
                .style("fill", "#2ecc71");

            // 显示完整公式
            const formula = g.append("g")
                .attr("transform", `translate(${width/2}, ${centerY + 120})`);

            formula.append("rect")
                .attr("x", -200)
                .attr("y", -20)
                .attr("width", 400)
                .attr("height", 40)
                .attr("rx", 10)
                .attr("fill", "#f8f9fa")
                .attr("stroke", "#6c757d")
                .attr("stroke-width", 2)
                .style("opacity", 0);

            formula.append("text")
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#495057")
                .text(`f(g(${value})) = (${value} + 1)² = ${final}`)
                .style("opacity", 0);

            formula.selectAll("*")
                .transition()
                .duration(800)
                .style("opacity", 1)
                .transition()
                .delay(2000)
                .duration(500)
                .style("opacity", 0)
                .remove();
        }, 3400);

        // 清除
        setTimeout(() => {
            valueText.transition()
                .duration(500)
                .style("opacity", 0)
                .remove();
        }, 6000);
    }

    // 开始动画循环
    setTimeout(() => animateComposition(), 1000);
    setInterval(animateComposition, 7000);

    // 标题
    g.append("text")
        .attr("x", width/2)
        .attr("y", 40)
        .attr("text-anchor", "middle")
        .style("font-size", "28px")
        .style("font-weight", "bold")
        .style("fill", "#2c3e50")
        .text("复合函数：层层处理")
        .style("opacity", 0)
        .transition()
        .duration(1000)
        .style("opacity", 1);

    // 说明文字
    g.append("text")
        .attr("x", width/2)
        .attr("y", height - 40)
        .attr("text-anchor", "middle")
        .style("font-size", "18px")
        .style("fill", "#7f8c8d")
        .style("font-weight", "bold")
        .text("复合函数：先执行内层函数，再用结果执行外层函数")
        .style("opacity", 0)
        .transition()
        .delay(2000)
        .duration(1000)
        .style("opacity", 1);
}







        // 运行可视化函数映射
        function runVisualization(slideIndex) {
            // 清理之前的动画
            if (currentAnimation && typeof currentAnimation.interrupt === 'function') {
                currentAnimation.interrupt();
                currentAnimation = null;
            }


            switch (slideIndex) {
                case 3: visualizeVariables('vis-variables'); break;
                case 4: visualizeIntervals('vis-intervals'); break;
                case 5: visualizeFunctionMachine('vis-function-machine'); break;
                case 6: visualizeDomain('vis-domain'); break;
                case 7: visualizeRange('vis-range'); break;
                case 8: visualizeElementaryIntro('vis-elementary-intro'); break;
                case 10: visualizeExponents('vis-exponents'); break;
                case 11: visualizeExponentRules1('vis-exponent-rules-1'); break;
                case 12: visualizeExponentRules2('vis-exponent-rules-2'); break;
                case 13: visualizeSpecialExponentsNew('vis-special-exponents'); break;
                case 14: visualizeFractionalExponents('vis-fractional-exponents'); break;
                case 16: visualizeLogHistory('vis-log-history'); break;
                case 17: visualizeLogDefinition('vis-log-definition'); break;
                case 19: visualizeLogProperties('vis-log-properties'); break;
                case 20: visualizeCommonLogs('vis-common-logs'); break;
             // 在runVisualization函数的switch语句中添加：
case 21: visualizeLogOperations('vis-log-operations'); break;
case 24: visualizePropertiesIntro('vis-properties-intro'); break;
case 25: visualizeMonotonicityInc('vis-monotonicity-inc'); break;
case 26: visualizeMonotonicityDec('vis-monotonicity-dec'); break;
case 27: visualizeMonotonicityIntervals('vis-monotonicity-intervals'); break;
case 28: visualizeParityIntro('vis-parity-intro'); break;
case 29: visualizeEvenFunction('vis-even-function'); break;
case 30: visualizeOddFunction('vis-odd-function'); break;
case 31: visualizeBoundedness('vis-boundedness'); break;
case 32: visualizeInverseMachine('vis-inverse-machine'); break;
case 33: visualizeInverseGraph('vis-inverse-graph'); break;
case 35: visualizeCompositeMachine('vis-composite-machine'); break;
            }
        }
    </script>
</body>
</html>