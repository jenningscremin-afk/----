<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一章：函数基础 (交互式课件)</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <!-- 使用统一的MathJax配置文件，避免配置冲突 -->
    <script src="../common-assets/js/mathjax-config.js"></script>
    <script type="text/javascript" id="MathJax-script" async
            src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js">
    </script>

    <style>
        @import url('../common-assets/css/fonts.css');

        :root {
            --chalkboard-bg: transparent;
            --chalk-text: #ecf0f1;
            --visualization-bg: #fdfdfd00;
            --primary-color: #3498db;
            --accent-color: #e67e22;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #9b59b6;
            --text-color: #34495e;
            --heading-font: 'Noto Serif SC', serif;
            --handwriting-font: 'Noto Serif SC', serif;
        }

        body {
            font-family: var(--heading-font);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: auto;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
        }
        
        #presentation-container {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            aspect-ratio: 16 / 9;
            position: relative;
            background: rgba(255, 255, 255, 0);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: auto;
        }

        .slide {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            display: flex;
            transition: opacity 0.6s ease-in-out;
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            z-index: 10;
        }

        /* iframe容器样式 */
        .iframe-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .iframe-nav-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
            background: transparent;
        }

        /* 全局控制面板样式 */
        .global-control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            padding: 15px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .control-title {
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            font-family: 'Orbitron', monospace;
        }

        .control-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }


        /* 添加导航提示 */
        .iframe-nav-hint {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1002;
            pointer-events: none;
        }

        .chalkboard {
            flex: 0 0 35%;
            background-color: #2c3e50 !important;
            background-image: url('../common-assets/images/black-felt.png');
            border: 10px solid #8B4513;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.7);
            color: var(--chalk-text, #f0f0f0);
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .chalkboard h2 {
            font-family: var(--handwriting-font);
            font-size: 2.2rem;
            color: #f1c40f;
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
            padding-bottom: 2px;
            margin-bottom: 3px;
        }

        .chalkboard h3 {
            font-family: var(--handwriting-font);
            font-size: 1.5rem;
            color: var(--primary-color);
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .chalkboard p, .chalkboard li {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 15px;
        }
        
        .chalkboard ol {
            padding-left: 25px;
        }

        .chalkboard ul {
            list-style-type: '→ ';
            padding-left: 20px;
        }

        .math-formula {
            font-size: 1.3rem;
            color: #1abc9c;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin: 15px 0;
            line-height: 1.5;
        }

        .highlight {
            color: var(--warning-color);
            font-weight: bold;
        }

        .visualization {
            flex: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            position: relative;
            box-sizing: border-box;
        }

        .visualization.full-width {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }
        
        .visualization.fullscreen {
            background: white;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1000;
            padding: 0;
            margin: 0;
        }
        
        .visualization.white-bg {
            background: white;
        }


        /* 页码指示器 */
        .page-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* 返回面板样式 */
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }

        /* 首页导航按钮样式 - 简化版 */
        .home-nav-buttons {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .home-nav-btn {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
            font-size: 0.85rem;
            font-weight: 500;
        }

        .home-nav-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            color: white;
            transform: translateY(-1px);
        }

        .home-nav-btn .btn-icon {
            font-size: 0.8rem;
            margin-right: 6px;
            font-weight: bold;
        }

        .home-nav-btn .btn-text {
            font-size: 0.8rem;
        }

        /* 翻页按钮样式 - 透明版 */
        .nav-buttons {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
        }

        .nav-btn {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
        }

        .nav-btn:disabled {
            background: rgba(0, 0, 0, 0.2);
            color: rgba(255, 255, 255, 0.3);
            cursor: not-allowed;
            transform: none;
        }

        /* 页面指示器样式 */
        .page-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* 全局动画控制面板样式 */
        .global-animation-controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }



        /* 统一控制面板样式 */
        .unified-control-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            font-family: var(--heading-font);
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        /* 浮动菜单样式 - 简化版 */
        #floating-menu {
            position: relative;
        }

        /* 章节目录菜单样式 */
        #chapter-menu {
            position: relative;
        }

        .menu-toggle {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.6);
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: normal;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
            min-width: 32px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-toggle:hover {
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .menu-toggle:active {
            transform: scale(0.95);
        }

        .menu-toggle .menu-icon {
            font-size: 12px;
            font-weight: normal;
            transition: transform 0.3s ease;
        }

        .menu-toggle.active .menu-icon {
            transform: rotate(45deg);
        }

        .menu-content {
            position: absolute;
            bottom: 40px;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 0;
            backdrop-filter: blur(10px);
            opacity: 0;
            visibility: hidden;
            transform: translateY(20px);
            transition: all 0.3s ease;
            min-width: 160px;
            max-height: 300px;
            overflow-y: auto;
        }

        .menu-content.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        /* 自定义滚动条样式 */
        .menu-content::-webkit-scrollbar {
            width: 6px;
        }

        .menu-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }

        .menu-content::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 3px;
        }

        .menu-content::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
            border-radius: 4px;
            margin: 0 4px;
        }

        .menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateX(2px);
        }

        .menu-item .menu-icon {
            font-size: 12px;
            margin-right: 8px;
            width: 16px;
            text-align: center;
        }

        .menu-item .menu-text {
            font-size: 13px;
            font-weight: 500;
        }

        /* 二级菜单样式 */
        .menu-section {
            margin-bottom: 8px;
        }

        .menu-section:last-child {
            margin-bottom: 0;
        }

        .menu-section-title {
            color: rgba(255, 255, 255, 0.6);
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 4px 12px;
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .info-box-style {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            color: #333;
            font-size: 14px;
            line-height: 1.6;
            margin-top: 20px;
            border: 1px solid #eee;
        }
        .info-box-style .color-sine { color: var(--danger-color); }
        .info-box-style .color-cosine { color: var(--primary-color); }
        .info-box-style .color-tangent { color: var(--success-color); }

        .toc-local {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        .toc-local h4 {
            font-size: 1rem;
            color: var(--warning-color);
            margin-bottom: 10px;
        }
        .toc-local a {
            display: block;
            color: var(--chalk-text);
            text-decoration: none;
            padding: 5px 0;
            font-size: 0.9rem;
            transition: color 0.2s;
        }
        .toc-local a:hover {
            color: var(--primary-color);
        }

        #back-to-top-btn {
            position: fixed;
            bottom: 80px;
            right: 30px;
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }
        #back-to-top-btn.show {
            opacity: 1;
            visibility: visible;
        }
        #back-to-top-btn:hover {
            background: rgba(0,0,0,0.8);
            transform: scale(1.1);
        }
    </style>
    <link rel="stylesheet" href="../common-assets/css/chapter-light-overrides.css">

</head>
<body>
    <div class="return-home-panel">
        <a class="return-link return-sub" href="index.html">← 返回课件目录</a>
        <a class="return-link return-main" href="../index.html">⌂ 返回主站</a>
    </div>

    <div id="presentation-container">
        
        <!-- 幻灯片0：标题页 -->
        <div class="slide active">
            <div class="chalkboard" style="flex: 1; text-align: center;">
                <h2 style="font-size: 4rem; border: none;">第一章</h2>
                <p style="font-size: 2.5rem; color: white;">代数与函数</p>
                
                <div class="home-nav-buttons">
                    <a href="../index.html" class="home-nav-btn">
                        <span class="btn-icon">HOME</span>
                        <span class="btn-text">主页</span>
                    </a>
                    <a href="../故事书/index.html" class="home-nav-btn">
                        <span class="btn-icon">STORY</span>
                        <span class="btn-text">故事书</span>
                    </a>
                    <a href="../习题/index.html" class="home-nav-btn">
                        <span class="btn-icon">EXERCISE</span>
                        <span class="btn-text">习题</span>
                    </a>
                    <a href="../网页资源/index.html" class="home-nav-btn">
                        <span class="btn-icon">RESOURCE</span>
                        <span class="btn-text">网页资源</span>
                    </a>
                </div>
            </div>
        </div>

        <!-- 幻灯片1：目录页 -->
        <div class="slide">
            <div class="chalkboard" style="flex: 1; text-align: center; overflow-y: auto; align-items: flex-start; justify-content: flex-start;">
                <div style="writing-mode: vertical-rl; text-orientation: mixed; font-size: 3rem; border: none; margin-bottom: 1.5rem; height: 8rem; display: flex; align-items: flex-start; justify-content: center;">
                    目录
                </div>
                
                <div style="width: 100%; max-width: 1200px; text-align: left; padding: 2rem; margin: 0 auto;">
                    <div style="background: rgba(255,255,255,0.1); padding: 1.2rem; border-radius: 10px; margin-bottom: 1.5rem;">
                        <h3 style="color: #e74c3c; font-size: 1.5rem; margin-bottom: 0.8rem; border-bottom: 2px solid #e74c3c; padding-bottom: 0.3rem;">第一节：集合与函数概念</h3>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 1.1 集合与区间</p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 1.2 函数的概念 (定义、定义域、值域)</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.1); padding: 1.2rem; border-radius: 10px; margin-bottom: 1.5rem;">
                        <h3 style="color: #3498db; font-size: 1.5rem; margin-bottom: 0.8rem; border-bottom: 2px solid #3498db; padding-bottom: 0.3rem;">第二节：基本初等函数</h3>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 2.1 幂函数 & 指数运算</p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 2.2 指数函数</p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 2.3 对数函数 & 对数运算</p>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 2.4 三角函数与反三角函数</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.1); padding: 1.2rem; border-radius: 10px; margin-bottom: 1.5rem;">
                        <h3 style="color: #2ecc71; font-size: 1.5rem; margin-bottom: 0.8rem; border-bottom: 2px solid #2ecc71; padding-bottom: 0.3rem;">第三节：函数的基本性质</h3>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 3.1 单调性 • 3.2 奇偶性 • 3.3 周期性 • 3.4 有界性</p>
                    </div>

                    <div style="background: rgba(255,255,255,0.1); padding: 1.2rem; border-radius: 10px;">
                        <h3 style="color: #f1c40f; font-size: 1.5rem; margin-bottom: 0.8rem; border-bottom: 2px solid #f1c40f; padding-bottom: 0.3rem;">第四节：函数的运算</h3>
                        <p style="font-size: 1.1rem; line-height: 1.6;">• 4.1 反函数 • 4.2 复合函数</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 幻灯片2：视频介绍页 -->
        <div class="slide">
            <div class="chalkboard" style="flex: 1; text-align: center; padding: 1rem; overflow: hidden; display: flex; flex-direction: column; justify-content: center;">
                <div style="position: relative; width: 100%; max-width: 400px; height: 0; padding-bottom: 28%; margin: 0 auto;">
                    <iframe 
                        src="https://player.bilibili.com/player.html?bvid=BV1ph4y1g75E&t=22.7&autoplay=0&high_quality=1" 
                        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);"
                        allowfullscreen>
                    </iframe>
                </div>
            </div>
        </div>

        <!-- 第一节：集合与函数概念 -->
        
        <!-- 幻灯片3：集合与常量变量 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>集合、常量与变量</h2>
                
                <h3>集合</h3>
                <p>指具有某种<span class="highlight">特定性质</span>的、确定的、可以区分的事物的<span class="highlight">全体</span>。</p>
                <p>例如：所有正整数的集合 {1, 2, 3, ...}</p>
                
                <h3>常量</h3>
                <p>在问题研究过程中，<span class="highlight">取值始终保持不变</span>的量。</p>
                <ul>
                    <li>例如：圆周率 $\pi \approx 3.14159$，自然常数 $e \approx 2.718$</li>
                    <li>在 $y=2x+1$ 中，数字 $2$ 和 $1$ 都是常量</li>
                </ul>
                
                <h3>变量</h3>
                <p>在一定范围内，<span class="highlight">可以取不同数值</span>的量。</p>
                <ul>
                    <li>例如：时间 $t$，温度 $T$，速度 $v$</li>
                    <li>在 $y=2x+1$ 中，$x$ 和 $y$ 都是变量</li>
                </ul>
            </div>
            <div class="visualization" id="vis-variables"></div>
        </div>

        <!-- 幻灯片4：区间表示法 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>区间表示法</h2>
                
                <h3>闭区间 [a, b]</h3>
                <p>包括端点 $a$ 和 $b$。$a \le x \le b$</p>
                
                <h3>开区间 (a, b)</h3>
                <p>不包括端点 $a$ 和 $b$。$a < x < b$</p>
                
                <h3>半开半闭区间</h3>
                <p>$[a, b)$：包括 $a$，不包括 $b$。$a \le x < b$</p>
                <p>$(a, b]$：不包括 $a$，包括 $b$。$a < x \le b$</p>
            </div>
            <div class="visualization" id="vis-intervals"></div>
        </div>

        <!-- 幻灯片5：函数定义 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>函数</h2>
                <p>函数是一种<span class="highlight">特殊的对应关系</span>，就像一个"加工机器"。</p>
                <p>对于每一个输入的数值 $x$（来自一个指定的集合 A），这台机器都能产出<span class="highlight">唯一确定</span>的输出数值 $y$（来自集合 B）。</p>
                <div class="math-formula">
                    $y = f(x)$
                </div>
                <ul>
                    <li>$x$：自变量 (Input)</li>
                    <li>$f$：对应法则 (Rule / Machine)</li>
                    <li>$y$：因变量 (Output)</li>
                </ul>
            </div>
            <div class="visualization" id="vis-function-machine"></div>
        </div>

        <!-- 幻灯片6：定义域 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>定义域</h3>
                <p>思考：要让函数表达式有意义，$x$ 可以取哪些值？</p>
                <ul>
                    <li>分母不能为零</li>
                    <li>偶次根号下的数必须大于等于零</li>
                    <li>对数的真数必须大于零</li>
                </ul>
                <p>$f(x) = \frac{1}{x-2}$，分母 $x-2 \neq 0$，所以定义域是 $x \neq 2$</p>
                <p>$g(x) = \sqrt{x-3}$，根号下 $x-3 \ge 0$，所以定义域是 $x \ge 3$</p>
            </div>
            <div class="visualization" id="vis-domain"></div>
        </div>

        <!-- 幻灯片7：值域 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>值域</h3>
                <p>当 $x$ 取遍定义域中的所有值时，对应的 $y$ 值组成了值域。</p>
                <ul>
                    <li>观察法：对于简单函数，直接观察图像</li>
                    <li>配方法：对于二次函数</li>
                    <li>反函数法：求反函数的定义域</li>
                </ul>
                <p>$f(x) = x^2$。因为平方永远是非负数，所以值域是 $y \ge 0$</p>
                <p>$g(x) = \sin(x)$。正弦函数的值在 -1 和 1 之间波动，所以值域是 $[-1, 1]$</p>
            </div>
            <div class="visualization" id="vis-range"></div>
        </div>

        <!-- 第二节：基本初等函数 -->
        
        <!-- 幻灯片8：基本初等函数介绍 -->
        <div class="slide">
            <div class="visualization full-width" id="vis-elementary-intro"></div>
        </div>

        <!-- 幻灯片9：幂函数可视化 -->
        <div class="slide">
            <div class="visualization fullscreen" id="vis-power-function"></div>
        </div>

        <!-- 幻灯片10：指数定义 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>指数</h2>
                <h3>定义</h3>
                <p>指数表示一个数（底数）连续乘以自身多少次。</p>
                <div class="math-formula">
                    $a^n = \underbrace{a \times a \times \dots \times a}_{n \text{ 个}}$
                </div>
                <p>其中，$a$ 是 <span class="highlight">底数</span>，$n$ 是 <span class="highlight">指数</span>。</p>
                <h3>例子</h3>
                <p>$2^3 = 2 \times 2 \times 2 = 8$</p>
                <p>$10^4 = 10 \times 10 \times 10 \times 10 = 10000$</p>
            </div>
            <div class="visualization" id="vis-exponents"></div>
        </div>

        <!-- 幻灯片11：指数运算法则1 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>乘法法则</h3>
                <div class="formula-rule">
                    $a^m \cdot a^n = a^{m+n}$
                </div>
                <p>同底数幂相乘，<span class="highlight">底数不变，指数相加</span>。</p>
                <p>例：$2^3 \cdot 2^4 = 2^{3+4} = 2^7 = 128$</p>
                
                <h3>除法法则</h3>
                <div class="formula-rule">
                    $\frac{a^m}{a^n} = a^{m-n}$
                </div>
                <p>同底数幂相除，<span class="highlight">底数不变，指数相减</span>。</p>
                <p>例：$\frac{5^7}{5^3} = 5^{7-3} = 5^4 = 625$</p>
            </div>
            <div class="visualization" id="vis-exponent-rules-1"></div>
        </div>

        <!-- 幻灯片12：指数运算法则2 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>幂的幂法则</h3>
                <div class="formula-rule">
                    $(a^m)^n = a^{m \cdot n}$
                </div>
                <p>幂的幂，<span class="highlight">底数不变，指数相乘</span>。</p>
                <p>例：$(3^2)^4 = 3^{2 \times 4} = 3^8$</p>
                
                <h3>乘积的幂法则</h3>
                <div class="formula-rule">
                    $(ab)^n = a^n \cdot b^n$
                </div>
                <p>积的幂等于<span class="highlight">幂的积</span>。</p>
                <p>例：$(2 \times 3)^4 = 2^4 \times 3^4 = 16 \times 81$</p>
            </div>
            <div class="visualization" id="vis-exponent-rules-2"></div>
        </div>

        <!-- 幻灯片13：零指数与负指数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>零指数</h3>
                <div class="formula-rule">
                    $a^0 = 1$ （$a \neq 0$）
                </div>
                <p>任何非零数的零次方都等于 <span class="highlight">1</span>。</p>
                <p>可以通过 $\frac{a^m}{a^m} = a^{m-m} = a^0$ 来理解。</p>
                
                <h3>负指数</h3>
                <div class="formula-rule">
                    $a^{-n} = \frac{1}{a^n}$
                </div>
                <p>负指数表示<span class="highlight">倒数</span>。</p>
                <p>可以从 $\frac{a^0}{a^n} = a^{0-n} = a^{-n}$ 推导出来。</p>
            </div>
            <div class="visualization" id="vis-special-exponents"></div>
        </div>

        <!-- 幻灯片14：分数指数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>分数指数</h3>
                <p>分数指数是<span class="highlight">开方运算</span>的另一种写法。</p>
                <div class="formula-rule">
                    $a^{\frac{1}{n}} = \sqrt[n]{a}$
                </div>
                <p>读作：$a$ 的 $n$ 分之一次方等于 $a$ 的 $n$ 次方根。</p>
                <p>• $27^{\frac{1}{3}} = \sqrt[3]{27} = 3$</p>
                <p>• $16^{\frac{1}{4}} = \sqrt[4]{16} = 2$</p>
                <p>• $8^{\frac{1}{3}} = \sqrt[3]{8} = 2$</p>
                <p>指数 $\frac{1}{n}$ 表示：<span class="highlight">"什么数的 $n$ 次方等于底数？"</span></p>
            </div>
            <div class="visualization" id="vis-fractional-exponents"></div>
        </div>

        <!-- 幻灯片15：指数函数可视化 -->
        <div class="slide">
            <div class="visualization full-width white-bg" id="vis-interactive-exponential"></div>
        </div>

        <!-- 幻灯片16：对数发展历史 -->
        <div class="slide">
            <div class="visualization full-width" id="vis-log-history"></div>
        </div>

        <!-- 幻灯片17：对数定义 -->
        <div class="slide">
            <div class="chalkboard">
                <h2>对数</h2>
                <p>对数是<strong>指数</strong>的逆运算。</p>
                <p>如果 $b^y = x$，那么 $\log_b(x) = y$</p>
                <ul>
                    <li>$b$ 是底数</li>
                    <li>$x$ 是真数</li>
                    <li>$y$ 就是以$b$为底$x$的对数</li>
                </ul>
                <p>对数 $y$ 回答了一个问题："底数 $b$ 需要自身相乘多少次才能得到 $x$？"</p>
                <p>将复杂的大数<strong>乘除</strong>运算，转化为简单的<strong>加减</strong>运算。</p>
            </div>
            <div class="visualization" id="vis-log-definition">
                <svg id="animation2" width="100%" height="100%"></svg>
            </div>
        </div>

        <!-- 幻灯片18：对数函数可视化 -->
        <div class="slide">
            <div class="visualization full-width white-bg" id="vis-interactive-logarithm"></div>
        </div>

        <!-- 幻灯片19：对数运算法则 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>乘积的对数</h3>
                <p>$\log_b(xy) = \log_b(x) + \log_b(y)$</p>
                <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                    <strong>例：</strong>$\log_2(8 \times 4) = \log_2(8) + \log_2(4) = 3 + 2 = 5$<br>
                    验证：$2^5 = 32 = 8 \times 4$ ✓
                </p>

                <h3>商的对数</h3>
                <p>$\log_b(\frac{x}{y}) = \log_b(x) - \log_b(y)$</p>
                <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
                    <strong>例：</strong>$\log_2(\frac{16}{4}) = \log_2(16) - \log_2(4) = 4 - 2 = 2$<br>
                    验证：$2^2 = 4 = \frac{16}{4}$ ✓
                </p>

                <h3>幂的对数</h3>
                <p>$\log_b(x^n) = n \cdot \log_b(x)$</p>

                <h3>换底公式</h3>
                <p>$\log_b(x) = \frac{\log_a(x)}{\log_a(b)}$</p>
            </div>
            <div class="visualization" id="vis-log-properties"></div>
        </div>

        <!-- 幻灯片20：常用对数系统 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>常用对数系统</h3>
                <div style="margin: 20px 0;">
                    <h3 style="color: #e74c3c;">常用对数（lg）</h3>
                    <p>以10为底的对数：$\lg(x) = \log_{10}(x)$</p>
                    <ul>
                        <li>$\lg(10) = 1$</li>
                        <li>$\lg(100) = 2$</li>
                        <li>$\lg(1000) = 3$</li>
                    </ul>
                </div>
                <div style="margin: 20px 0;">
                    <h3 style="color: #27ae60;">自然对数（ln）</h3>
                    <p>以$e$为底的对数：$\ln(x) = \log_e(x)$</p>
                    <p>其中 $e \approx 2.718...$（欧拉数）</p>
                    <ul>
                        <li>$\ln(e) = 1$</li>
                        <li>$\ln(e^2) = 2$</li>
                        <li>$\ln(1) = 0$</li>
                    </ul>
                </div>
            </div>
            <div class="visualization" id="vis-common-logs">
                <svg id="animation5" width="100%" height="100%"></svg>
            </div>
        </div>

        <!-- 幻灯片21：对数运算可视化 -->
        <div class="slide">
            <div class="visualization full-width white-bg" id="vis-log-operations">
                <svg id="animation3" width="100vw" height="100vh"></svg>
            </div>
        </div>

        <!-- 幻灯片22：三角函数可视化 (优化版) -->
        <div class="slide">
            <div class="chalkboard" style="flex: 0 0 30%; padding: 20px; overflow-y: auto;">
                <h2 id="trig-functions-anchor">三角函数</h2>
                <h3>单位圆定义</h3>
                <p>在单位圆上，一个角 \(\theta\) 的终边与圆交于点 \(P(x, y)\)，则：</p>
                <ul>
                    <li>\(\sin(\theta) = y\) (正弦)</li>
                    <li>\(\cos(\theta) = x\) (余弦)</li>
                    <li>\(\tan(\theta) = \frac{y}{x}\) (正切)</li>
                </ul>
                <div id="trig-info-box" class="info-box-style"></div>
                <div class="toc-local">
                    <h4>本节导航</h4>
                    <a href="javascript:void(0);" onclick="document.getElementById('vis-interactive-trig').scrollIntoView({behavior: 'smooth'});">三角函数</a>
                    <a href="javascript:void(0);" onclick="document.getElementById('vis-interactive-inv-trig').scrollIntoView({behavior: 'smooth'});">反三角函数</a>
                </div>
            </div>
            <div class="visualization white-bg" style="flex: 1;" id="vis-interactive-trig"></div>
        </div>

        <!-- 幻灯片23：六种三角与余函数图像总览 -->
        <div class="slide">
            <div class="visualization white-bg" style="flex: 1;" id="vis-trig-all"></div>
        </div>

        <!-- 幻灯片23：反三角函数可视化 (优化版) -->
        <div class="slide">
            <div class="chalkboard" style="flex: 0 0 30%; padding: 20px; overflow-y: auto;">
                <h2 id="inv-trig-functions-anchor">反三角函数</h2>
                <h3>定义</h3>
                <p>为了让三角函数有反函数，我们必须限制其定义域，使其成为一一对应的关系。</p>
                <ul>
                    <li>反正弦 (arcsin): 定义域 \([-1, 1]\), 值域 \([-\frac{\pi}{2}, \frac{\pi}{2}]\)</li>
                    <li>反余弦 (arccos): 定义域 \([-1, 1]\), 值域 \([0, \pi]\)</li>
                </ul>
                <p>拖动图中的滑块，观察 \(y=\sin(x)\) 如何通过限制定义域来得到其反函数 \(y=\arcsin(x)\)。</p>
                 <div class="toc-local">
                    <h4>本节导航</h4>
                    <a href="javascript:void(0);" onclick="document.getElementById('vis-interactive-trig').scrollIntoView({behavior: 'smooth'});">三角函数</a>
                    <a href="javascript:void(0);" onclick="document.getElementById('vis-interactive-inv-trig').scrollIntoView({behavior: 'smooth'});">反三角函数</a>
                </div>
            </div>
            <div class="visualization white-bg" style="flex: 1;" id="vis-interactive-inv-trig"></div>
        </div>

        <!-- 第三节：函数的基本性质 -->
        
        <!-- 幻灯片24：函数性质介绍 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>函数的基本性质</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                    <div>
                        <h4><span class="highlight">单调性</span></h4>
                        <p>描述函数图像是"上坡"还是"下坡"</p>
                    </div>
                    <div>
                        <h4><span class="highlight">奇偶性</span></h4>
                        <p>描述函数图像的对称性</p>
                    </div>
                    <div>
                        <h4><span class="highlight">周期性</span></h4>
                        <p>描述函数图像的重复性</p>
                    </div>
                    <div>
                        <h4><span class="highlight">有界性</span></h4>
                        <p>描述函数值的范围限制</p>
                    </div>
                </div>
            </div>
            <div class="visualization" id="vis-properties-intro"></div>
        </div>

        <!-- 幻灯片25：单调递增 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>单调递增</h3>
                <p>在一个区间内，如果函数值 $y$ <span class="highlight">随着 $x$ 的增大而增大</span>，那么函数在该区间上是单调递增的。</p>
                <p>几何上看，图像是<span class="highlight">从左到右上升的（上坡）</span>。</p>
                <div class="math-formula">
                    若 $x_1 < x_2$，则 $f(x_1) < f(x_2)$
                </div>
            </div>
            <div class="visualization" id="vis-monotonicity-inc"></div>
        </div>

        <!-- 幻灯片26：单调递减 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>单调递减</h3>
                <p>在一个区间内，如果函数值 $y$ <span class="highlight">随着 $x$ 的增大而减小</span>，那么函数在该区间上是单调递减的。</p>
                <p>几何上看，图像是<span class="highlight">从左到右下降的（下坡）</span>。</p>
                <div class="math-formula">
                    若 $x_1 < x_2$，则 $f(x_1) > f(x_2)$
                </div>
            </div>
            <div class="visualization" id="vis-monotonicity-dec"></div>
        </div>

        <!-- 幻灯片27：单调区间 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>单调区间</h3>
                <p>函数的单调性在不同区间可能呈现不同特征。</p>
                <p>分析函数性质时，需要明确划分其单调递增和单调递减的区间范围。</p>
                <p>$f(x) = x^2$</p>
                <ul>
                    <li>在区间 $(-\infty, 0]$ 上，函数<span class="highlight">单调递减</span>。</li>
                    <li>在区间 $[0, +\infty)$ 上，函数<span class="highlight">单调递增</span>。</li>
                </ul>
                <p>点 $x=0$ 是它的"转折点"。</p>
            </div>
            <div class="visualization" id="vis-monotonicity-intervals"></div>
        </div>

        <!-- 幻灯片28：奇偶性介绍 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>奇偶性</h3>
                <p>奇偶性描述的是函数图像关于<span class="highlight">坐标轴或原点</span>的对称性。</p>
                <p>判断奇偶性的前提是：函数的<span class="highlight">定义域必须关于原点对称</span>。</p>
                <ul>
                    <li><strong>偶函数</strong>：图像关于 Y 轴对称</li>
                    <li><strong>奇函数</strong>：图像关于原点对称</li>
                </ul>
            </div>
            <div class="visualization" id="vis-parity-intro"></div>
        </div>

        <!-- 幻灯片29：偶函数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>偶函数</h3>
                <p>如果对于定义域内的任意 $x$，都满足：</p>
                <div class="math-formula">
                    $f(-x) = f(x)$
                </div>
                <p>那么 $f(x)$ 就是一个偶函数。</p>
                <p>函数图像关于 <span class="highlight">Y 轴对称</span>。就像镜子一样。</p>
                <p>例：$f(x) = x^2$, $f(x) = |x|$, $f(x) = \cos(x)$</p>
            </div>
            <div class="visualization" id="vis-even-function"></div>
        </div>

        <!-- 幻灯片30：奇函数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>奇函数</h3>
                <p>如果对于定义域内的任意 $x$，都满足：</p>
                <div class="math-formula">
                    $f(-x) = -f(x)$
                </div>
                <p>那么 $f(x)$ 就是一个奇函数。</p>
                <p>函数图像关于 <span class="highlight">原点 (0,0) 对称</span>。图像旋转180度后会与原图重合。</p>
                <p>例：$f(x) = x$, $f(x) = x^3$, $f(x) = \sin(x)$</p>
            </div>
            <div class="visualization" id="vis-odd-function"></div>
        </div>

        <!-- 幻灯片31：有界性 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>有界性</h3>
                <p>如果存在一个正数 M，使得函数 f(x) 在其整个定义域上，恒有 <span class="highlight">|f(x)| ≤ M</span> 成立，那么就称 f(x) 为有界函数。</p>
                <p>通俗地说，函数的图像被两条水平线"夹住"了，既不会跑到"天上去"，也不会掉到"无底洞"。</p>
                <p>例如：</p>
                <ul>
                    <li>$y = \sin(x)$ 和 $y = \cos(x)$ 都是有界函数，因为它们的值域都在 $[-1, 1]$ 之间</li>
                    <li>$y = x^2$ 在 $(-\infty, +\infty)$ 上无界，但在任何有限区间 $[a, b]$ 上有界</li>
                </ul>
            </div>
            <div class="visualization" id="vis-boundedness"></div>
        </div>

        <!-- 第四节：函数的运算 -->
        
        <!-- 幻灯片32：反函数定义 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>反函数</h3>
                <p>如果函数 $f$ 把 $x$ 变成了 $y$，那么它的反函数 $f^{-1}$ 就是把 $y$ <span class="highlight">变回</span> $x$ 的操作。</p>
                <div class="math-formula">
                    若 $y = f(x)$，则 $x = f^{-1}(y)$
                </div>
                <p><span class="highlight">注意</span>：只有单调函数（严格一对一的函数）才有反函数。</p>
            </div>
            <div class="visualization" id="vis-inverse-machine"></div>
        </div>

        <!-- 幻灯片33：反函数图像 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>反函数与原函数</h3>
                <ul>
                    <li>原函数 $f(x)$ 的<span class="highlight">定义域</span>是反函数 $f^{-1}(x)$ 的<span class="highlight">值域</span>。</li>
                    <li>原函数 $f(x)$ 的<span class="highlight">值域</span>是反函数 $f^{-1}(x)$ 的<span class="highlight">定义域</span>。</li>
                </ul>
                <p>函数 $y=f(x)$ 和它的反函数 $y=f^{-1}(x)$ 的图像关于直线 <span class="highlight">$y=x$ 对称</span>。</p>
            </div>
            <div class="visualization" id="vis-inverse-graph"></div>
        </div>

        <!-- 幻灯片34：指对数互为反函数可视化 -->
        <div class="slide">
            <div class="visualization full-width white-bg" id="vis-interactive-inverse-exp-log"></div>
        </div>

        <!-- 幻灯片35：复合函数 -->
        <div class="slide">
            <div class="chalkboard">
                <h3>复合函数</h3>
                <p>如果 $u=g(x)$，而 $y=f(u)$，那么 $y=f(g(x))$ 就是一个复合函数。</p>
                <ul>
                    <li>$g(x)$ 是<span class="highlight">内层函数</span>。</li>
                    <li>$f(u)$ 是<span class="highlight">外层函数</span>。</li>
                </ul>
                <p>计算时，要<span class="highlight">由内向外</span>，层层计算。</p>
                <p>1. 先算内层函数：$u = g(x)$</p>
                <p>2. 再把结果 $u$ 代入外层函数：$y = f(u)$</p>
            </div>
            <div class="visualization" id="vis-composite-machine"></div>
        </div>

        <!-- 翻页按钮 -->
        <div class="nav-buttons">
            <button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">‹</button>
            <button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">›</button>
        </div>

        <div class="page-indicator" id="page-indicator">1 / 37</div>
</div>


 

<!-- 统一控制面板 -->
<div class="unified-control-panel">
<!-- 浮动菜单按钮 -->
<div id="floating-menu">
    <div id="menu-toggle" class="menu-toggle">
        <span class="menu-icon">☰</span>
    </div>
    <div id="menu-content" class="menu-content">
        <div class="menu-section">
            <div class="menu-section-title">实验室</div>
        <a href="../网页资源/lab 1-1.html" target="_blank" class="menu-item">
                <span class="menu-icon">📊</span>
            <span class="menu-text">指数运算实验室</span>
        </a>
        <a href="../网页资源/lab 1-2.html" target="_blank" class="menu-item">
                <span class="menu-icon">📈</span>
            <span class="menu-text">对数运算实验室</span>
        </a>
        <a href="../网页资源/lab 1-3.html" target="_blank" class="menu-item">
                <span class="menu-icon">🌊</span>
                <span class="menu-text">三角函数实验室</span>
        </a>
        <a href="../网页资源/lab 1-4.html" target="_blank" class="menu-item">
                <span class="menu-icon">🔄</span>
                <span class="menu-text">反三角函数实验室</span>
            </a>
        <!-- 1章剩余 -->
        <a href="../网页资源/lab 1-5.html" target="_blank" class="menu-item"><span class="menu-icon">🔬</span><span class="menu-text">Lab 1-5</span></a>
        <a href="../网页资源/lab 1-6.html" target="_blank" class="menu-item"><span class="menu-icon">🔬</span><span class="menu-text">Lab 1-6</span></a>
        <a href="../网页资源/lab 1-7.html" target="_blank" class="menu-item"><span class="menu-icon">🔬</span><span class="menu-text">Lab 1-7</span></a>
        <a href="../网页资源/lab 1-8.html" target="_blank" class="menu-item"><span class="menu-icon">🔬</span><span class="menu-text">Lab 1-8</span></a>
        <a href="../网页资源/lab 1-9.html" target="_blank" class="menu-item"><span class="menu-icon">🔬</span><span class="menu-text">Lab 1-9</span></a>

        <!-- 2章 -->
        <a href="../网页资源/lab 2-1.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-1</span></a>
        <a href="../网页资源/lab 2-2.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-2</span></a>
        <a href="../网页资源/lab 2-3.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-3</span></a>
        <a href="../网页资源/lab 2-4.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-4</span></a>
        <a href="../网页资源/lab 2-5.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-5</span></a>
        <a href="../网页资源/lab 2-6.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-6</span></a>
        <a href="../网页资源/lab 2-7.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-7</span></a>
        <a href="../网页资源/lab 2-8.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-8</span></a>
        <a href="../网页资源/lab 2-9.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-9</span></a>
        <a href="../网页资源/lab 2-10.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-10</span></a>
        <a href="../网页资源/lab 2-11.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-11</span></a>
        <a href="../网页资源/lab 2-12.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-12</span></a>
        <a href="../网页资源/lab 2-13.html" target="_blank" class="menu-item"><span class="menu-icon">2️⃣</span><span class="menu-text">Lab 2-13</span></a>

        <!-- 3章 -->
        <a href="../网页资源/lab 3-1.html" target="_blank" class="menu-item"><span class="menu-icon">3️⃣</span><span class="menu-text">Lab 3-1</span></a>
        <a href="../网页资源/lab 3-2.html" target="_blank" class="menu-item"><span class="menu-icon">3️⃣</span><span class="menu-text">Lab 3-2</span></a>
        <a href="../网页资源/lab 3-3.html" target="_blank" class="menu-item"><span class="menu-icon">3️⃣</span><span class="menu-text">Lab 3-3</span></a>
        <a href="../网页资源/lab 3-4.html" target="_blank" class="menu-item"><span class="menu-icon">3️⃣</span><span class="menu-text">Lab 3-4</span></a>
        <a href="../网页资源/lab 3-5.html" target="_blank" class="menu-item"><span class="menu-icon">3️⃣</span><span class="menu-text">Lab 3-5</span></a>
        <a href="../网页资源/lab 3-6.html" target="_blank" class="menu-item"><span class="menu-icon">3️⃣</span><span class="menu-text">Lab 3-6</span></a>

        <!-- 4章 -->
        <a href="../网页资源/lab 4-1.html" target="_blank" class="menu-item"><span class="menu-icon">4️⃣</span><span class="menu-text">Lab 4-1</span></a>
        <a href="../网页资源/lab 4-2.html" target="_blank" class="menu-item"><span class="menu-icon">4️⃣</span><span class="menu-text">Lab 4-2</span></a>
        <a href="../网页资源/lab 4-3.html" target="_blank" class="menu-item"><span class="menu-icon">4️⃣</span><span class="menu-text">Lab 4-3</span></a>

        <!-- 5章 -->
        <a href="../网页资源/lab 5-1.html" target="_blank" class="menu-item"><span class="menu-icon">5️⃣</span><span class="menu-text">Lab 5-1</span></a>
        <a href="../网页资源/lab 5-2.html" target="_blank" class="menu-item"><span class="menu-icon">5️⃣</span><span class="menu-text">Lab 5-2</span></a>
        <a href="../网页资源/lab 5-3.html" target="_blank" class="menu-item"><span class="menu-icon">5️⃣</span><span class="menu-text">Lab 5-3</span></a>
        <a href="../网页资源/lab 5-4.html" target="_blank" class="menu-item"><span class="menu-icon">5️⃣</span><span class="menu-text">Lab 5-4</span></a>
        <a href="../网页资源/lab 5-5.html" target="_blank" class="menu-item"><span class="menu-icon">5️⃣</span><span class="menu-text">Lab 5-5</span></a>

        <!-- 6章 -->
        <a href="../网页资源/lab 6-1.html" target="_blank" class="menu-item"><span class="menu-icon">6️⃣</span><span class="menu-text">Lab 6-1</span></a>
        <a href="../网页资源/lab 6-2.html" target="_blank" class="menu-item"><span class="menu-icon">6️⃣</span><span class="menu-text">Lab 6-2</span></a>
        <a href="../网页资源/lab 6-3.html" target="_blank" class="menu-item"><span class="menu-icon">6️⃣</span><span class="menu-text">Lab 6-3</span></a>
        <a href="../网页资源/lab 6-4.html" target="_blank" class="menu-item"><span class="menu-icon">6️⃣</span><span class="menu-text">Lab 6-4</span></a>
        <a href="../网页资源/lab 6-5.html" target="_blank" class="menu-item"><span class="menu-icon">6️⃣</span><span class="menu-text">Lab 6-5</span></a>

        <!-- 7章 -->
        <a href="../网页资源/lab 7-1.html" target="_blank" class="menu-item"><span class="menu-icon">7️⃣</span><span class="menu-text">Lab 7-1</span></a>
        <a href="../网页资源/lab 7-2.html" target="_blank" class="menu-item"><span class="menu-icon">7️⃣</span><span class="menu-text">Lab 7-2</span></a>
        <a href="../网页资源/lab 7-3.html" target="_blank" class="menu-item"><span class="menu-icon">7️⃣</span><span class="menu-text">Lab 7-3</span></a>
        <a href="../网页资源/lab 7-4.html" target="_blank" class="menu-item"><span class="menu-icon">7️⃣</span><span class="menu-text">Lab 7-4</span></a>
        <a href="../网页资源/lab 7-5.html" target="_blank" class="menu-item"><span class="menu-icon">7️⃣</span><span class="menu-text">Lab 7-5</span></a>

        <!-- 8章 -->
        <a href="../网页资源/lab 8-1.html" target="_blank" class="menu-item"><span class="menu-icon">8️⃣</span><span class="menu-text">Lab 8-1</span></a>
        <a href="../网页资源/lab 8-2.html" target="_blank" class="menu-item"><span class="menu-icon">8️⃣</span><span class="menu-text">Lab 8-2</span></a>
        <a href="../网页资源/lab 8-3.html" target="_blank" class="menu-item"><span class="menu-icon">8️⃣</span><span class="menu-text">Lab 8-3</span></a>
        <a href="../网页资源/lab 8-4.html" target="_blank" class="menu-item"><span class="menu-icon">8️⃣</span><span class="menu-text">Lab 8-4</span></a>
        <a href="../网页资源/lab 8-5.html" target="_blank" class="menu-item"><span class="menu-icon">8️⃣</span><span class="menu-text">Lab 8-5</span></a>
        <a href="../网页资源/lab 8-6.html" target="_blank" class="menu-item"><span class="menu-icon">8️⃣</span><span class="menu-text">Lab 8-6</span></a>

        <!-- 9章 -->
        <a href="../网页资源/lab 9-1.html" target="_blank" class="menu-item"><span class="menu-icon">9️⃣</span><span class="menu-text">Lab 9-1</span></a>
        <a href="../网页资源/lab 9-2.html" target="_blank" class="menu-item"><span class="menu-icon">9️⃣</span><span class="menu-text">Lab 9-2</span></a>
        <a href="../网页资源/lab 9-3.html" target="_blank" class="menu-item"><span class="menu-icon">9️⃣</span><span class="menu-text">Lab 9-3</span></a>

        <!-- 10章 -->
        <a href="../网页资源/lab 10-1.html" target="_blank" class="menu-item"><span class="menu-icon">🔟</span><span class="menu-text">Lab 10-1</span></a>
        <a href="../网页资源/lab 10-2.html" target="_blank" class="menu-item"><span class="menu-icon">🔟</span><span class="menu-text">Lab 10-2</span></a>
        <a href="../网页资源/lab 10-3.html" target="_blank" class="menu-item"><span class="menu-icon">🔟</span><span class="menu-text">Lab 10-3</span></a>
        <a href="../网页资源/lab 10-4.html" target="_blank" class="menu-item"><span class="menu-icon">🔟</span><span class="menu-text">Lab 10-4</span></a>
        <a href="../网页资源/lab 10-5.html" target="_blank" class="menu-item"><span class="menu-icon">🔟</span><span class="menu-text">Lab 10-5</span></a>
        <a href="../网页资源/lab 10-6.html" target="_blank" class="menu-item"><span class="menu-icon">🔟</span><span class="menu-text">Lab 10-6</span></a>
        <a href="../网页资源/lab 10-7.html" target="_blank" class="menu-item"><span class="menu-icon">🔟</span><span class="menu-text">Lab 10-7</span></a>

        <!-- 11章 -->
        <a href="../网页资源/lab 11-1.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣1️⃣</span><span class="menu-text">Lab 11-1</span></a>
        <a href="../网页资源/lab 11-2.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣1️⃣</span><span class="menu-text">Lab 11-2</span></a>
        <a href="../网页资源/lab 11-3.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣1️⃣</span><span class="menu-text">Lab 11-3</span></a>
        <a href="../网页资源/lab 11-4.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣1️⃣</span><span class="menu-text">Lab 11-4</span></a>
        <a href="../网页资源/lab 11-5.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣1️⃣</span><span class="menu-text">Lab 11-5</span></a>

        <!-- 12章 -->
        <a href="../网页资源/lab 12-1.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣2️⃣</span><span class="menu-text">Lab 12-1</span></a>
        <a href="../网页资源/lab 12-2.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣2️⃣</span><span class="menu-text">Lab 12-2</span></a>
        <a href="../网页资源/lab 12-3.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣2️⃣</span><span class="menu-text">Lab 12-3</span></a>
        <a href="../网页资源/lab 12-4.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣2️⃣</span><span class="menu-text">Lab 12-4</span></a>
        <a href="../网页资源/lab 12-5.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣2️⃣</span><span class="menu-text">Lab 12-5</span></a>
        <a href="../网页资源/lab 12-6.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣2️⃣</span><span class="menu-text">Lab 12-6</span></a>

        <!-- 13章 -->
        <a href="../网页资源/lab 13-1.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣3️⃣</span><span class="menu-text">Lab 13-1</span></a>
        <a href="../网页资源/lab 13-2.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣3️⃣</span><span class="menu-text">Lab 13-2</span></a>
        <a href="../网页资源/lab 13-3.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣3️⃣</span><span class="menu-text">Lab 13-3</span></a>
        <a href="../网页资源/lab 13-4.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣3️⃣</span><span class="menu-text">Lab 13-4</span></a>
        <a href="../网页资源/lab 13-5.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣3️⃣</span><span class="menu-text">Lab 13-5</span></a>
        <a href="../网页资源/lab 13-6.html" target="_blank" class="menu-item"><span class="menu-icon">1️⃣3️⃣</span><span class="menu-text">Lab 13-6</span></a>
        </div>
        <div class="menu-section">
            <div class="menu-section-title">其他资源</div>
            <a href="../故事书/index.html" target="_blank" class="menu-item">
                <span class="menu-icon">📚</span>
                <span class="menu-text">故事书</span>
            </a>
            <a href="../习题/index.html" target="_blank" class="menu-item">
                <span class="menu-icon">📝</span>
                <span class="menu-text">习题</span>
            </a>
        </div>
    </div>
</div>

<!-- 章节目录菜单 -->
<div id="chapter-menu">
    <div id="chapter-toggle" class="menu-toggle">
        <span class="menu-icon">📚</span>
    </div>
    <div id="chapter-content" class="menu-content">
        <div class="menu-section">
            <div class="menu-section-title">基础概念</div>
        <a href="#" class="menu-item" onclick="goToSlide(0); toggleChapterMenu();">
            <span class="menu-icon">🏠</span>
            <span class="menu-text">标题页</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(1); toggleChapterMenu();">
            <span class="menu-icon">📋</span>
            <span class="menu-text">目录</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(3); toggleChapterMenu();">
            <span class="menu-icon">1</span>
            <span class="menu-text">集合、常量与变量</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(4); toggleChapterMenu();">
            <span class="menu-icon">2</span>
            <span class="menu-text">区间表示法</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(5); toggleChapterMenu();">
            <span class="menu-icon">3</span>
            <span class="menu-text">函数基础</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(6); toggleChapterMenu();">
            <span class="menu-icon">4</span>
            <span class="menu-text">定义域与值域</span>
        </a>
        </div>
        <div class="menu-section">
            <div class="menu-section-title">函数类型</div>
        <a href="#" class="menu-item" onclick="goToSlide(10); toggleChapterMenu();">
            <span class="menu-icon">5</span>
            <span class="menu-text">指数运算</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(16); toggleChapterMenu();">
            <span class="menu-icon">6</span>
            <span class="menu-text">对数运算</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(24); toggleChapterMenu();">
            <span class="menu-icon">7</span>
            <span class="menu-text">函数性质</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(32); toggleChapterMenu();">
            <span class="menu-icon">8</span>
            <span class="menu-text">反函数</span>
        </a>
        <a href="#" class="menu-item" onclick="goToSlide(35); toggleChapterMenu();">
            <span class="menu-icon">9</span>
            <span class="menu-text">复合函数</span>
        </a>
        </div>
    </div>
    </div>
</div>

<script>
        // === 基础导航功能 ===
        let slides, totalSlides, counter, currentSlide = 0;
        let currentAnimation;

        // 全局动画控制变量
        let globalAnimationPlaying = true;
        let globalAnimationSpeed = 1.0;
        let currentAnimationFunction = null;

        const animationState = {
            isPaused: false,
            speed: 1,
            resumeCallback: null,
        };

        function stopCurrentAnimation() {
            if (currentAnimation && typeof currentAnimation.interrupt === 'function') {
                currentAnimation.interrupt();
            }
            currentAnimation = null;
        }

        function applyCurrentAnimation(handlers) {
            if (!handlers || typeof handlers !== 'object') {
                currentAnimation = null;
                return;
            }

            currentAnimation = {
                pause: typeof handlers.pause === 'function' ? handlers.pause : () => {},
                resume: typeof handlers.resume === 'function' ? handlers.resume : () => {},
                setSpeed: typeof handlers.setSpeed === 'function' ? handlers.setSpeed : () => {},
                interrupt: typeof handlers.interrupt === 'function' ? handlers.interrupt : () => {},
            };

            currentAnimation.setSpeed(animationState.speed);

            if (animationState.isPaused) {
                currentAnimation.pause();
            }
        }

        function nextSlide() {
            if (!slides || totalSlides === 0) return;
            currentSlide = (currentSlide + 1) % totalSlides;
            showSlide(currentSlide);
        }

        function previousSlide() {
            if (!slides || totalSlides === 0) return;
            currentSlide = (currentSlide - 1 + totalSlides) % totalSlides;
            showSlide(currentSlide);
        }

        function showSlide(index) {
            if (!slides || index < 0 || index >= totalSlides) return;
            
            slides.forEach(slide => slide.classList.remove('active'));
            currentSlide = index;
            slides[currentSlide].classList.add('active');
            
            counter.textContent = `${currentSlide + 1} / ${totalSlides}`;
            updateNavButtons();
            
            
            // 运行当前幻灯片的可视化
            runVisualization(currentSlide);
            
            // 渲染数学公式
            setTimeout(() => renderMathJax(slides[currentSlide]), 50);
        }

        function updateNavButtons() {
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            
            if (prevBtn && nextBtn) {
                prevBtn.disabled = (currentSlide === 0);
                nextBtn.disabled = (currentSlide === totalSlides - 1);
            }
        }



        

        // 控制页面内的动画
        function controlPageAnimations() {
            // 这里可以添加控制页面内动画的逻辑
            // 例如控制D3动画、CSS动画等
        }

        // 重置页面内的动画
        function resetPageAnimations() {
            // 这里可以添加重置页面内动画的逻辑
        }

        // 初始化悬浮菜单
        function initFloatingMenus() {
            // 浮动菜单功能
            const menuToggle = document.getElementById('menu-toggle');
            const menuContent = document.getElementById('menu-content');
            
            if (menuToggle && menuContent) {
                menuToggle.addEventListener('click', function(e) {
                    e.stopPropagation();
                    menuToggle.classList.toggle('active');
                    menuContent.classList.toggle('active');
                });
                
                // 点击页面其他地方关闭菜单
                document.addEventListener('click', function(e) {
                    if (!menuToggle.contains(e.target) && !menuContent.contains(e.target)) {
                        menuToggle.classList.remove('active');
                        menuContent.classList.remove('active');
                    }
                });
                
                // 防止菜单内容点击时关闭菜单
                menuContent.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }

            // 章节目录菜单功能
            const chapterToggle = document.getElementById('chapter-toggle');
            const chapterContent = document.getElementById('chapter-content');
            
            if (chapterToggle && chapterContent) {
                chapterToggle.addEventListener('click', function(e) {
                    e.stopPropagation();
                    chapterToggle.classList.toggle('active');
                    chapterContent.classList.toggle('active');
                });
                
                // 点击页面其他地方关闭菜单
                document.addEventListener('click', function(e) {
                    if (!chapterToggle.contains(e.target) && !chapterContent.contains(e.target)) {
                        chapterToggle.classList.remove('active');
                        chapterContent.classList.remove('active');
                    }
                });
                
                // 防止菜单内容点击时关闭菜单
                chapterContent.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
        }

        // 章节目录菜单切换函数
        function toggleChapterMenu() {
            const chapterToggle = document.getElementById('chapter-toggle');
            const chapterContent = document.getElementById('chapter-content');
            
            if (chapterToggle && chapterContent) {
                chapterToggle.classList.toggle('active');
                chapterContent.classList.toggle('active');
            }
        }

        // 跳转到指定幻灯片
        function goToSlide(index) {
            if (index >= 0 && index < totalSlides) {
                showSlide(index);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            slides = document.querySelectorAll('.slide');
            totalSlides = slides.length;
            counter = document.getElementById('page-indicator');
            
            
            
            
            // 初始化悬浮菜单
            initFloatingMenus();
            
            showSlide(0);
            
            // 键盘导航
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ' ||
                    e.key === 'PageDown' || e.key === 'Enter') {
                    e.preventDefault();
                    nextSlide();
                }
                else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp' ||
                         e.key === 'PageUp' || e.key === 'Backspace') {
                    e.preventDefault();
                    previousSlide();
                }
                else if (e.key === 'Home') {
                    e.preventDefault();
                    showSlide(0);
                }
                else if (e.key === 'End') {
                    e.preventDefault();
                    showSlide(totalSlides - 1);
                }
            });
            
            // 鼠标滚轮导航（循环翻页）
            document.addEventListener('wheel', (e) => {
                let target = e.target;
                // 若在可滚动容器内，允许默认滚动
                while (target && target !== document.body) {
                    if (target.scrollHeight > target.clientHeight) {
                        return;
                    }
                    target = target.parentElement;
                }

                e.preventDefault();
                if (e.deltaY > 0) {
                    // 下滚：到末页后回到首页
                    currentSlide = (currentSlide + 1) % totalSlides;
                    showSlide(currentSlide);
                } else {
                    // 上滚：到首页前一页跳到末页
                    currentSlide = (currentSlide - 1 + totalSlides) % totalSlides;
                    showSlide(currentSlide);
                }
            }, { passive: false });
        });

        // === MathJax 渲染函数 ===
        const renderMathJax = async (container) => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                try {
                    await window.MathJax.typesetPromise([container]);
                } catch (error) {
                    console.warn('MathJax rendering failed:', error);
                }
            }
        };

        const renderMathJaxInContainer = async (containerId) => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                try {
                    const container = document.getElementById(containerId);
                    if (container) {
                        await window.MathJax.typesetPromise([container]);
                    }
                } catch (error) {
                    console.warn('MathJax container rendering failed:', error);
                }
            }
        };

        // === D3.js 辅助函数 ===
        function setupD3(containerId, margins = {top: 40, right: 40, bottom: 40, left: 40}) {
            const container = d3.select(`#${containerId}`);
            if (container.empty()) {
                console.error("Container not found:", containerId);
                return null;
            }
            container.html('');

            const bounds = container.node().getBoundingClientRect();
            if (bounds.width === 0 || bounds.height === 0) return null;

            const svg = container.append('svg')
                .attr('width', bounds.width)
                .attr('height', bounds.height);

            const width = bounds.width - margins.left - margins.right;
            const height = bounds.height - margins.top - margins.bottom;

            const g = svg.append('g')
                .attr('transform', `translate(${margins.left}, ${margins.top})`);

            return { container, svg, g, width, height };
        }

        function drawAxes(g, xScale, yScale, width, height) {
            g.append('g')
                .attr('transform', `translate(0, ${yScale(0)})`)
                .call(d3.axisBottom(xScale).ticks(10))
                .call(g => g.select(".domain").attr("stroke-width", 1.5).attr("stroke", "#333"))
                .call(g => g.selectAll(".tick line").remove());

            g.append('g')
                .attr('transform', `translate(${xScale(0)}, 0)`)
                .call(d3.axisLeft(yScale).ticks(10))
                .call(g => g.select(".domain").attr("stroke-width", 1.5).attr("stroke", "#333"))
                .call(g => g.selectAll(".tick line").remove());
        }

        function animatePath(path) {
            if (!path.node()) return;
            const totalLength = path.node().getTotalLength();
            path.attr("stroke-dasharray", totalLength + " " + totalLength)
                .attr("stroke-dashoffset", totalLength)
                .transition()
                .duration(2000)
                .ease(d3.easeLinear)
                .attr("stroke-dashoffset", 0);
        }

        // === 可视化函数 ===
        
        // 幻灯片3：常量与变量可视化
        function visualizeVariables(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;

            // 常量示例（π）
            g.append("circle")
                .attr("cx", width * 0.25)
                .attr("cy", height * 0.5)
                .attr("r", 10)
                .attr("fill", "var(--danger-color)");
            
            g.append("text")
                .attr("x", width * 0.25)
                .attr("y", height * 0.5 + 40)
                .text("常量 π")
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em");

            // 变量示例（动态移动的点）
            g.append("line")
                .attr("x1", width * 0.6)
                .attr("y1", height * 0.5)
                .attr("x2", width * 0.9)
                .attr("y2", height * 0.5)
                .attr("stroke", "#ccc")
                .attr("stroke-width", 2);
            
            const variablePoint = g.append("circle")
                .attr("cy", height * 0.5)
                .attr("r", 10)
                .attr("fill", "var(--primary-color)");
            
            g.append("text")
                .attr("x", width * 0.75)
                .attr("y", height * 0.5 + 40)
                .text("变量 x")
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em");

            const leftX = width * 0.6;
            const rightX = width * 0.9;
            let movingRight = true;
            let currentTransition = null;
            let isAnimating = false;
            let paused = animationState.isPaused;
            let speed = animationState.speed || 1;
            let active = true;

            function cancelTransition() {
                if (currentTransition) {
                    variablePoint.interrupt();
                    currentTransition = null;
                }
                isAnimating = false;
            }

            function runTransition() {
                if (!active || paused || isAnimating) return;
                isAnimating = true;
                const targetX = movingRight ? rightX : leftX;
                currentTransition = variablePoint.transition()
                    .duration(2000 / speed)
                    .attr("cx", targetX)
                    .on("end", () => {
                        if (!active) return;
                        currentTransition = null;
                        isAnimating = false;
                        movingRight = !movingRight;
                        runTransition();
                    });
            }

            runTransition();

            return {
                pause() {
                    if (paused) return;
                    paused = true;
                    cancelTransition();
                },
                resume() {
                    if (!active || !paused) return;
                    paused = false;
                    runTransition();
                },
                setSpeed(newSpeed) {
                    speed = newSpeed || 1;
                    if (!paused && active) {
                        cancelTransition();
                        runTransition();
                    }
                },
                interrupt() {
                    active = false;
                    cancelTransition();
                    g.selectAll("*").interrupt();
                }
            };
        }

        // 幻灯片4：区间可视化
        function visualizeIntervals(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            
            const axisY = height * 0.2;

            // 闭区间
            g.append("line").attr("x1", 0).attr("y1", axisY).attr("x2", width).attr("y2", axisY).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY).attr("x2", width*0.4).attr("y2", axisY).attr("stroke", "var(--success-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY).attr("r", 5).attr("fill", "var(--success-color)");
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY).attr("r", 5).attr("fill", "var(--success-color)");
            g.append("text").attr("x", width*0.25).attr("y", axisY + 40).text("闭区间 [a, b]").attr("text-anchor", "middle");

            // 开区间
            const axisY2 = height * 0.5;
            g.append("line").attr("x1", 0).attr("y1", axisY2).attr("x2", width).attr("y2", axisY2).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY2).attr("x2", width*0.4).attr("y2", axisY2).attr("stroke", "var(--warning-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY2).attr("r", 5).attr("fill", "white").attr("stroke", "var(--warning-color)").attr("stroke-width", 2);
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY2).attr("r", 5).attr("fill", "white").attr("stroke", "var(--warning-color)").attr("stroke-width", 2);
            g.append("text").attr("x", width*0.25).attr("y", axisY2 + 40).text("开区间 (a, b)").attr("text-anchor", "middle");

            // 半开区间
            const axisY3 = height * 0.8;
            g.append("line").attr("x1", 0).attr("y1", axisY3).attr("x2", width).attr("y2", axisY3).attr("stroke", "black");
            g.append("line").attr("x1", width*0.1).attr("y1", axisY3).attr("x2", width*0.4).attr("y2", axisY3).attr("stroke", "var(--info-color)").attr("stroke-width", 5);
            g.append("circle").attr("cx", width*0.1).attr("cy", axisY3).attr("r", 5).attr("fill", "var(--info-color)");
            g.append("circle").attr("cx", width*0.4).attr("cy", axisY3).attr("r", 5).attr("fill", "white").attr("stroke", "var(--info-color)").attr("stroke-width", 2);
            g.append("text").attr("x", width*0.25).attr("y", axisY3 + 40).text("半开区间 [a, b)").attr("text-anchor", "middle");
        }

        // 幻灯片5：函数机器可视化
        function visualizeFunctionMachine(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);

            // 函数机器
            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };
            
            svg.append("rect")
                .attr("x", machine.x - machine.width / 2)
                .attr("y", machine.y - machine.height / 2)
                .attr("width", machine.width)
                .attr("height", machine.height)
                .attr("rx", 10)
                .attr("fill", "#4a90e2")
                .attr("stroke", "#357ABD")
                .attr("stroke-width", 3);

            svg.append("text")
                .text("f(x) = 2x + 1")
                .attr("x", machine.x)
                .attr("y", machine.y)
                .attr("text-anchor", "middle")
                .attr("dy", ".3em")
                .attr("fill", "white")
                .style("font-size", "18px")
                .style("font-weight", "bold");

            // 输入漏斗
            svg.append("path")
                .attr("d", `M ${machine.x - 50} ${machine.y - machine.height/2 - 50} 
                           L ${machine.x - 25} ${machine.y - machine.height/2} 
                           H ${machine.x + 25} 
                           L ${machine.x + 50} ${machine.y - machine.height/2 - 50} Z`)
                .attr("fill", "#a2cffe");

            // 输出管道
            svg.append("rect")
                .attr("x", machine.x - 25)
                .attr("y", machine.y + machine.height/2)
                .attr("width", 50)
                .attr("height", 30)
                .attr("fill", "#a2cffe");

            const timeouts = new Set();
            let paused = animationState.isPaused;
            let speed = animationState.speed || 1;
            let active = true;

            function clearTimers() {
                timeouts.forEach(id => clearTimeout(id));
                timeouts.clear();
            }

            function scheduleTask(fn, baseDelay) {
                const id = setTimeout(() => {
                    timeouts.delete(id);
                    if (!active || paused) return;
                    fn();
                }, baseDelay / speed);
                timeouts.add(id);
            }

            function animateNumber() {
                if (!active || paused) return;

                const input = Math.floor(Math.random() * 10) - 5;
                const output = 2 * input + 1;

                const inputText = svg.append("text")
                    .text(input)
                    .attr("x", machine.x)
                    .attr("y", machine.y - machine.height/2 - 60)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#333")
                    .style("font-size", "20px")
                    .style("font-weight", "bold");

                const moveDuration = 1000 / speed;
                const fadeInDuration = 500 / speed;
                const holdDuration = 1500 / speed;
                const fadeOutDuration = 500 / speed;

                inputText.transition()
                    .duration(moveDuration)
                    .attr("y", machine.y)
                    .style("opacity", 0)
                    .remove();

                scheduleTask(() => {
                    const outputText = svg.append("text")
                        .text(output)
                        .attr("x", machine.x)
                        .attr("y", machine.y + machine.height/2 + 30)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#2ecc71")
                        .style("font-size", "20px")
                        .style("font-weight", "bold")
                        .style("opacity", 0);

                    outputText.transition()
                        .duration(fadeInDuration)
                        .style("opacity", 1)
                        .transition()
                        .delay(holdDuration)
                        .duration(fadeOutDuration)
                        .style("opacity", 0)
                        .remove();
                }, moveDuration);

                scheduleTask(animateNumber, 3000);
            }

            animateNumber();

            return {
                pause() {
                    if (paused) return;
                    paused = true;
                    clearTimers();
                    svg.selectAll("*").interrupt();
                },
                resume() {
                    if (!active || !paused) return;
                    paused = false;
                    animateNumber();
                },
                setSpeed(newSpeed) {
                    speed = newSpeed || 1;
                    if (!paused && active) {
                        clearTimers();
                        svg.selectAll("*").interrupt();
                        animateNumber();
                    }
                },
                interrupt() {
                    active = false;
                    clearTimers();
                    svg.selectAll("*").interrupt();
                }
            };
        }

        // 幻灯片6：定义域可视化
        function visualizeDomain(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            const svg = container.append("svg").attr("width", width).attr("height", height);

            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };

            // 函数机器
            svg.append("rect")
                .attr("x", machine.x - machine.width / 2)
                .attr("y", machine.y - machine.height / 2)
                .attr("width", machine.width)
                .attr("height", machine.height)
                .attr("rx", 10)
                .attr("fill", "#4a90e2")
                .attr("stroke", "#357ABD")
                .attr("stroke-width", 3);

            svg.append("text")
                .text("f(x) = √(x-2)")
                .attr("x", machine.x)
                .attr("y", machine.y)
                .attr("text-anchor", "middle")
                .attr("dy", ".3em")
                .attr("fill", "white")
                .style("font-size", "18px")
                .style("font-weight", "bold");

            // 数轴
            const numLineY = height - 50;
            const scaleX = d3.scaleLinear().domain([-2, 10]).range([50, width - 50]);
            
            svg.append("line")
                .attr("x1", scaleX.range()[0])
                .attr("y1", numLineY)
                .attr("x2", scaleX.range()[1])
                .attr("y2", numLineY)
                .attr("stroke", "#333");

            // 定义域高亮
            svg.append("rect")
                .attr("x", scaleX(2))
                .attr("y", numLineY - 10)
                .attr("width", scaleX(10) - scaleX(2))
                .attr("height", 20)
                .attr("fill", "#50e3c2")
                .attr("opacity", 0.5);

            svg.append("text")
                .text("定义域: x ≥ 2")
                .attr("x", scaleX(6))
                .attr("y", numLineY - 25)
                .attr("text-anchor", "middle")
                .style("font-weight", "bold")
                .style("fill", "#2c3e50");

            const timeouts = new Set();
            let paused = animationState.isPaused;
            let speed = animationState.speed || 1;
            let active = true;

            function clearTimers() {
                timeouts.forEach(id => clearTimeout(id));
                timeouts.clear();
            }

            function scheduleNext() {
                const id = setTimeout(() => {
                    timeouts.delete(id);
                    if (!active || paused) return;
                    generateParticle();
                }, 1500 / speed);
                timeouts.add(id);
            }

            function generateParticle() {
                if (!active || paused) return;

                const value = Math.floor(Math.random() * 12) - 1;
                const isValid = value >= 2;
                
                const particle = svg.append("g")
                    .attr("transform", `translate(${width * 0.2}, ${height * 0.2})`);

                particle.append("circle")
                    .attr("r", 15)
                    .attr("fill", isValid ? "#50e3c2" : "#e74c3c");
                
                particle.append("text")
                    .text(value)
                    .attr("text-anchor", "middle")
                    .attr("dy", ".3em")
                    .attr("fill", "white")
                    .style("font-size", "14px");

                const travelDuration = 2000 / speed;
                const exitDuration = 1000 / speed;

                particle.transition()
                    .duration(travelDuration)
                    .attr("transform", `translate(${machine.x}, ${machine.y - machine.height/2 - 20})`);

                if (isValid) {
                    particle.transition()
                        .delay(travelDuration)
                        .duration(exitDuration)
                        .attr("transform", `translate(${machine.x}, ${machine.y + machine.height/2 + 20})`)
                        .style("opacity", 0)
                        .remove();
                } else {
                    particle.transition()
                        .delay(travelDuration)
                        .duration(exitDuration)
                        .attr("transform", `translate(${machine.x + 100}, ${machine.y - machine.height - 50})`)
                        .style("opacity", 0)
                        .remove();
                }

                scheduleNext();
            }

            scheduleNext();

            return {
                pause() {
                    if (paused) return;
                    paused = true;
                    clearTimers();
                    svg.selectAll("*").interrupt();
                },
                resume() {
                    if (!active || !paused) return;
                    paused = false;
                    generateParticle();
                },
                setSpeed(newSpeed) {
                    speed = newSpeed || 1;
                    if (!paused && active) {
                        clearTimers();
                        svg.selectAll("*").interrupt();
                        generateParticle();
                    }
                },
                interrupt() {
                    active = false;
                    clearTimers();
                    svg.selectAll("*").interrupt();
                }
            };
        }

        // 幻灯片7：值域可视化
        function visualizeRange(containerId) {
            const container = d3.select(`#${containerId}`);
            container.html("");
            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            const svg = container.append("svg").attr("width", width).attr("height", height);

            const machine = { x: width / 2, y: height / 2, width: 150, height: 100 };

            svg.append("rect")
                .attr("x", machine.x - machine.width / 2)
                .attr("y", machine.y - machine.height / 2)
                .attr("width", machine.width)
                .attr("height", machine.height)
                .attr("rx", 10)
                .attr("fill", "#4a90e2");

            svg.append("text")
                .text("f(x) = x²")
                .attr("x", machine.x)
                .attr("y", machine.y)
                .attr("text-anchor", "middle")
                .attr("dy", ".3em")
                .attr("fill", "white")
                .style("font-size", "20px");

            // 值域轴
            const numLineX = width - 100;
            const scaleY = d3.scaleLinear().domain([-2, 10]).range([height - 50, 50]);
            
            svg.append("line")
                .attr("x1", numLineX)
                .attr("y1", scaleY.range()[0])
                .attr("x2", numLineX)
                .attr("y2", scaleY.range()[1])
                .attr("stroke", "#333");

            // 值域高亮
            svg.append("rect")
                .attr("x", numLineX - 10)
                .attr("y", scaleY(10))
                .attr("width", 20)
                .attr("height", scaleY(0) - scaleY(10))
                .attr("fill", "#f5a623")
                .attr("opacity", 0.5);

            svg.append("text")
                .text("值域: y ≥ 0")
                .attr("x", numLineX)
                .attr("y", scaleY(10) - 10)
                .attr("text-anchor", "middle")
                .style("font-weight", "bold")
                .style("fill", "#2c3e50");

            const timeouts = new Set();
            let paused = animationState.isPaused;
            let speed = animationState.speed || 1;
            let active = true;

            function clearTimers() {
                timeouts.forEach(id => clearTimeout(id));
                timeouts.clear();
            }

            function scheduleNext() {
                const id = setTimeout(() => {
                    timeouts.delete(id);
                    if (!active || paused) return;
                    generateParticle();
                }, 2000 / speed);
                timeouts.add(id);
            }

            function generateParticle() {
                if (!active || paused) return;

                const value = (Math.random() * 6) - 3;
                const outputValue = value * value;

                const particle = svg.append("g")
                    .attr("transform", `translate(${50}, ${machine.y})`);

                particle.append("circle")
                    .attr("r", 15)
                    .attr("fill", "#50e3c2");
                
                particle.append("text")
                    .text(value.toFixed(1))
                    .attr("text-anchor", "middle")
                    .attr("dy", ".3em")
                    .attr("fill", "white");

                const moveDuration = 1500 / speed;
                const fadeDuration = 500 / speed;

                particle.transition()
                    .duration(moveDuration)
                    .attr("transform", `translate(${machine.x - machine.width/2 - 20}, ${machine.y})`)
                    .transition()
                    .duration(fadeDuration)
                    .style("opacity", 0)
                    .remove()
                    .on("end", () => {
                        if (!active || paused) return;

                        const outputParticle = svg.append("g")
                            .attr("transform", `translate(${machine.x + machine.width/2 + 20}, ${machine.y})`);
                        
                        outputParticle.append("circle")
                            .attr("r", 15)
                            .attr("fill", "#f5a623");
                        
                        outputParticle.append("text")
                            .text(outputValue.toFixed(1))
                            .attr("text-anchor", "middle")
                            .attr("dy", ".3em")
                            .attr("fill", "white");

                        outputParticle.transition()
                            .duration(moveDuration)
                            .attr("transform", `translate(${numLineX}, ${scaleY(outputValue)})`);

                        outputParticle.select("circle")
                            .transition()
                            .delay(moveDuration)
                            .duration(fadeDuration)
                            .attr("r", 5);

                        outputParticle.transition()
                            .delay(moveDuration)
                            .duration(fadeDuration)
                            .style("opacity", 0.7);
                    });

                scheduleNext();
            }

            scheduleNext();

            return {
                pause() {
                    if (paused) return;
                    paused = true;
                    clearTimers();
                    svg.selectAll("*").interrupt();
                },
                resume() {
                    if (!active || !paused) return;
                    paused = false;
                    generateParticle();
                },
                setSpeed(newSpeed) {
                    speed = newSpeed || 1;
                    if (!paused && active) {
                        clearTimers();
                        svg.selectAll("*").interrupt();
                        generateParticle();
                    }
                },
                interrupt() {
                    active = false;
                    clearTimers();
                    svg.selectAll("*").interrupt();
                }
            };
        }

        // 幻灯片8：基本初等函数星系可视化
        function visualizeElementaryIntro(containerId) {
            const setup = setupD3(containerId, { top: 0, right: 0, bottom: 0, left: 0 });
            if (!setup) return;
            const { container, svg, g, width, height } = setup;

            // 简洁白底风格
            svg.style('background', '#ffffff');

            const centerX = width / 2;
            const centerY = height / 2;

            // 创建星空背景
            function createStarField() {
                const starCount = 50;
                const stars = [];

                for (let i = 0; i < starCount; i++) {
                    stars.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        radius: Math.random() * 1.5 + 0.5,
                        opacity: Math.random() * 0.6 + 0.4
                    });
                }

                const starGroup = g.append('g').attr('class', 'star-field');
                starGroup.selectAll('.star')
                    .data(stars)
                    .enter()
                    .append('circle')
                    .attr('class', 'star')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', d => d.radius)
                    .attr('fill', 'white')
                    .attr('opacity', d => d.opacity);
            }

            // 可选：弱化星空或移除，此处移除保留清爽

            // 添加标题
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 60)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .style('font-size', '48px')
                .style('font-weight', 'bold')
                .text('基本初等函数星系');

            // 定义行星数据
            const planetsData = [
                { name: "幂函数", color: "#e74c3c", radius: 22, orbitRadius: 100, speed: 0.002 },
                { name: "指数函数", color: "#3498db", radius: 25, orbitRadius: 160, speed: 0.0015 },
                { name: "对数函数", color: "#2ecc71", radius: 25, orbitRadius: 220, speed: 0.0012 },
                { name: "三角函数", color: "#f1c40f", radius: 28, orbitRadius: 280, speed: 0.001 },
                { name: "反三角函数", color: "#9b59b6", radius: 20, orbitRadius: 340, speed: 0.0008 },
                { name: "常数函数", color: "#bdc3c7", radius: 18, orbitRadius: 60, speed: 0.0025 }
            ];

            // 绘制轨道
            g.selectAll(".orbit")
                .data(planetsData)
                .enter().append("circle")
                .attr("class", "orbit")
                .attr("cx", centerX)
                .attr("cy", centerY)
                .attr("r", d => d.orbitRadius)
                .attr("fill", "none")
                .attr("stroke", "rgba(255, 255, 255, 0.3)")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "5, 5");

            // 绘制中央太阳
            const sun = g.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);

            sun.append("circle")
                .attr("r", 45)
                .attr("fill", "#f1c40f");

            sun.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.35em")
                .attr("fill", "#333")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .text("初等函数");

            // 创建行星
            const planets = g.selectAll(".planet")
                .data(planetsData)
                .enter().append("g")
                .attr("class", "planet");

            planets.append("circle")
                .attr("r", d => d.radius)
                .attr("fill", d => d.color)
                .attr("stroke", d => d.color)
                .attr("stroke-width", 1)
                .attr("stroke-opacity", 0.5);

            planets.append("text")
                .attr("dy", d => d.radius + 15)
                .attr("text-anchor", "middle")
                .attr("fill", "#fff")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .text(d => d.name);

            // 行星运行动画
            let angle = 0;
            let frameId = null;
            let lastTimestamp = null;
            let paused = animationState.isPaused;
            let speed = animationState.speed || 1;
            let active = true;
            const baseAngularVelocity = 0.6; // radian per second baseline

            function step(timestamp) {
                if (!active) return;

                if (paused) {
                    lastTimestamp = timestamp;
                    frameId = requestAnimationFrame(step);
                    return;
                }

                if (lastTimestamp === null) {
                    lastTimestamp = timestamp;
                }

                const deltaSeconds = (timestamp - lastTimestamp) / 1000;
                lastTimestamp = timestamp;
                angle += deltaSeconds * baseAngularVelocity * speed;

                planets.attr("transform", d => {
                    const planetAngle = angle * d.speed;
                    const x = centerX + d.orbitRadius * Math.cos(planetAngle);
                    const y = centerY + d.orbitRadius * Math.sin(planetAngle);
                    return `translate(${x}, ${y})`;
                });

                frameId = requestAnimationFrame(step);
            }

            if (!paused) {
                frameId = requestAnimationFrame(step);
            }

            return {
                pause() {
                    if (paused) return;
                    paused = true;
                    if (frameId !== null) {
                        cancelAnimationFrame(frameId);
                        frameId = null;
                    }
                },
                resume() {
                    if (!active || !paused) return;
                    paused = false;
                    lastTimestamp = null;
                    frameId = requestAnimationFrame(step);
                },
                setSpeed(newSpeed) {
                    speed = newSpeed || 1;
                },
                interrupt() {
                    active = false;
                    if (frameId !== null) {
                        cancelAnimationFrame(frameId);
                        frameId = null;
                    }
                }
            };
        }

        // 幻灯片10：指数定义可视化
        function visualizeExponents(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { g, width, height } = setup;
            
            const data = [
                { x: 0, y: 1, label: "2^0" },
                { x: 1, y: 2, label: "2^1" },
                { x: 2, y: 4, label: "2^2" },
                { x: 3, y: 8, label: "2^3" }
            ];
            
            const xScale = d3.scaleLinear().domain([-1, 4]).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);
            
            // 绘制柱状图
            g.selectAll("rect")
                .data(data)
                .enter().append("rect")
                .attr("x", d => xScale(d.x) - width/10)
                .attr("y", height)
                .attr("width", width/5)
                .attr("height", 0)
                .attr("fill", "var(--primary-color)")
                .transition().duration(1000).delay((d, i) => i * 300)
                .attr("y", d => yScale(d.y))
                .attr("height", d => height - yScale(d.y));
            
            // 添加标签
            g.selectAll(".label")
                .data(data)
                .enter().append("text")
                .attr("class", "label")
                .attr("x", d => xScale(d.x))
                .attr("y", d => yScale(d.y) - 10)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.2em")
                .attr("fill", "var(--text-color)")
                .style("opacity", 0)
                .text(d => d.y)
                .transition().duration(500).delay((d, i) => 1000 + i * 300)
                .style("opacity", 1);
        }

        // 幻灯片11：指数运算法则1可视化
        function visualizeExponentRules1(containerId) {
            const setup = setupD3(containerId);
            if (!setup) return;
            const { svg, g, width, height } = setup;

            const mulY = height * 0.25;
            
            // 乘法法则动画
            const mulGroup = g.append("g");
            const mulText = mulGroup.append("text")
                .attr("x", width / 2)
                .attr("y", mulY - 30)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.8em")
                .attr("fill", "var(--text-color)");
            
            mulText.append("tspan").text("2³ × 2² = 2⁵");

            // 动画圆圈
            const circles1 = g.selectAll(".c1")
                .data(d3.range(3))
                .enter().append("circle")
                .attr("class", "c1")
                .attr("cy", mulY)
                .attr("cx", (d, i) => width * 0.2 + i * 40)
                .attr("r", 15)
                .attr("fill", "var(--primary-color)");
            
            const circles2 = g.selectAll(".c2")
                .data(d3.range(2))
                .enter().append("circle")
                .attr("class", "c2")
                .attr("cy", mulY)
                .attr("cx", (d, i) => width * 0.8 - i * 40)
                .attr("r", 15)
                .attr("fill", "var(--accent-color)");
            
            // 合并动画
            circles1.transition().delay(1000).duration(1500)
                .attr("cx", (d, i) => width/2 - 100 + i * 40);
            
            circles2.transition().delay(1000).duration(1500)
                .attr("cx", (d, i) => width/2 + 20 + i * 40);

            // 除法法则
            const divY = height * 0.75;
            g.append("line")
                .attr("x1", 0).attr("y1", height/2)
                .attr("x2", width).attr("y2", height/2)
                .attr("stroke", "#ddd").attr("stroke-width", 2);
            
            const divText = g.append("text")
                .attr("x", width / 2)
                .attr("y", divY - 50)
                .attr("text-anchor", "middle")
                .attr("font-size", "1.8em")
                .attr("fill", "var(--text-color)")
                .text("5⁴ ÷ 5² = 5²");
        }

        // 幻灯片12：指数运算法则2可视化
        function visualizeExponentRules2(containerId) {
            const setup = setupD3(containerId, {top: 0, right: 0, bottom: 0, left: 0});
            if (!setup) return;
            const { svg, g, width, height } = setup;

            svg.style("background", "transparent");

            // 标题
            g.append("text")
                .attr("x", width/2)
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .attr("font-size", "2em")
                .attr("font-weight", "300")
                .attr("fill", "#2d3436")
                .text("(2³)⁴ = ?");

            // 大圆圈动画
            setTimeout(() => {
                const bigCircle = g.append("circle")
                    .attr("cx", width/2)
                    .attr("cy", height/2)
                    .attr("r", 0)
                    .attr("fill", "#74b9ff")
                    .attr("stroke", "#0984e3")
                    .attr("stroke-width", 3)
                    .style("opacity", 0.8);

                bigCircle.transition()
                    .duration(1000)
                    .attr("r", 60);

                g.append("text")
                    .attr("x", width/2)
                    .attr("y", height/2 + 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "1.8em")
                    .attr("font-weight", "bold")
                    .attr("fill", "white")
                    .text("2³")
                    .style("opacity", 0)
                    .transition()
                    .delay(800)
                    .duration(600)
                    .style("opacity", 1);
            }, 1000);

            // 分散成4个小圆
            setTimeout(() => {
                const positions = [
                    {x: width/2, y: height/2 - 120},
                    {x: width/2 + 120, y: height/2},
                    {x: width/2, y: height/2 + 120},
                    {x: width/2 - 120, y: height/2}
                ];

                positions.forEach((pos, i) => {
                    const bubble = g.append("circle")
                        .attr("cx", width/2)
                        .attr("cy", height/2)
                        .attr("r", 15)
                        .attr("fill", "#74b9ff")
                        .attr("stroke", "#0984e3")
                        .attr("stroke-width", 2)
                        .style("opacity", 0);

                    bubble.transition()
                        .delay(500 + i * 150)
                        .duration(100)
                        .style("opacity", 0.8)
                        .transition()
                        .duration(800)
                        .attr("cx", pos.x)
                        .attr("cy", pos.y)
                        .attr("r", 35);

                    g.append("text")
                        .attr("x", width/2)
                        .attr("y", height/2)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "1.2em")
                        .attr("font-weight", "bold")
                        .attr("fill", "white")
                        .text("2³")
                        .style("opacity", 0)
                        .transition()
                        .delay(600 + i * 150)
                        .duration(800)
                        .attr("x", pos.x)
                        .attr("y", pos.y + 5)
                        .style("opacity", 1);
                });
            }, 3000);

            // 最终结果
            setTimeout(() => {
                g.append("text")
                    .attr("x", width/2)
                    .attr("y", height - 50)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "2.2em")
                    .attr("font-weight", "bold")
                    .attr("fill", "#e74c3c")
                    .text("(2³)⁴ = 2¹² = 4096")
                    .style("opacity", 0)
                    .transition()
                    .duration(800)
                    .style("opacity", 1);
            }, 6000);
        }

        // 幻灯片13：零指数与负指数可视化  
// 幻灯片13（第14页）：零指数与负指数可视化 - 增强版
function visualizeSpecialExponentsNew(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

        const sectionHeight = height / 2;
        const sectionWidth = width;

        // --- Section 1: Zero Exponent ---
    const zeroGroup = g.append("g");
        const scaleGroup = zeroGroup.append("g")
            .attr("transform", `translate(${sectionWidth / 2}, ${sectionHeight * 0.6})`);

        scaleGroup.append("polygon").attr("points", "-10,0 10,0 0,15").attr("fill", "#555");
        const beam = scaleGroup.append("line").attr("x1", -100).attr("x2", 100).attr("stroke", "#555").attr("stroke-width", 4);
        const leftPan = scaleGroup.append("text").attr("x", -70).attr("y", -15).attr("font-size", "1.5em").attr("text-anchor", "middle");
        const rightPan = scaleGroup.append("text").attr("x", 70).attr("y", -15).attr("font-size", "1.5em").attr("text-anchor", "middle");

        // 零指数动画 - 立即开始
        leftPan.append("tspan").text("a³").style("opacity", 0).transition().delay(0).duration(500).style("opacity", 1);
        rightPan.append("tspan").text("a³").style("opacity", 0).transition().delay(0).duration(500).style("opacity", 1);

        setTimeout(() => {
            leftPan.html("a³ ÷ a³");
            rightPan.html("a³ ÷ a³");
        }, 800);

        setTimeout(() => {
            beam.transition().duration(500).attr("transform", "rotate(5)").transition().duration(500).attr("transform", "rotate(-5)").transition().duration(500).attr("transform", "rotate(0)");
            leftPan.html("a⁰").attr("font-size", "1.5em").attr("fill", "var(--danger-color)");
            rightPan.html("1").attr("font-size", "1.5em").attr("fill", "var(--success-color)");
        }, 1500);

        // --- Section 2: Negative Exponent ---
        g.append("line").attr("x1", 0).attr("y1", sectionHeight).attr("x2", width).attr("y2", sectionHeight).attr("stroke", "#ddd");
        const negGroup2 = g.append("g").attr("transform", `translate(0, ${sectionHeight})`);
        // 负指数动画 - 1秒后开始
        const negTitle = negGroup2.append("text").attr("x", sectionWidth/2).attr("y", sectionHeight * 0.2).attr("text-anchor", "middle").attr("font-size", "1.5em").text("a² ÷ a⁵ = ?").style("opacity", 0).transition().delay(1000).duration(500).style("opacity", 1);

const fraction = negGroup2.append("g").attr("transform", `translate(${sectionWidth/2}, ${sectionHeight * 0.6})`).style("opacity", 0);
const numerator = fraction.selectAll(".num").data("aa".split("")).enter().append("text").attr("class", "num").text("a").attr("x", (d,i) => -25 + i * 25).attr("y", -15).attr("font-size", "1.5em");

const denominator = fraction.selectAll(".den").data("aaaaa".split("")).enter().append("text").attr("class", "den").text("a").attr("x", (d,i) => -60 + i * 25).attr("y", 25).attr("font-size", "1.5em");


    // === 负指数部分 ===
    const negGroup = g.append("g")
        .attr("transform", `translate(0, ${height/2 + 30})`);

    // 标题
    const negTitleFO = negGroup.append("foreignObject")
        .attr("x", 0)
        .attr("y", 200)
        .attr("width", width)
        .attr("height", 60)
        .html(`<div style="text-align: center; font-size: 24px; font-weight: bold; color: #e74c3c;">
            负指数定律：$a^{-n} = \\frac{1}{a^n}$
        </div>`);

    // 创建交互式示例
    const exampleY = 80;
    const examples = [
        { base: 2, exp: -1, value: 1/2 },
        { base: 2, exp: -2, value: 1/4 },
        { base: 2, exp: -3, value: 1/8 }
    ];

    examples.forEach((ex, i) => {
        const exGroup = negGroup.append("g")
            .attr("transform", `translate(${width * (0.25 + i * 0.25)}, ${exampleY})`);

        // 背景圆
        exGroup.append("circle")
            .attr("r", 45)
            .attr("fill", "#e74c3c")
            .attr("fill-opacity", 0.1)
            .attr("stroke", "#e74c3c")
            .attr("stroke-width", 2)
            .style("opacity", 0)
            .transition()
            .delay(5000 + i * 300)
            .duration(600)
            .style("opacity", 1);

        // 公式
        const formulaFO = exGroup.append("foreignObject")
            .attr("x", -40)
            .attr("y", -20)
            .attr("width", 80)
            .attr("height", 40)
            .html(`<div style="text-align: center; font-size: 18px; color: #c0392b;">
                $2^{${ex.exp}}$
            </div>`)
            .style("opacity", 0);

        formulaFO.transition()
            .delay(5300 + i * 300)
            .duration(600)
            .style("opacity", 1);

        // 可视化分数饼图
        const pieRadius = 25;
        const pieY = 60;

    const arc = d3.arc()
        .innerRadius(0)
            .outerRadius(pieRadius);

        const denominator = Math.pow(2, -ex.exp);
        const pieData = d3.pie()(Array(denominator).fill(1));
        
        const pieGroup = exGroup.append("g")
            .attr("transform", `translate(0, ${pieY})`);
    
    pieGroup.selectAll("path")
        .data(pieData)
        .enter()
        .append("path")
        .attr("d", arc)
            .attr("fill", (d, j) => j === 0 ? "#e74c3c" : "#fce4ec")
        .attr("stroke", "#fff")
            .attr("stroke-width", 1)
        .style("opacity", 0)
        .transition()
            .delay(5600 + i * 300)
            .duration(600)
        .style("opacity", 1);

        // 数值标签
        const valueFO = exGroup.append("foreignObject")
            .attr("x", -40)
            .attr("y", pieY + pieRadius + 10)
            .attr("width", 180)
            .attr("height", 30)
            .html(`<div style="text-align: center; font-size: 14px; color: #7f8c8d;">
                $= \\frac{1}{${denominator}} = ${ex.value}$
            </div>`)
            .style("opacity", 0);

        valueFO.transition()
            .delay(6000 + i * 300)
        .duration(600)
        .style("opacity", 1);
    });

    // 渲染所有MathJax公式
    setTimeout(() => {
        renderMathJaxInContainer(containerId);
    }, 100);
}
 // 幻灯片14（第15页）：分数指数可视化 - 修复版
        function visualizeFractionalExponents(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    // 清除之前的内容
    g.selectAll("*").remove();

    // 标题
    const titleFO = g.append("foreignObject")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", 50)
        .html(`<div style="text-align: center; font-size: 28px; font-weight: bold; color: #2c3e50; padding-top: 10px;">
            分数指数的意义：$a^{\\frac{m}{n}} = \\sqrt[n]{a^m}$
        </div>`);

    // 创建三个交互式示例
    const examples = [
        { base: 27, numerator: 1, denominator: 3, result: 3, color: "#e74c3c" },
        { base: 16, numerator: 1, denominator: 2, result: 4, color: "#3498db" },
        { base: 8, numerator: 2, denominator: 3, result: 4, color: "#2ecc71" }
    ];

    const cardSpacing = width / 3;

    examples.forEach((ex, i) => {
        const cardGroup = g.append("g")
            .attr("transform", `translate(${cardSpacing * (i + 0.5)}, ${height * 0.5})`);

        // 主圆形背景
        const mainCircle = cardGroup.append("circle")
            .attr("r", 0)
            .attr("fill", ex.color)
            .attr("fill-opacity", 0.15)
            .attr("stroke", ex.color)
            .attr("stroke-width", 3)
            .transition()
            .delay(500 + i * 300)
            .duration(800)
            .attr("r", 80);

        // 步骤1：原始表达式
        const step1FO = cardGroup.append("foreignObject")
            .attr("x", -60)
            .attr("y", -120)
            .attr("width", 120)
            .attr("height", 40)
            .html(`<div style="text-align: center; font-size: 20px; color: ${ex.color}; font-weight: bold;">
                ${ex.base}^{\\frac{${ex.numerator}}{${ex.denominator}}}$
            </div>`)
            .style("opacity", 0);

        step1FO.transition()
            .delay(800 + i * 300)
            .duration(600)
            .style("opacity", 1);

        // 步骤2：根式表示
        const step2FO = cardGroup.append("foreignObject")
            .attr("x", -60)
            .attr("y", -30)
            .attr("width", 120)
            .attr("height", 40)
            .html(`<div style="text-align: center; font-size: 20px; color: #2c3e50;">
                $\\sqrt[${ex.denominator}]{${ex.base}^{${ex.numerator}}}$
            </div>`)
            .style("opacity", 0);

        step2FO.transition()
            .delay(2000 + i * 300)
            .duration(600)
            .style("opacity", 1);

        // 步骤3：结果
        const resultGroup = cardGroup.append("g")
            .attr("transform", "translate(0, 80)");

        const resultCircle = resultGroup.append("circle")
            .attr("r", 0)
            .attr("fill", ex.color)
            .attr("stroke", "#fff")
            .attr("stroke-width", 3);

        resultCircle.transition()
            .delay(3200 + i * 300)
            .duration(600)
            .attr("r", 35);

        const resultText = resultGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.3em")
            .style("font-size", "28px")
            .style("font-weight", "bold")
            .style("fill", "white")
            .text(ex.result)
            .style("opacity", 0);

        resultText.transition()
            .delay(3500 + i * 300)
            .duration(400)
            .style("opacity", 1);

        // 脉动动画
        function pulse() {
            resultCircle.transition()
                .duration(1500)
                .attr("r", 40)
                .transition()
                .duration(1500)
                .attr("r", 35)
                .on("end", pulse);
        }
        setTimeout(() => pulse(), 4000 + i * 300);
    });

    // 底部总结
    const summaryFO = g.append("foreignObject")
        .attr("x", 50)
        .attr("y", height - 60)
        .attr("width", width - 100)
        .attr("height", 50)
        .html(`<div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.9); border-radius: 10px; border: 2px solid #95a5a6;">
            <span style="font-size: 16px; color: #2c3e50;">
                <strong>记忆技巧：</strong> 分数指数中，<span style="color: #e74c3c;">分母是根次</span>，<span style="color: #3498db;">分子是幂次</span>
            </span>
        </div>`)
        .style("opacity", 0);

    summaryFO.transition()
        .delay(5000)
        .duration(800)
        .style("opacity", 1);

    // 渲染MathJax
    setTimeout(() => {
        renderMathJaxInContainer(containerId);
    }, 100);
}


        // 幻灯片16：对数历史可视化 - 增强版
        function visualizeLogHistory(containerId) {
            const setup = setupD3(containerId, { top: 0, right: 0, bottom: 0, left: 0 });
            if (!setup) return;
            const { svg, g, width, height } = setup;

            // 改为白底深色文本
            svg.style('background', '#ffffff');

            // 移除星空效果，保持信息聚焦

            // 添加流星效果
            function createMeteor() {
                const meteor = g.append("circle")
                    .attr("r", 0)
                    .attr("fill", "white")
                    .attr("opacity", 0);
                
                meteor.transition()
                    .duration(0)
                    .attr("cx", Math.random() * width)
                    .attr("cy", Math.random() * height * 0.3)
                    .attr("r", 3)
                    .attr("opacity", 1)
                    .transition()
                    .duration(2000)
                    .attr("cx", Math.random() * width)
                    .attr("cy", height + 50)
                    .attr("opacity", 0)
                    .remove();
            }

            // 定期创建流星
            setInterval(createMeteor, 3000);

            // 标题带发光效果
            const title = g.append("text")
                .attr("x", width/2)
                .attr("y", 80)
                .attr("text-anchor", "middle")
                .style("font-size", "36px")
                .style("font-weight", "bold")
                .style("fill", "#1f2937")
                .text("对数的历史长河")
                .style("opacity", 0)
                .transition()
                .duration(800)
                .style("opacity", 1);

            // 流动的时间线
            g.append("line")
                .attr("x1", width * 0.1)
                .attr("y1", height/2)
                .attr("x2", width * 0.9)
                .attr("y2", height/2)
                .attr("stroke", "#334155")
                .attr("stroke-width", 3)
                .style("opacity", 0);

            // 移除彩色渐变，保持简洁

            g.select("line").transition()
                .delay(800)
                .duration(2000)
                .style("opacity", 0.8);

            // 历史事件（更丰富的信息）
            const events = [
                { 
                    year: 1614, 
                    title: "对数诞生", 
                    desc: "纳皮尔发明对数", 
                    detail: "《奇妙对数表》出版",
                    x: 0.15, 
                    icon: "📜", 
                    color: "#e74c3c",
                    impact: "革命性突破"
                },
                { 
                    year: 1617, 
                    title: "对数表", 
                    desc: "布里格斯制作常用对数表", 
                    detail: "以10为底的对数",
                    x: 0.3, 
                    icon: "📊", 
                    color: "#3498db",
                    impact: "实用化"
                },
                { 
                    year: 1620, 
                    title: "航海应用", 
                    desc: "对数简化航海计算", 
                    detail: "天文导航革命",
                    x: 0.45, 
                    icon: "⚓", 
                    color: "#2ecc71",
                    impact: "航海时代"
                },
                { 
                    year: 1622, 
                    title: "计算尺", 
                    desc: "滑尺计算器发明", 
                    detail: "机械计算工具",
                    x: 0.6, 
                    icon: "📏", 
                    color: "#f39c12",
                    impact: "计算工具"
                },
                { 
                    year: 1970, 
                    title: "计算器时代", 
                    desc: "电子计算器普及", 
                    detail: "对数功能内置",
                    x: 0.75, 
                    icon: "🖩", 
                    color: "#9b59b6",
                    impact: "数字化"
                },
                { 
                    year: 2024, 
                    title: "AI时代", 
                    desc: "对数在机器学习中的应用", 
                    detail: "深度学习基础",
                    x: 0.9, 
                    icon: "🤖", 
                    color: "#1abc9c",
                    impact: "智能时代"
                }
            ];

            events.forEach((event, i) => {
                const eventGroup = g.append("g")
                    .attr("transform", `translate(${width * event.x}, ${height/2})`)
                    .attr("class", "event-group");

                // 时间点（带脉冲效果）
                const timePoint = eventGroup.append("circle")
                    .attr("r", 0)
                    .attr("fill", "#0ea5e9")
                    .attr("stroke", "#ffffff")
                    .attr("stroke-width", 3)
                    .style("filter", `drop-shadow(0 0 10px ${event.color})`);

                timePoint.transition()
                    .delay(1500 + i * 300)
                    .duration(800)
                    .attr("r", 15)
                    .transition()
                    .duration(1000)
                    .attr("r", 12);

                // 脉冲环效果
                const pulseRing = eventGroup.append("circle")
                    .attr("r", 0)
                    .attr("fill", "none")
                    .attr("stroke", "#93c5fd")
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.6);

                pulseRing.transition()
                    .delay(2000 + i * 300)
                    .duration(1500)
                    .attr("r", 25)
                    .attr("opacity", 0)
                    .transition()
                    .duration(0)
                    .attr("r", 0)
                    .attr("opacity", 0.6)
                    .on("end", function repeat() {
                        d3.select(this)
                            .transition()
                            .duration(2000)
                            .attr("r", 25)
                            .attr("opacity", 0)
                            .transition()
                            .duration(0)
                            .attr("r", 0)
                            .attr("opacity", 0.6)
                            .on("end", repeat);
                    });

                // 事件卡片（带悬停效果）
                const card = eventGroup.append("g")
                    .attr("transform", `translate(0, ${i % 2 === 0 ? -120 : 120})`)
                    .attr("class", "event-card")
                    .style("cursor", "pointer");

                const cardRect = card.append("rect")
                    .attr("x", -75)
                    .attr("y", -45)
                    .attr("width", 150)
                    .attr("height", 90)
                    .attr("rx", 15)
                    .attr("fill", "#f8fafc")
                    .attr("stroke", "#334155")
                    .attr("stroke-width", 2)
                    .style("filter", `drop-shadow(0 5px 12px rgba(0,0,0,0.15))`)
                    .style("opacity", 0);

                cardRect.transition()
                    .delay(1800 + i * 300)
                    .duration(800)
                    .style("opacity", 1);

                // 悬停效果
                card.on("mouseover", function() {
                    d3.select(this).select("rect")
                        .transition()
                        .duration(200)
                        .attr("fill-opacity", 1)
                        .attr("transform", "scale(1.05)");
                }).on("mouseout", function() {
                    d3.select(this).select("rect")
                        .transition()
                        .duration(200)
                        .attr("fill-opacity", 0.9)
                        .attr("transform", "scale(1)");
                });

                // 图标
                card.append("text")
                    .attr("y", -15)
                    .attr("text-anchor", "middle")
                    .style("font-size", "28px")
                    .text(event.icon)
                    .style("opacity", 0)
                    .transition()
                    .delay(2000 + i * 300)
                    .duration(500)
                    .style("opacity", 1);

                // 年份
                card.append("text")
                    .attr("y", 5)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("font-weight", "bold")
                    .style("fill", "#0f172a")
                    .text(event.year)
                    .style("opacity", 0)
                    .transition()
                    .delay(2100 + i * 300)
                    .duration(500)
                    .style("opacity", 1);

                // 描述
                card.append("text")
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("fill", "#1f2937")
                    .text(event.desc)
                    .style("opacity", 0)
                    .transition()
                    .delay(2200 + i * 300)
                    .duration(500)
                    .style("opacity", 1);

                // 连接线（带流动效果）
                const connection = eventGroup.append("line")
                    .attr("x1", 0)
                    .attr("y1", 0)
                    .attr("x2", 0)
                    .attr("y2", 0)
                    .attr("stroke", event.color)
                    .attr("stroke-width", 3)
                    .attr("stroke-dasharray", "5, 5")
                    .style("opacity", 0);

                connection.transition()
                    .delay(1700 + i * 300)
                    .duration(800)
                    .attr("y2", i % 2 === 0 ? -85 : 85)
                    .style("opacity", 0.8);

                // 流动动画
                connection.transition()
                    .delay(2500 + i * 300)
                    .duration(2000)
                    .attr("stroke-dashoffset", -20)
                    .transition()
                    .duration(2000)
                    .attr("stroke-dashoffset", 0)
                    .on("end", function repeat() {
                        d3.select(this)
                            .transition()
                            .duration(2000)
                            .attr("stroke-dashoffset", -20)
                            .transition()
                            .duration(2000)
                            .attr("stroke-dashoffset", 0)
                            .on("end", repeat);
                    });
            });

            // 底部说明（带打字机效果）
            const bottomText = g.append("text")
                .attr("x", width/2)
                .attr("y", height - 30)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("fill", "#ecf0f1")
                .style("text-shadow", "0 0 10px #ecf0f1")
                .style("opacity", 0);

            const textContent = "对数：将复杂的乘除运算转化为简单的加减运算，推动人类计算历史的革命";
            let currentText = "";
            let index = 0;

            bottomText.transition()
                .delay(5000)
                .duration(500)
                .style("opacity", 1)
                .on("end", function typeWriter() {
                    if (index < textContent.length) {
                        currentText += textContent[index];
                        bottomText.text(currentText);
                        index++;
                        setTimeout(typeWriter, 80);
                    }
                });

            // 添加交互式时间轴控制
            const controls = g.append("g")
                .attr("transform", `translate(${width/2}, ${height - 80})`)
                .style("opacity", 0);

            controls.transition()
                .delay(8000)
                .duration(1000)
                .style("opacity", 1);

            // 播放/暂停按钮
            controls.append("circle")
                .attr("r", 20)
                .attr("fill", "#3498db")
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .style("cursor", "pointer");

            controls.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.3em")
                .style("font-size", "16px")
                .style("fill", "white")
                .text("▶");

            controls.select("circle").on("click", function() {
                // 重新播放动画
                location.reload();
            });
        }

        // 幻灯片17：对数定义可视化
        function visualizeLogDefinition(containerId) {
            const svg = d3.select("#animation2");
            if(svg.empty()) return;
            svg.selectAll("*").remove();
            
            const bounds = svg.node().getBoundingClientRect();
            const width = bounds.width, height = bounds.height;
            const centerX = width / 2;
            
            svg.append("text")
                .attr("x", centerX)
                .attr("y", 50)
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .text("求 log₂(8) = ?");
            
            svg.append("text")
                .attr("x", centerX)
                .attr("y", 80)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("也就是，2的几次方等于8？");

            // 指数过程
            const expGroup = svg.append("g");
            expGroup.append("text")
                .attr("x", 50)
                .attr("y", 150)
                .text("指数过程:")
                .style("font-size", "16px")
                .style("font-weight", "bold");

            // 绘制路径
            let pathData = "M 150 145";
            for (let i = 1; i <= 3; i++) {
                pathData += ` L ${150 + i * 100} 145`;
            }

            const expPath = expGroup.append("path")
                .attr("d", pathData)
                .attr("stroke", "#3498db")
                .attr("stroke-width", 2)
                .attr("fill", "none");

            // 路径动画
            const totalLength = expPath.node().getTotalLength();
            expPath.attr("stroke-dasharray", `${totalLength} ${totalLength}`)
                .attr("stroke-dashoffset", totalLength)
                .transition()
                .duration(2000)
                .ease(d3.easeLinear)
                .attr("stroke-dashoffset", 0);

            // 添加节点
            [1, 2, 4, 8].forEach((val, i) => {
                const node = expGroup.append("g")
                    .attr("transform", `translate(${150 + i * 100}, 145)`)
                    .style("opacity", 0);
                
                node.append("circle")
                    .attr("r", 15)
                    .attr("fill", "#3498db");
                
                node.append("text")
                    .text(val)
                    .attr("y", 40)
                    .attr("text-anchor", "middle")
                    .style("fill", "#2c3e50");
                
                node.transition()
                    .delay(1000 + i * 500)
                    .duration(500)
                    .style("opacity", 1);
            });

            // 答案
            setTimeout(() => {
                svg.append("text")
                    .attr("x", centerX)
                    .attr("y", 300)
                    .attr("text-anchor", "middle")
                    .style("font-size", "24px")
                    .style("fill", "#e74c3c")
                    .style("font-weight", "bold")
                    .text("log₂(8) = 3")
                    .style("opacity", 0)
                    .transition()
                    .duration(500)
                    .style("opacity", 1);
            }, 4000);
        }

        // 幻灯片19：对数性质可视化
        function visualizeLogProperties(containerId) {
            const container = d3.select(`#${containerId}`);
            if(container.empty()) return;
            container.html('');

            const svg = container.append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .style('margin-top', '-60px');

            const bounds = container.node().getBoundingClientRect();
            const width = bounds.width, height = bounds.height;
            const centerX = width / 2;

            const properties = [
                { 
                    title: "乘法在对数世界变成加法",
                    formula: "log(x·y) = log(x) + log(y)",
                    y: height*0.2,
                    color1: "#3498db",
                    color2: "#e74c3c"
                },
                { 
                    title: "除法在对数世界变成减法",
                    formula: "log(x/y) = log(x) - log(y)",
                    y: height*0.5,
                    color1: "#27ae60",
                    color2: "#f39c12"
                },
                { 
                    title: "幂在对数世界变成乘法",
                    formula: "log(x^n) = n·log(x)",
                    y: height*0.8,
                    color1: "#9b59b6",
                    color2: "#e67e22"
                }
            ];

            properties.forEach((prop, index) => {
                const propGroup = svg.append("g")
                    .attr("transform", `translate(${centerX}, ${prop.y})`);

                // 两个圆圈表示运算
                const circle1 = propGroup.append("circle")
                    .attr("cx", -80)
                    .attr("r", 35)
                    .attr("fill", prop.color1)
                    .attr("opacity", 1);
                
                const circle2 = propGroup.append("circle")
                    .attr("cx", 80)
                    .attr("r", 35)
                    .attr("fill", prop.color2)
                    .attr("opacity", 1);

                // 标题
                propGroup.append("text")
                    .attr("x", -200)
                    .attr("y", 0)
                    .attr("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("font-weight", "bold")
                    .text(prop.title);

                // 公式
                propGroup.append("text")
                    .attr("x", -200)
                    .attr("y", 30)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .text(prop.formula);

                // 动画
                function animateProperty() {
                    circle1.transition().duration(2000)
                        .attr("cx", 0)
                        .transition().duration(1000)
                        .attr("cx", -80);
                    
                    circle2.transition().duration(2000)
                        .attr("cx", 0)
                        .transition().duration(1000)
                        .attr("cx", 80);
                }
                
                setTimeout(() => {
                    animateProperty();
                    setInterval(animateProperty, 6000);
                }, index * 1000);
            });
        }

        // 幻灯片20：常用对数系统可视化
        function visualizeCommonLogs(containerId) {
            const svg = d3.select("#animation5");
            if(svg.empty()) return;
            svg.selectAll("*").remove();
            
            const bounds = svg.node().getBoundingClientRect();
            const width = bounds.width, height = bounds.height;
            const centerX = width / 2;

            svg.append("text")
                .attr("x", centerX)
                .attr("y", 40)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("font-weight", "bold")
                .text("常用对数与自然对数对比");

            // 常用对数示例
            const lgGroup = svg.append("g")
                .attr("transform", `translate(${width*0.1}, 80)`);
            
            lgGroup.append("text")
                .text("常用对数 (lg)")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .style("fill", "#e74c3c");
            
            [{input: "10", output: "1"}, {input: "100", output: "2"}, {input: "1000", output: "3"}]
                .forEach((ex, i) => {
                    const y = 30 + i * 40;
                    const g = lgGroup.append("g").style("opacity", 0);
                    
                    g.append("rect")
                        .attr("y", y)
                        .attr("width", 150)
                        .attr("height", 30)
                        .attr("fill", "#ffebee")
                        .attr("stroke", "#e74c3c")
                        .attr("rx", 5);
                    
                    g.append("text")
                        .text(`lg(${ex.input}) = ${ex.output}`)
                        .attr("x", 75)
                        .attr("y", y + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px");
                    
                    g.transition()
                        .delay(500 + i * 300)
                        .duration(500)
                        .style("opacity", 1);
                });

            // 自然对数示例
            const lnGroup = svg.append("g")
                .attr("transform", `translate(${width*0.9 - 150}, 80)`);
            
            lnGroup.append("text")
                .text("自然对数 (ln)")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .style("fill", "#27ae60");
            
            [{input: "e", output: "1"}, {input: "e²", output: "2"}, {input: "1", output: "0"}]
                .forEach((ex, i) => {
                    const y = 30 + i * 40;
                    const g = lnGroup.append("g").style("opacity", 0);
                    
                    g.append("rect")
                        .attr("y", y)
                        .attr("width", 150)
                        .attr("height", 30)
                        .attr("fill", "#e8f5e8")
                        .attr("stroke", "#27ae60")
                        .attr("rx", 5);
                    
                    g.append("text")
                        .text(`ln(${ex.input}) = ${ex.output}`)
                        .attr("x", 75)
                        .attr("y", y + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px");
                    
                    g.transition()
                        .delay(1500 + i * 300)
                        .duration(500)
                        .style("opacity", 1);
                });
        }
  /**
     * 第21页：对数运算法则可视化
     * 功能：动画演示对数运算法则的应用
     * 内容：乘积、商、幂的对数运算法则
     * 动画：数字变换，运算过程展示，支持播放控制
     * 教学目标：掌握对数运算的基本法则
     */

function visualizeLogOperations(containerId) {
        const svg = d3.select("#animation3");
        if(svg.empty()) return;
        svg.selectAll("*").remove();

        // 设置SVG背景色
        svg.append("rect")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("fill", "#ffffff");

        const width = 1100, height = 800;
        const margin = {top: 220, right: 50, bottom: 120, left: 50};
        const innerWidth = width - margin.left - margin.right;

        const g = svg.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

        // 创建背景区域 - 增强可见性
        const upperBg = g.append("rect")
            .attr("x", -30)
            .attr("y", -60)
            .attr("width", innerWidth + 60)
            .attr("height", 100)
            .attr("fill", "#e3f2fd")
            .attr("rx", 10)
            .style("opacity", 0.8)
            .style("stroke", "#1976d2")
            .style("stroke-width", 2);

        const lowerBg = g.append("rect")
            .attr("x", -30)
            .attr("y", 90)
            .attr("width", innerWidth + 60)
            .attr("height", 100)
            .attr("fill", "#e8f5e8")
            .attr("rx", 10)
            .style("opacity", 0.8)
            .style("stroke", "#388e3c")
            .style("stroke-width", 2);

    const numbers = [2, 4, 8, 16, 32, 64, 128, 256, 512];
    const logs = [1, 2, 3, 4, 5, 6, 7, 8, 9];

        const scaleNumbers = d3.scalePoint().domain(numbers).range([0, innerWidth]).padding(0.5);
        const scaleLogs = d3.scalePoint().domain(logs).range([0, innerWidth]).padding(0.5);

        // 数字轴
        const numberAxis = g.append("g").attr("class", "number-axis");
        numberAxis.call(d3.axisBottom(scaleNumbers));
        numberAxis.selectAll("text").style("font-size", "14px").style("font-weight", "bold");

        // 为数字轴添加节点 - 显示2的幂次方
    numbers.forEach((num, i) => {
            const nodeG = numberAxis.append("g")
                .attr("class", "number-node")
                .attr("transform", `translate(${scaleNumbers(num)}, 0)`);
            nodeG.append("circle")
                .attr("r", 18)
                .attr("cy", -30)
                .attr("fill", "#3498db")
            .attr("fill-opacity", 0.2)
                .attr("stroke", "#3498db")
            .attr("stroke-width", 2);

            // 使用外置文本标签来显示公式
            const textElement = nodeG.append("foreignObject")
                .attr("x", -15)
                .attr("y", -38)
                .attr("width", 30)
                .attr("height", 20)
                .html(`<div style="font-size: 12px; text-align: center; color: #2c3e50; font-weight: bold;">$2^{${i+1}}$</div>`);

            // 渲染这个节点的数学公式
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(() => {
                    window.MathJax.typesetPromise([textElement.node()]).catch(error => {
                        console.warn('MathJax rendering failed for number node:', error);
                    });
                }, 50);
            }
        });

        // 对数轴
        const logAxis = g.append("g").attr("transform", `translate(0, 150)`).attr("class", "log-axis");
        logAxis.call(d3.axisBottom(scaleLogs));
        logAxis.selectAll("text").style("font-size", "14px").style("font-weight", "bold");

        // 为对数轴添加节点
        logs.forEach(log => {
            const nodeG = logAxis.append("g")
                .attr("class", "number-node")
                .attr("transform", `translate(${scaleLogs(log)}, 0)`);
            nodeG.append("rect")
                .attr("x", -25)
                .attr("y", -42)
                .attr("width", 50)
                .attr("height", 24)
                .attr("fill", "#2ecc71")
            .attr("fill-opacity", 0.2)
                .attr("stroke", "#2ecc71")
                .attr("stroke-width", 2)
                .attr("rx", 5);

            // 使用外置文本标签来显示公式
            const textElement = nodeG.append("foreignObject")
                .attr("x", -25)
                .attr("y", -38)
                .attr("width", 50)
                .attr("height", 20)
                .html(`<div style="font-size: 10px; text-align: center; color: #2c3e50; font-weight: bold;">$\\log_2(${Math.pow(2, log)})$</div>`);

            // 渲染这个节点的数学公式
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(() => {
                    window.MathJax.typesetPromise([textElement.node()]).catch(error => {
                        console.warn('MathJax rendering failed for log node:', error);
                    });
                }, 50);
            }
        });

        g.append("text")
            .attr("x", -40)
            .attr("y", -95)
            .attr("class", "world-description")
            .attr("text-anchor", "start")
            .style("font-weight", "bold")
            .text("(乘法、除法、幂运算)");

        g.append("text")
            .attr("x", -40)
            .attr("y", 225)
            .attr("class", "world-description")
            .attr("text-anchor", "start")
            .style("font-weight", "bold")
            .text("(加法、减法、乘法)");

        // 添加垂直连接线（虚线）
        numbers.forEach((num, i) => {
            g.append("line")
                .attr("x1", scaleNumbers(num))
                .attr("y1", 20)
                .attr("x2", scaleLogs(logs[i]))
                .attr("y2", 130)
                .attr("stroke", "#9b59b6")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3")
                .style("opacity", 0.3);
        });

        // 渲染数学公式
        setTimeout(async () => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                try {
                    // 先渲染整个SVG
                    await window.MathJax.typesetPromise([svg.node()]);
                    // 再专门渲染SVG中的公式
                    await renderMathJaxInSVG(svg.node());
                } catch (error) {
                    console.warn('MathJax rendering failed:', error);
                }
            }
        }, 200);

        const operations = [
            { type: 'multiply', num1: 16, num2: 32, log1: 4, log2: 5, title: '乘法运算', desc: '16 × 32 = ?' },
            { type: 'divide', num1: 256, num2: 16, log1: 8, log2: 4, title: '除法运算', desc: '256 ÷ 16 = ?' },
            { type: 'power', num1: 8, num2: 3, log1: 3, log2: 3, title: '幂运算', desc: '8³ = ?' }
        ];

        let resumeIndex = 0;
        let cycleRunning = false;

        const getSpeed = () => animationState.speed || 1;
        const scaledDuration = value => value / getSpeed();
        const scaledDelay = value => value / getSpeed();

        const waitForResume = () => Promise.resolve();

        async function animateOperation(op) {
            return new Promise(resolve => {
                svg.selectAll(".animation-element").remove();

                let logResult, numResult, opSymbol, logOpSymbol, logFormula, numFormula;
                switch(op.type) {
                    case 'multiply':
                        logResult = op.log1 + op.log2;
                        numResult = op.num1 * op.num2;
                        opSymbol = '×';
                        logOpSymbol = '+';
                        logFormula = `${op.num1}\\times ${op.num2}=2^{${op.log1}}\\times 2^{${op.log2}}=2^{(${op.log1}+${op.log2})}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1} \\times ${op.num2} = ${numResult}`;
                        break;
                    case 'divide':
                        logResult = op.log1 - op.log2;
                        numResult = op.num1 / op.num2;
                        opSymbol = '÷';
                        logOpSymbol = '−';
                        logFormula = `${op.num1}\\div ${op.num2}=\\frac{2^{${op.log1}}}{2^{${op.log2}}}=2^{(${op.log1}-${op.log2})}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1} \\div ${op.num2} = ${numResult}`;
                        break;
                    case 'power':
                        logResult = op.log1 * op.log2;
                        numResult = Math.pow(op.num1, op.num2);
                        opSymbol = '^';
                        logOpSymbol = '×';
                        logFormula = `${op.num1}^{${op.num2}}=(2^{${op.log1}})^{${op.num2}}=2^{${op.log1}\\times ${op.log2}}=2^{${logResult}}=${numResult}`;
                        numFormula = `${op.num1}^{${op.num2}} = ${numResult}`;
                        break;
                }

                const animGroup = g.append("g").attr("class", "animation-element");

                // 问题框
                const questionBox = animGroup.append("g");
                questionBox.append("rect")
                    .attr("x", innerWidth/2 - 150)
                    .attr("y", -130)
                    .attr("width", 300)
                    .attr("height", 50)
                    .attr("class", "operation-box");

                const mainText = questionBox.append("text")
                    .attr("x", innerWidth/2)
                    .attr("y", -100)
                .attr("text-anchor", "middle")
                    .style("font-size", "24px")
                    .style("font-weight", "bold")
                    .style("fill", "#1976d2")
                    .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.1)");

                async function step1() {
                    await waitForResume();
                    mainText.text(op.desc)
                .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1000)));
                }

                async function step2() {
                    await waitForResume();
                    // 创建移动的圆点
                    const mover1 = animGroup.append("circle")
                        .attr("r", 10)
                        .attr("fill", "#e67e22")
                        .attr("cx", scaleNumbers(op.num1))
                        .attr("cy", 0)
                        .attr("class", "highlight-path");

                    let mover2;
                    if (op.type !== 'power') {
                        mover2 = animGroup.append("circle")
                            .attr("r", 10)
                            .attr("fill", "#3498db")
                            .attr("cx", scaleNumbers(op.num2))
                            .attr("cy", 0)
                            .attr("class", "highlight-path");
                    }

                    // 下移动画
                    const pathDown1 = animGroup.append("path")
                        .attr("d", `M${scaleNumbers(op.num1)},0 Q${scaleNumbers(op.num1)},75 ${scaleLogs(op.log1)},150`)
                        .attr("stroke", "#e67e22")
                        .attr("stroke-width", 2)
                .attr("fill", "none")
                        .attr("class", "highlight-path");

                    const len1 = pathDown1.node().getTotalLength();
                    pathDown1.attr("stroke-dasharray", len1 + " " + len1)
                        .attr("stroke-dashoffset", len1)
                        .transition().delay(scaledDelay(500)).duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                    mover1.transition().delay(scaledDelay(500)).duration(scaledDuration(1000))
                        .attr("cx", scaleLogs(op.log1))
                        .attr("cy", 150);

                    if (mover2) {
                        const pathDown2 = animGroup.append("path")
                            .attr("d", `M${scaleNumbers(op.num2)},0 Q${scaleNumbers(op.num2)},75 ${scaleLogs(op.log2)},150`)
                            .attr("stroke", "#3498db")
                            .attr("stroke-width", 2)
                            .attr("fill", "none")
                            .attr("class", "highlight-path");

                        const len2 = pathDown2.node().getTotalLength();
                        pathDown2.attr("stroke-dasharray", len2 + " " + len2)
                            .attr("stroke-dashoffset", len2)
                            .transition().delay(scaledDelay(500)).duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                        mover2.transition().delay(scaledDelay(500)).duration(scaledDuration(1000))
                            .attr("cx", scaleLogs(op.log2))
                            .attr("cy", 150);
                    }

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step3() {
                    await waitForResume();
                    // 显示对数公式
                    const formulaG = animGroup.append("g");
                    formulaG.append("rect")
                        .attr("x", innerWidth/2 - 180)
                        .attr("y", 200)
                        .attr("width", 360)
                    .attr("height", 40)
                        .attr("fill", "#e8f4f8")
                        .attr("stroke", "#2980b9")
                        .attr("stroke-width", 2)
                        .attr("rx", 8);

                    let latexFormula = (logFormula || "")
                        .replace(/×/g, "\\times")
                        .replace(/÷/g, "\\div")
                        .replace(/−/g, "-");

                    const formulaFO = formulaG.append("foreignObject")
                        .attr("x", innerWidth/2 - 180)
                        .attr("y", 200)
                        .attr("width", 360)
                        .attr("height", 40)
                        .style("opacity", 0);

                    formulaFO.html(`<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:16px;font-weight:bold;color:#2980b9;text-align:center;line-height:40px;">${latexFormula}$</div>`);

                    if (window.MathJax && window.MathJax.typesetPromise) {
                        try {
                            await window.MathJax.typesetPromise([formulaFO.node()]);
                        } catch (error) {
                            console.warn('MathJax rendering failed:', error);
                        }
                    }

                    formulaFO.transition().duration(scaledDuration(1000)).style("opacity", 1);
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step4() {
                    await waitForResume();
                    // 移动到结果位置
                    const mover1 = animGroup.select("circle");
                    mover1.transition().duration(scaledDuration(1000))
                        .attr("cx", scaleLogs(logResult))
                        .attr("fill", "#2ecc71");

                    const mover2 = animGroup.selectAll("circle").filter((d, i) => i === 1);
                    if (!mover2.empty()) {
                        mover2.transition().duration(scaledDuration(1000))
                            .attr("cx", scaleLogs(logResult))
                            .style("opacity", 0);
                    }

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1500)));
                }

                async function step5() {
                    await waitForResume();
                    // 上移动画
                    const pathUp = animGroup.append("path")
                        .attr("d", `M${scaleLogs(logResult)},150 Q${scaleLogs(logResult)},75 ${scaleNumbers(numResult)},0`)
                        .attr("stroke", "#2ecc71")
                        .attr("stroke-width", 2)
                        .attr("fill", "none")
                        .attr("class", "highlight-path");

                    const lenUp = pathUp.node().getTotalLength();
                    pathUp.attr("stroke-dasharray", lenUp + " " + lenUp)
                        .attr("stroke-dashoffset", lenUp)
                        .transition().duration(scaledDuration(1000)).attr("stroke-dashoffset", 0);

                    const mover1 = animGroup.select("circle");
                    mover1.transition().duration(scaledDuration(1000))
                        .attr("cy", 0)
                        .attr("cx", scaleNumbers(numResult));

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(1000)));
                }

                async function step6() {
                    await waitForResume();
                    // 显示最终结果
                    const resultBox = animGroup.append("g");
                    resultBox.append("rect")
                        .attr("x", innerWidth/2 + 300)
                        .attr("y", -130)
                        .attr("width", 200)
                        .attr("height", 50)
                        .attr("class", "result-box")
                        .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);

                    resultBox.append("text")
                        .attr("x", innerWidth/2 + 400)
                        .attr("y", -100)
        .attr("text-anchor", "middle")
                        .style("font-size", "26px")
        .style("font-weight", "bold")
                        .style("fill", "white")
                        .text(`答案: ${numResult}`)
        .style("opacity", 0)
                        .transition().duration(scaledDuration(1000)).style("opacity", 1);

                    await new Promise(resolve => setTimeout(resolve, scaledDelay(2000)));
                    resolve();
                }

                // 依次执行所有步骤
                (async () => {
                    await step1();
                    await step2();
                    await step3();
                    await step4();
                    await step5();
                    await step6();
                })();
            });
        }

        async function cycleAnimations(startIndex = 0) {
            if (cycleRunning) return;
            cycleRunning = true;
            animationState.cycleActive = true;

            let index = startIndex;

            while (animationState.cycleActive) {
                for (let i = index; i < operations.length; i++) {
                    if (!animationState.cycleActive) break;
                    animationState.currentOperationIndex = i;
                    await animateOperation(operations[i]);
                    if (!animationState.cycleActive) break;
                    await new Promise(resolve => setTimeout(resolve, scaledDelay(2000)));
                }
                index = 0;
            }

            cycleRunning = false;
            resumeIndex = animationState.currentOperationIndex || 0;
        }

        cycleAnimations();

        // 确保SVG中的公式正确渲染
        const ensureSVGMathRendering = () => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                setTimeout(async () => {
                    try {
                        await renderMathJaxInSVG(svg.node());
                    } catch (error) {
                        console.warn('SVG Math rendering failed:', error);
                    }
                }, 500);
            }
        };

        // 监听SVG内容变化，自动重新渲染公式
        const observer = new MutationObserver(() => {
            ensureSVGMathRendering();
        });

        observer.observe(svg.node(), {
            childList: true,
            subtree: true
        });

        const animationHandlers = {
            pause() {
                if (!animationState.cycleActive) return;
                resumeIndex = animationState.currentOperationIndex || 0;
                animationState.cycleActive = false;
                svg.selectAll("*").interrupt();
            },
            resume() {
                if (animationState.cycleActive) return;
                cycleAnimations(resumeIndex);
            },
            setSpeed(newSpeed) {
                animationState.speed = newSpeed || 1;
            },
            interrupt() {
                animationState.cycleActive = false;
                resumeIndex = 0;
                svg.selectAll("*").interrupt();
            }
        };

        return animationHandlers;
}

// 幻灯片24：函数性质介绍可视化
function visualizePropertiesIntro(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const properties = [
        { name: "单调性", x: width * 0.25, y: height * 0.25, color: "#e74c3c" },
        { name: "奇偶性", x: width * 0.75, y: height * 0.25, color: "#3498db" },
        { name: "周期性", x: width * 0.25, y: height * 0.75, color: "#2ecc71" },
        { name: "有界性", x: width * 0.75, y: height * 0.75, color: "#f39c12" }
    ];

    properties.forEach((prop, i) => {
        const group = g.append("g")
            .attr("transform", `translate(${prop.x}, ${prop.y})`)
            .style("opacity", 0);

        group.append("circle")
            .attr("r", 60)
            .attr("fill", prop.color)
            .attr("fill-opacity", 0.3)
            .attr("stroke", prop.color)
            .attr("stroke-width", 3);

        group.append("text")
            .attr("text-anchor", "middle")
            .attr("dy", "0.3em")
            .style("font-size", "20px")
            .style("font-weight", "bold")
            .text(prop.name);

        group.transition()
            .delay(i * 300)
            .duration(800)
            .style("opacity", 1);
    });
}

// 幻灯片25：单调递增可视化
function visualizeMonotonicityInc(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画递增函数 y = x
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(d))
        .curve(d3.curveMonotoneX);

    const data = d3.range(-4, 4.1, 0.1);
    
    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#2ecc71")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    animatePath(path);

    // 添加上升箭头
    g.append("text")
        .attr("x", xScale(3))
        .attr("y", yScale(3) - 20)
        .text("↗")
        .style("font-size", "30px")
        .style("fill", "#2ecc71");
}

// 幻灯片26：单调递减可视化
function visualizeMonotonicityDec(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画递减函数 y = -x
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(-d))
        .curve(d3.curveMonotoneX);

    const data = d3.range(-4, 4.1, 0.1);
    
    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    animatePath(path);

    // 添加下降箭头
    g.append("text")
        .attr("x", xScale(3))
        .attr("y", yScale(-3) + 40)
        .text("↘")
        .style("font-size", "30px")
        .style("fill", "#e74c3c");
}

// 幻灯片27：单调区间可视化
// 幻灯片27（显示第28页）：单调区间可视化 - 增强版
function visualizeMonotonicityIntervals(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-4, 4]).range([40, width - 40]);
    const yScale = d3.scaleLinear().domain([-2, 10]).range([height - 40, 40]);

    // 坐标轴
    drawAxes(g, xScale, yScale, width, height);

    // 画 y = (x-1)²
    const data = d3.range(-3, 5, 0.05);
    const parabola = d3.line()
        .x(d => xScale(d))
        .y(d => yScale((d - 1) * (d - 1)))
        .curve(d3.curveBasis);

    // 分段着色
    const leftData = data.filter(d => d <= 1);
    const rightData = data.filter(d => d >= 1);

    // 递减部分（红色）
    const leftPath = g.append("path")
        .datum(leftData)
        .attr("d", parabola)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 4)
        .attr("fill", "none")
        .style("filter", "drop-shadow(0 2px 4px rgba(231, 76, 60, 0.3))");

    // 递增部分（绿色）
    const rightPath = g.append("path")
        .datum(rightData)
        .attr("d", parabola)
        .attr("stroke", "#2ecc71")
        .attr("stroke-width", 4)
        .attr("fill", "none")
        .style("filter", "drop-shadow(0 2px 4px rgba(46, 204, 113, 0.3))");

    // 动画绘制曲线
    [leftPath, rightPath].forEach((path, i) => {
        const totalLength = path.node().getTotalLength();
        path.attr("stroke-dasharray", totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition()
            .delay(i * 800)
            .duration(1500)
            .ease(d3.easeLinear)
            .attr("stroke-dashoffset", 0);
    });

    // 转折点（带脉冲效果）
    const criticalPoint = g.append("circle")
        .attr("cx", xScale(1))
        .attr("cy", yScale(0))
        .attr("r", 0)
        .attr("fill", "#f39c12")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3)
        .style("filter", "drop-shadow(0 0 10px #f39c12)");

    criticalPoint.transition()
        .delay(2500)
        .duration(800)
        .attr("r", 12);

    // 脉冲环效果
    const pulseRing = g.append("circle")
        .attr("cx", xScale(1))
        .attr("cy", yScale(0))
        .attr("r", 0)
        .attr("fill", "none")
        .attr("stroke", "#f39c12")
        .attr("stroke-width", 2)
        .attr("opacity", 0.6);

    pulseRing.transition()
        .delay(3300)
        .duration(1500)
        .attr("r", 25)
        .attr("opacity", 0)
        .transition()
        .duration(0)
        .attr("r", 0)
        .attr("opacity", 0.6)
        .on("end", function repeat() {
            d3.select(this)
                .transition()
                .duration(2000)
                .attr("r", 25)
                .attr("opacity", 0)
                .transition()
                .duration(0)
                .attr("r", 0)
                .attr("opacity", 0.6)
                .on("end", repeat);
        });

    // 动态标注
    const decreaseLabel = g.append("g")
        .attr("transform", `translate(${xScale(-1)}, ${yScale(6)})`);

    decreaseLabel.append("rect")
        .attr("x", -30)
        .attr("y", -15)
        .attr("width", 60)
        .attr("height", 30)
        .attr("rx", 15)
        .attr("fill", "#e74c3c")
        .attr("fill-opacity", 0.9)
        .style("opacity", 0);

    decreaseLabel.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.3em")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .style("fill", "white")
        .text("递减↘")
        .style("opacity", 0);

    const increaseLabel = g.append("g")
        .attr("transform", `translate(${xScale(2.5)}, ${yScale(6)})`);

    increaseLabel.append("rect")
        .attr("x", -30)
        .attr("y", -15)
        .attr("width", 60)
        .attr("height", 30)
        .attr("rx", 15)
        .attr("fill", "#2ecc71")
        .attr("fill-opacity", 0.9)
        .style("opacity", 0);

    increaseLabel.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.3em")
        .style("font-size", "16px")
        .style("font-weight", "bold")
        .style("fill", "white")
        .text("递增↗")
        .style("opacity", 0);

    // 动画显示标注
    [decreaseLabel, increaseLabel].forEach((label, i) => {
        label.selectAll("*")
            .transition()
            .delay(1000 + i * 400)
            .duration(600)
            .style("opacity", 1);
    });

    // 转折点标注
    const criticalLabel = g.append("g")
        .attr("transform", `translate(${xScale(1)}, ${yScale(0) + 40})`);

    criticalLabel.append("rect")
        .attr("x", -50)
        .attr("y", -12)
        .attr("width", 100)
        .attr("height", 24)
        .attr("rx", 12)
        .attr("fill", "#f39c12")
        .attr("fill-opacity", 0.9)
        .style("opacity", 0);

    criticalLabel.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.3em")
        .style("font-size", "14px")
        .style("font-weight", "bold")
        .style("fill", "white")
        .text("转折点 (1, 0)")
        .style("opacity", 0);

    criticalLabel.selectAll("*")
        .transition()
        .delay(3500)
        .duration(600)
        .style("opacity", 1);

    // 函数表达式
    const title = g.append("text")
        .attr("x", width/2)
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .style("font-size", "24px")
        .style("font-weight", "bold")
        .style("fill", "#2c3e50")
        .text("y = (x - 1)²")
        .style("opacity", 0)
        .transition()
        .delay(4000)
        .duration(800)
        .style("opacity", 1);

    // 添加交互式点
    function addInteractivePoint(x) {
        const point = g.append("circle")
            .attr("cx", xScale(x))
            .attr("cy", yScale((x - 1) * (x - 1)))
            .attr("r", 6)
            .attr("fill", "#3498db")
            .attr("stroke", "#fff")
            .attr("stroke-width", 2)
            .style("cursor", "pointer")
            .style("opacity", 0);

        point.transition()
            .delay(4500)
            .duration(500)
            .style("opacity", 1);

        // 悬停效果
        point.on("mouseover", function() {
            d3.select(this)
                .transition()
                .duration(200)
                .attr("r", 10)
                .attr("fill", "#e74c3c");

            // 显示坐标
            const tooltip = g.append("text")
                .attr("x", xScale(x) + 10)
                .attr("y", yScale((x - 1) * (x - 1)) - 10)
                .style("font-size", "12px")
                .style("fill", "#2c3e50")
                .style("font-weight", "bold")
                .text(`(${x}, ${((x - 1) * (x - 1)).toFixed(2)})`)
                .style("opacity", 0);

            tooltip.transition()
                .duration(200)
                .style("opacity", 1);
        }).on("mouseout", function() {
            d3.select(this)
                .transition()
                .duration(200)
                .attr("r", 6)
                .attr("fill", "#3498db");

            g.selectAll("text").filter(function() {
                return d3.select(this).text().includes("(" + x + ",");
            }).remove();
        });
    }

    // 添加几个关键点
    setTimeout(() => {
        addInteractivePoint(-2);
        addInteractivePoint(0);
        addInteractivePoint(1);
        addInteractivePoint(3);
    }, 4500);

    // 添加切线动画
    function showTangentAt(x) {
        const slope = 2 * (x - 1); // 导数为 2(x-1)
        const y = (x - 1) * (x - 1);
        
        // 切线
        const tangentLine = g.append("line")
            .attr("x1", xScale(x - 1))
            .attr("y1", yScale(y - slope))
            .attr("x2", xScale(x + 1))
            .attr("y2", yScale(y + slope))
            .attr("stroke", "#9b59b6")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5, 5")
            .style("opacity", 0);

        tangentLine.transition()
            .delay(6000)
            .duration(800)
            .style("opacity", 1);

        // 切线标签
        g.append("text")
            .attr("x", xScale(x + 0.5))
            .attr("y", yScale(y + slope) - 10)
            .style("font-size", "12px")
            .style("fill", "#9b59b6")
            .style("font-weight", "bold")
            .text(`斜率 = ${slope.toFixed(1)}`)
            .style("opacity", 0)
            .transition()
            .delay(6500)
            .duration(600)
            .style("opacity", 1);
    }

    // 在转折点显示切线
    setTimeout(() => {
        showTangentAt(1);
    }, 6000);
}

// 幻灯片28：奇偶性介绍可视化
function visualizeParityIntro(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    // 偶函数示例
    const evenGroup = g.append("g")
        .attr("transform", `translate(${width * 0.25}, ${height * 0.5})`);
    
    evenGroup.append("rect")
        .attr("x", -80)
        .attr("y", -80)
        .attr("width", 160)
        .attr("height", 160)
        .attr("fill", "#3498db")
        .attr("fill-opacity", 0.2)
        .attr("stroke", "#3498db")
        .attr("stroke-width", 2);
    
    evenGroup.append("text")
        .attr("text-anchor", "middle")
        .text("偶函数")
        .style("font-size", "20px");
    
    evenGroup.append("text")
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .text("Y轴对称")
        .style("font-size", "16px")
        .style("fill", "#666");

    // 奇函数示例
    const oddGroup = g.append("g")
        .attr("transform", `translate(${width * 0.75}, ${height * 0.5})`);
    
    oddGroup.append("circle")
        .attr("r", 80)
        .attr("fill", "#e74c3c")
        .attr("fill-opacity", 0.2)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2);
    
    oddGroup.append("text")
        .attr("text-anchor", "middle")
        .text("奇函数")
        .style("font-size", "20px");
    
    oddGroup.append("text")
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .text("原点对称")
        .style("font-size", "16px")
        .style("fill", "#666");
}

// 幻灯片29：偶函数可视化
function visualizeEvenFunction(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-2, 10]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画 y = x^2 (偶函数)
    const data = d3.range(-4, 4.1, 0.1);
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(d * d))
        .curve(d3.curveBasis);

    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#3498db")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    animatePath(path);

    // 标记对称点
    [-2, 2].forEach(x => {
        g.append("circle")
            .attr("cx", xScale(x))
            .attr("cy", yScale(x * x))
            .attr("r", 5)
            .attr("fill", "#e74c3c");
    });

    // Y轴对称线
    g.append("line")
        .attr("x1", xScale(0))
        .attr("y1", 0)
        .attr("x2", xScale(0))
        .attr("y2", height)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5, 5");
}

// 幻灯片30：奇函数可视化
function visualizeOddFunction(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画 y = x^3 (奇函数)
    const data = d3.range(-2, 2.1, 0.1);
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(d * d * d))
        .curve(d3.curveBasis);

    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    animatePath(path);

    // 标记对称点
    [-1.5, 1.5].forEach(x => {
        g.append("circle")
            .attr("cx", xScale(x))
            .attr("cy", yScale(x * x * x))
            .attr("r", 5)
            .attr("fill", "#3498db");
    });

    // 原点
    g.append("circle")
        .attr("cx", xScale(0))
        .attr("cy", yScale(0))
        .attr("r", 6)
        .attr("fill", "#f39c12")
        .attr("stroke", "#333")
        .attr("stroke-width", 2);
}

// 幻灯片31：有界性可视化
function visualizeBoundedness(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-10, 10]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-2, 2]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // 画 sin(x)
    const data = d3.range(-10, 10.1, 0.1);
    const line = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(Math.sin(d)))
        .curve(d3.curveBasis);

    const path = g.append("path")
        .datum(data)
        .attr("d", line)
        .attr("stroke", "#3498db")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    // 上界线
    g.append("line")
        .attr("x1", 0)
        .attr("y1", yScale(1))
        .attr("x2", width)
        .attr("y2", yScale(1))
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "10, 5");

    // 下界线
    g.append("line")
        .attr("x1", 0)
        .attr("y1", yScale(-1))
        .attr("x2", width)
        .attr("y2", yScale(-1))
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "10, 5");

    // 标注
    g.append("text")
        .attr("x", width - 50)
        .attr("y", yScale(1) - 10)
        .text("上界: 1")
        .style("fill", "#e74c3c");

    g.append("text")
        .attr("x", width - 50)
        .attr("y", yScale(-1) + 20)
        .text("下界: -1")
        .style("fill", "#e74c3c");
}

// 幻灯片32：反函数机器可视化
// 幻灯片32（显示第33页）：反函数机器可视化 - 增强版
// 幻灯片32（显示第33页）：反函数机器可视化 - 修复版
function visualizeInverseMachine(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    // 清除之前的内容
    g.selectAll("*").remove();

    // 标题
    const titleFO = g.append("foreignObject")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", 60)
        .html(`<div style="text-align: center; font-size: 30px; font-weight: bold; color: #2c3e50; padding-top: 20px;">
            反函数：互逆的操作
        </div>`);

    const centerY = height / 2;

    // 机器1：正向函数
    const machine1 = g.append("g")
        .attr("transform", `translate(${width * 0.25}, ${centerY})`);

    const box1 = machine1.append("rect")
        .attr("x", -80)
        .attr("y", -60)
        .attr("width", 160)
        .attr("height", 120)
        .attr("rx", 15)
        .attr("fill", "#3498db")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3)
        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.2))")
        .style("opacity", 0);

    box1.transition()
        .duration(800)
        .style("opacity", 1);

    const machine1FO = machine1.append("foreignObject")
        .attr("x", -70)
        .attr("y", -40)
        .attr("width", 140)
        .attr("height", 80)
        .html(`<div style="text-align: center; color: white;">
            <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">$f(x)$</div>
            <div style="font-size: 18px;">$y = 2x + 3$</div>
        </div>`)
        .style("opacity", 0);

    machine1FO.transition()
        .delay(200)
        .duration(600)
        .style("opacity", 1);

    // 机器2：反函数
    const machine2 = g.append("g")
        .attr("transform", `translate(${width * 0.75}, ${centerY})`);

    const box2 = machine2.append("rect")
        .attr("x", -80)
        .attr("y", -60)
        .attr("width", 160)
        .attr("height", 120)
        .attr("rx", 15)
        .attr("fill", "#e74c3c")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3)
        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.2))")
        .style("opacity", 0);

    box2.transition()
        .delay(400)
        .duration(800)
        .style("opacity", 1);

    const machine2FO = machine2.append("foreignObject")
        .attr("x", -70)
        .attr("y", -40)
        .attr("width", 140)
        .attr("height", 180)
        .html(`<div style="text-align: center; color: white;">
            <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">$f^{-1}(x)$</div>
            <div style="font-size: 18px;">$x = \\frac{y-3}{2}$</div>
        </div>`)
        .style("opacity", 0);

    machine2FO.transition()
        .delay(600)
        .duration(600)
        .style("opacity", 1);

    // 动画演示
    function animateInverse() {
        const inputValue = 2;
        const outputValue = 2 * inputValue + 3; // f(2) = 7
        
        // 创建数字小球
        const ball = g.append("g")
            .attr("class", "demo-ball");

        const circle = ball.append("circle")
            .attr("cx", width * 0.1)
            .attr("cy", centerY)
            .attr("r", 25)
            .attr("fill", "#2c3e50")
            .style("opacity", 0);

        const ballText = ball.append("text")
            .attr("x", width * 0.1)
            .attr("y", centerY)
            .attr("text-anchor", "middle")
            .attr("dy", "0.3em")
            .style("font-size", "18px")
            .style("font-weight", "bold")
            .style("fill", "white")
            .text(inputValue)
            .style("opacity", 0);

        // 显示输入
        circle.transition().duration(400).style("opacity", 1);
        ballText.transition().duration(400).style("opacity", 1);

        // 后续动画逻辑...
    }

    // 底部说明
    const explanationFO = g.append("foreignObject")
        .attr("x", 50)
        .attr("y", height - 60)
        .attr("width", width - 100)
        .attr("height", 50)
        .html(`<div style="text-align: center; font-size: 18px; color: #7f8c8d;">
            <strong>关键性质：</strong> $f(f^{-1}(x)) = x$ 且 $f^{-1}(f(x)) = x$
        </div>`)
                        .style("opacity", 0);

    explanationFO.transition()
        .delay(3000)
        .duration(1000)
        .style("opacity", 1);

    // 渲染MathJax
    setTimeout(() => {
        renderMathJaxInContainer(containerId);
    }, 100);
}

// 幻灯片33：反函数图像可视化
function visualizeInverseGraph(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { g, width, height } = setup;

    const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);

    drawAxes(g, xScale, yScale, width, height);

    // y = x 对称线
    g.append("line")
        .attr("x1", xScale(-5))
        .attr("y1", yScale(-5))
        .attr("x2", xScale(5))
        .attr("y2", yScale(5))
        .attr("stroke", "#95a5a6")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5, 5");

    // 原函数 y = 2x
    const data = d3.range(-2.5, 2.6, 0.1);
    const lineF = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(2 * d));

    g.append("path")
        .datum(data)
        .attr("d", lineF)
        .attr("stroke", "#3498db")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    // 反函数 y = x/2
    const lineInv = d3.line()
        .x(d => xScale(d))
        .y(d => yScale(d / 2));

    g.append("path")
        .datum(data)
        .attr("d", lineInv)
        .attr("stroke", "#e74c3c")
        .attr("stroke-width", 3)
        .attr("fill", "none");

    // 标注
    g.append("text")
        .attr("x", xScale(2))
        .attr("y", yScale(4) - 10)
        .text("f(x) = 2x")
        .style("fill", "#3498db");

    g.append("text")
        .attr("x", xScale(4))
        .attr("y", yScale(2) + 20)
        .text("f⁻¹(x) = x/2")
        .style("fill", "#e74c3c");
}

// 幻灯片35：复合函数机器可视化
// 幻灯片35（显示第36页）：复合函数机器可视化 - 增强版
function visualizeCompositeMachine(containerId) {
    const setup = setupD3(containerId);
    if (!setup) return;
    const { svg, g, width, height } = setup;

    const centerY = height / 2;

    // 三个处理阶段
    const stages = [
        { x: width * 0.15, label: "输入", formula: "x", color: "#95a5a6", isIO: true },
        { x: width * 0.35, label: "内层函数", formula: "g(x) = x + 1", color: "#3498db", isIO: false },
        { x: width * 0.55, label: "外层函数", formula: "f(u) = u²", color: "#e74c3c", isIO: false },
        { x: width * 0.75, label: "输出", formula: "y", color: "#2ecc71", isIO: true }
    ];

    stages.forEach((stage, i) => {
        const stageGroup = g.append("g")
            .attr("transform", `translate(${stage.x}, ${centerY})`);

        if (stage.isIO) {
            // 输入输出用圆形
            stageGroup.append("circle")
                .attr("r", 50)
                .attr("fill", stage.color)
                .attr("fill-opacity", 0.2)
                .attr("stroke", stage.color)
                .attr("stroke-width", 3)
                .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.1))");

            stageGroup.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "0.3em")
                .style("font-size", "24px")
                .style("font-weight", "bold")
                .style("fill", stage.color)
                .text(stage.formula);
        } else {
            // 函数用矩形
            stageGroup.append("rect")
                .attr("x", -70)
                .attr("y", -50)
                .attr("width", 140)
                .attr("height", 200)
                .attr("rx", 15)
                .attr("fill", stage.color)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.2))");

            stageGroup.append("text")
                .attr("text-anchor", "middle")
                .attr("y", -15)
                .style("font-size", "18px")
                .style("font-weight", "bold")
                .style("fill", "white")
                .text(stage.label);

            stageGroup.append("text")
                .attr("text-anchor", "middle")
                .attr("y", 15)
                .style("font-size", "16px")
                .style("fill", "white")
                .text(stage.formula);
        }
    });

    // 连接线
    for (let i = 0; i < stages.length - 1; i++) {
        const x1 = stages[i].x + (stages[i].isIO ? 50 : 70);
        const x2 = stages[i + 1].x - (stages[i + 1].isIO ? 50 : 70);
        
        const line = g.append("line")
            .attr("x1", x1)
            .attr("y1", centerY)
            .attr("x2", x2)
            .attr("y2", centerY)
            .attr("stroke", "#7f8c8d")
            .attr("stroke-width", 3)
            .attr("stroke-dasharray", "5, 5")
            .style("opacity", 0.8);

        // 流动动画
        line.transition()
            .delay(i * 500)
            .duration(2000)
            .attr("stroke-dashoffset", -20)
            .transition()
            .duration(2000)
            .attr("stroke-dashoffset", 0)
            .on("end", function repeat() {
                d3.select(this)
                    .transition()
                    .duration(2000)
                    .attr("stroke-dashoffset", -20)
                    .transition()
                    .duration(2000)
                    .attr("stroke-dashoffset", 0)
                    .on("end", repeat);
            });
    }

    // 动画演示
    function animateComposition() {
        const value = Math.floor(Math.random() * 4) + 1;
        
        // 显示初始值
        const valueText = g.append("text")
            .attr("x", stages[0].x)
            .attr("y", centerY - 80)
            .attr("text-anchor", "middle")
            .style("font-size", "32px")
            .style("font-weight", "bold")
            .style("fill", "#2c3e50")
            .text(value)
            .style("opacity", 0);

        valueText.transition()
            .duration(500)
            .style("opacity", 1);

        // 经过g(x)
        setTimeout(() => {
            const intermediate = value + 1;
            valueText.transition()
                .duration(800)
                .attr("x", stages[1].x)
                .text(`${value} → ${intermediate}`)
                .style("fill", "#3498db");
        }, 1000);

        // 经过f(u)
        setTimeout(() => {
            const intermediate = value + 1;
            const final = intermediate * intermediate;
            valueText.transition()
                .duration(800)
                .attr("x", stages[2].x)
                .text(`${intermediate} → ${final}`)
                .style("fill", "#e74c3c");
        }, 2200);

        // 最终结果
        setTimeout(() => {
            const final = (value + 1) * (value + 1);
            valueText.transition()
                .duration(800)
                .attr("x", stages[3].x)
                .text(final)
                .style("fill", "#2ecc71");

            // 显示完整公式
            const formula = g.append("g")
                .attr("transform", `translate(${width/2}, ${centerY + 120})`);

            formula.append("rect")
                .attr("x", -200)
                .attr("y", -20)
                .attr("width", 400)
                .attr("height", 40)
                .attr("rx", 10)
                .attr("fill", "#f8f9fa")
                .attr("stroke", "#6c757d")
                .attr("stroke-width", 2)
                .style("opacity", 0);

            formula.append("text")
                .attr("text-anchor", "middle")
                .style("font-size", "20px")
                .style("font-weight", "bold")
                .style("fill", "#495057")
                .text(`f(g(${value})) = (${value} + 1)² = ${final}`)
                .style("opacity", 0);

            formula.selectAll("*")
                .transition()
                .duration(800)
                .style("opacity", 1)
                .transition()
                .delay(2000)
                .duration(500)
                .style("opacity", 0)
                .remove();
        }, 3400);

        // 清除
        setTimeout(() => {
            valueText.transition()
                .duration(500)
                .style("opacity", 0)
                .remove();
        }, 6000);
    }

    // 开始动画循环
    setTimeout(() => animateComposition(), 1000);
    setInterval(animateComposition, 7000);

    // 标题
    g.append("text")
        .attr("x", width/2)
        .attr("y", 40)
        .attr("text-anchor", "middle")
        .style("font-size", "28px")
        .style("font-weight", "bold")
        .style("fill", "#2c3e50")
        .text("复合函数：层层处理")
        .style("opacity", 0)
        .transition()
        .duration(1000)
        .style("opacity", 1);

    // 说明文字
    g.append("text")
        .attr("x", width/2)
        .attr("y", height - 40)
        .attr("text-anchor", "middle")
        .style("font-size", "18px")
        .style("fill", "#7f8c8d")
        .style("font-weight", "bold")
        .text("复合函数：先执行内层函数，再用结果执行外层函数")
        .style("opacity", 0)
        .transition()
        .delay(2000)
        .duration(1000)
        .style("opacity", 1);
}







        function visualizeInteractiveExponential(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 50});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;

            // Add title
            svg.append('text')
                .attr('x', width / 2 + 50)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '20px')
                .style('font-weight', 'bold')
                .text('指数函数 y = a^x');

            const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-1, 8]).range([height, 0]);

            // Draw axes
            g.append('g')
                .attr('transform', `translate(0, ${yScale(0)})`)
                .call(d3.axisBottom(xScale).ticks(8))
                .call(sel => sel.select('.domain').attr('stroke-width', 1.5));
            g.append('g')
                .attr('transform', `translate(${xScale(0)}, 0)`)
                .call(d3.axisLeft(yScale).ticks(8))
                .call(sel => sel.select('.domain').attr('stroke-width', 1.5));

            // Slider
            const sliderContainer = container.append('div')
                .style('position', 'absolute')
                .style('bottom', '20px')
                .style('left', '50%')
                .style('transform', 'translateX(-50%)')
                .style('background', 'rgba(255, 255, 255, 0.9)')
                .style('padding', '10px')
                .style('border-radius', '8px')
                .style('box-shadow', '0 2px 8px rgba(0,0,0,0.15)');

            sliderContainer.append('label').text('底数 a: ').style('color', 'black');
            const slider = sliderContainer.append('input')
                .attr('type', 'range')
                .attr('min', 0.2)
                .attr('max', 4)
                .attr('step', 0.1)
                .attr('value', 2);
            const label = sliderContainer.append('span').text('2.0').style('color', 'black').style('font-weight', 'bold');

            const path = g.append("path")
                .attr("fill", "none")
                .attr("stroke-width", 3);

            const fixedPointLabel = g.append('text')
                .attr('x', xScale(0) + 5)
                .attr('y', yScale(1) - 5)
                .style('font-size', '12px')
                .text('恒过点 (0, 1)');

            g.append('circle')
                .attr('cx', xScale(0))
                .attr('cy', yScale(1))
                .attr('r', 5)
                .attr('fill', 'var(--accent-color)');

            function update(a) {
                label.text(a.toFixed(1));
                
                let description = '';
                if (a > 1) {
                    path.attr("stroke", "var(--danger-color)");
                    description = 'a > 1, 函数单调递增';
                } else if (a === 1) {
                    path.attr("stroke", "var(--info-color)");
                    description = 'a = 1, 函数为 y=1';
                } else { // 0 < a < 1
                    path.attr("stroke", "var(--success-color)");
                    description = '0 < a < 1, 函数单调递减';
                }
                
                // Update description text
                svg.selectAll('.desc-text').remove();
                svg.append('text')
                    .attr('class', 'desc-text')
                    .attr('x', width / 2 + 50)
                    .attr('y', height - 5)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('fill', '#555')
                    .text(description);

                const line = d3.line()
                    .x(d => xScale(d))
                    .y(d => yScale(Math.pow(a, d)));

                const data = d3.range(-4, 4.1, 0.1);
                path.datum(data).attr("d", line);
            }

            update(2);
            slider.on('input', function() {
                update(+this.value);
            });
        }

        function visualizeInteractiveLogarithm(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 50});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;

            svg.append('text')
                .attr('x', width / 2 + 50)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '20px')
                .style('font-weight', 'bold')
                .text('对数函数 y = logₐ(x)');

            const xScale = d3.scaleLinear().domain([-1, 8]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-4, 4]).range([height, 0]);

            g.append('g')
                .attr('transform', `translate(0, ${yScale(0)})`)
                .call(d3.axisBottom(xScale).ticks(8))
                .call(sel => sel.select('.domain').attr('stroke-width', 1.5));
            g.append('g')
                .attr('transform', `translate(${xScale(0)}, 0)`)
                .call(d3.axisLeft(yScale).ticks(8))
                .call(sel => sel.select('.domain').attr('stroke-width', 1.5));

            const sliderContainer = container.append('div')
                .style('position', 'absolute')
                .style('bottom', '20px')
                .style('left', '50%')
                .style('transform', 'translateX(-50%)')
                .style('background', 'rgba(255, 255, 255, 0.9)')
                .style('padding', '10px')
                .style('border-radius', '8px')
                .style('box-shadow', '0 2px 8px rgba(0,0,0,0.15)');

            sliderContainer.append('label').text('底数 a: ').style('color', 'black');
            const slider = sliderContainer.append('input')
                .attr('type', 'range')
                .attr('min', 0.2)
                .attr('max', 4)
                .attr('step', 0.1)
                .attr('value', 2);
            const label = sliderContainer.append('span').text('2.0').style('color', 'black').style('font-weight', 'bold');

            const path = g.append("path")
                .attr("fill", "none")
                .attr("stroke-width", 3);
                
            const fixedPointLabel = g.append('text')
                .attr('x', xScale(1) + 5)
                .attr('y', yScale(0) - 5)
                .style('font-size', '12px')
                .text('恒过点 (1, 0)');

            g.append('circle')
                .attr('cx', xScale(1))
                .attr('cy', yScale(0))
                .attr('r', 5)
                .attr('fill', 'var(--accent-color)');

            function update(a) {
                label.text(a.toFixed(1));
                path.style('opacity', 1);

                let description = '';
                if (a > 1) {
                    path.attr("stroke", "var(--danger-color)");
                    description = 'a > 1, 函数单调递增';
                } else if (a === 1) {
                    path.style('opacity', 0); // log base 1 is undefined
                    description = 'a = 1, 对数函数无意义';
                } else { // 0 < a < 1
                    path.attr("stroke", "var(--success-color)");
                    description = '0 < a < 1, 函数单调递减';
                }

                svg.selectAll('.desc-text').remove();
                svg.append('text')
                    .attr('class', 'desc-text')
                    .attr('x', width / 2 + 50)
                    .attr('y', height - 5)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('fill', '#555')
                    .text(description);

                if (a === 1) return;

                const line = d3.line()
                    .x(d => xScale(d))
                    .y(d => yScale(Math.log(d) / Math.log(a)));

                const data = d3.range(0.01, 8.1, 0.01);
                path.datum(data).attr("d", line);
            }

            update(2);
            slider.on('input', function() {
                update(+this.value);
            });
        }

        function visualizeInteractiveTrig(containerId) {
            const container = d3.select(`#${containerId}`);
            if (container.empty()) {
                console.error("Container not found:", containerId);
                return null;
            }
            container.html('');
            container.style('touch-action', 'none');

            const width = container.node().clientWidth;
            const height = container.node().clientHeight;
            const margin = {top: 40, right: 20, bottom: 40, left: 20};
            
            const plotSize = Math.min(width - margin.left - margin.right, height - margin.top - margin.bottom);
            const radius = plotSize / 2.5;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${width / 2}, ${height / 2})`);

            const xScale = d3.scaleLinear().domain([-1.5, 1.5]).range([-radius * 1.5, radius * 1.5]);
            const yScale = d3.scaleLinear().domain([-1.5, 1.5]).range([radius * 1.5, -radius * 1.5]);

            // Grid lines
            const grid = g.append('g').attr('class', 'grid');
            grid.selectAll('.x-grid')
                .data(yScale.ticks(10))
                .enter().append('line')
                .attr('class', 'x-grid')
                .attr('x1', xScale.range()[0])
                .attr('x2', xScale.range()[1])
                .attr('y1', d => yScale(d))
                .attr('y2', d => yScale(d))
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 0.5);

            grid.selectAll('.y-grid')
                .data(xScale.ticks(10))
                .enter().append('line')
                .attr('class', 'y-grid')
                .attr('x1', d => xScale(d))
                .attr('x2', d => xScale(d))
                .attr('y1', yScale.range()[0])
                .attr('y2', yScale.range()[1])
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 0.5);

            // Axes
            const xAxis = g.append('g').attr('class', 'axis x-axis').call(d3.axisBottom(xScale).ticks(5));
            const yAxis = g.append('g').attr('class', 'axis y-axis').call(d3.axisLeft(yScale).ticks(5));
            xAxis.select('.domain').attr('stroke-width', 1.5);
            yAxis.select('.domain').attr('stroke-width', 1.5);

            // Unit circle
            g.append('circle')
                .attr('r', radius)
                .attr('fill', 'rgba(200, 200, 200, 0.1)')
                .attr('stroke', '#888');

            const angleArc = d3.arc().innerRadius(0).outerRadius(radius * 0.3);
            const anglePath = g.append('path').attr('fill', 'rgba(0,0,0,0.1)');
            const angleLabel = g.append('text').attr('class', 'angle-label').attr('dy', '0.35em');

            const angleLine = g.append('line').attr('x1', 0).attr('y1', 0).attr('stroke', '#555').attr('stroke-width', 2);
            const sineLine = g.append('line').attr('stroke', 'var(--danger-color)').attr('stroke-width', 2.5);
            const cosineLine = g.append('line').attr('stroke', 'var(--primary-color)').attr('stroke-width', 2.5);
            
            const sineLabel = g.append('text').attr('class', 'label sine-label').style('fill', 'var(--danger-color)');
            const cosineLabel = g.append('text').attr('class', 'label cosine-label').style('fill', 'var(--primary-color)');

            const draggablePoint = g.append('circle').attr('r', 8).attr('fill', 'var(--accent-color)').style('cursor', 'pointer');
            const infoBox = d3.select('#trig-info-box');

            function update(angle) {
                const x = radius * Math.cos(angle);
                const y = -radius * Math.sin(angle); // y is inverted in SVG

                draggablePoint.attr('cx', x).attr('cy', y);
                angleLine.attr('x2', x).attr('y2', y);

                sineLine.attr('x1', x).attr('y1', y).attr('x2', x).attr('y2', 0);
                cosineLine.attr('x1', x).attr('y1', 0).attr('x2', 0).attr('y2', 0);

                sineLabel.attr('x', x + 5).attr('y', y / 2).text('sin(θ)');
                cosineLabel.attr('x', x / 2).attr('y', -5).text('cos(θ)');

                anglePath.attr('d', angleArc({startAngle: 0, endAngle: -angle}));
                const [angleX, angleY] = angleArc.centroid({startAngle: 0, endAngle: -angle});
                angleLabel.attr('x', angleX).attr('y', angleY).text(`${(-angle * 180 / Math.PI).toFixed(0)}°`);

                infoBox.html(
                    `<strong>Angle (θ):</strong> ${(-angle * 180 / Math.PI).toFixed(1)}° / ${(-angle).toFixed(2)} rad<br>` +
                    `<strong class="color-cosine">Cosine:</strong> ${Math.cos(angle).toFixed(3)}<br>` +
                    `<strong class="color-sine">Sine:</strong> ${Math.sin(angle).toFixed(3)}<br>`
                );
                renderMathJax(infoBox.node());
            }

            const drag = d3.drag().on('drag', function(event) {
                const angle = Math.atan2(-event.y, event.x);
                update(angle);
            });

            draggablePoint.call(drag);
            update(-Math.PI / 4);
        }

        // 六种三角与余函数图像（按钮切换单曲线 + MathJax 标题）
        function visualizeTrigAll(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 60});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;

            const xScale = d3.scaleLinear().domain([-Math.PI * 2, Math.PI * 2]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-2.2, 2.2]).range([height, 0]);

            // 坐标轴
            g.append('g').attr('transform', `translate(0, ${yScale(0)})`)
                .call(d3.axisBottom(xScale)
                    .ticks(9)
                    .tickFormat(d => {
                        const k = Math.round(d / (Math.PI / 2));
                        const map = {
                            '-4': '-2π','-3': '-3π/2','-2': '-π','-1': '-π/2','0': '0','1': 'π/2','2': 'π','3': '3π/2','4': '2π'
                        };
                        return map[String(k)] ?? '';
                    })
                );
            g.append('g').call(d3.axisLeft(yScale).tickValues([-2,-1,0,1,2]));

            // MathJax 标题容器
            const titleFO = g.append('foreignObject')
                .attr('x', width/2 - 150)
                .attr('y', -45)
                .attr('width', 300)
                .attr('height', 40)
                .html(`<div style="text-align:center;font-size:20px;font-weight:bold;color:#222;">$y=\\sin x$</div>`);

            // 控件：函数切换
            const ui = container.append('div')
                .style('position', 'absolute')
                .style('top', '16px')
                .style('left', '50%')
                .style('transform', 'translateX(-50%)')
                .style('display', 'flex')
                .style('gap', '8px')
                .style('background', 'rgba(255,255,255,0.9)')
                .style('padding', '6px 10px')
                .style('border-radius', '8px')
                .style('box-shadow', '0 2px 8px rgba(0,0,0,0.08)');

            const funcs = [
                { key: 'sin', label: '$y=\\sin x$', color: 'var(--danger-color)', f: x => Math.sin(x), clip: false },
                { key: 'cos', label: '$y=\\cos x$', color: 'var(--primary-color)', f: x => Math.cos(x), clip: false },
                { key: 'tan', label: '$y=\\tan x$', color: '#8e44ad', f: x => Math.tan(x), clip: true },
                { key: 'csc', label: '$y=\\csc x$', color: '#16a085', f: x => 1/Math.sin(x), clip: true },
                { key: 'sec', label: '$y=\\sec x$', color: '#d35400', f: x => 1/Math.cos(x), clip: true },
                { key: 'cot', label: '$y=\\cot x$', color: '#2c3e50', f: x => 1/Math.tan(x), clip: true },
            ];

            // 支持最多同时显示两条曲线
            const curvesG = g.append('g').attr('class','trig-curves');
            let activeKeys = new Set([funcs[0].key]);
            let activeOrder = [funcs[0].key];

            function drawCurveFor(conf) {
                const data = [];
                const step = 0.008;
                for (let x = -Math.PI*2; x <= Math.PI*2; x += step) {
                    const y = conf.f(x);
                    if (!isFinite(y) || (conf.clip && Math.abs(y) > 2.2)) {
                        data.push({break:true});
                    } else {
                        data.push({x,y});
                    }
                }
                const line = d3.line().x(d=>xScale(d.x)).y(d=>yScale(d.y));
                let seg = [];
                data.forEach(p => {
                    if (p.break) {
                        if (seg.length) {
                            curvesG.append('path')
                                .datum(seg)
                                .attr('fill','none')
                                .attr('stroke', conf.color)
                                .attr('stroke-width', 3)
                                .attr('d', line)
                                .attr('opacity', 0.95);
                            seg = [];
                        }
                    } else {
                        seg.push(p);
                    }
                });
                if (seg.length) {
                    curvesG.append('path')
                        .datum(seg)
                        .attr('fill','none')
                        .attr('stroke', conf.color)
                        .attr('stroke-width', 3)
                        .attr('d', line)
                        .attr('opacity', 0.95);
                }
            }

            function drawAll() {
                curvesG.selectAll('*').remove();
                const labels = [];
                activeOrder.forEach(key => {
                    if (!activeKeys.has(key)) return;
                    const conf = funcs.find(f=>f.key===key);
                    if (!conf) return;
                    drawCurveFor(conf);
                    labels.push(conf.label);
                });
                const titleHtml = labels.length ? labels.join('，') : '$\\,$';
                titleFO.html(`<div style=\"text-align:center;font-size:20px;font-weight:bold;color:#222;\">${titleHtml}</div>`);
                renderMathJax(titleFO.node());
            }

            // 按钮（多选，最多两条）
            funcs.forEach((conf, idx) => {
                const btn = ui.append('button')
                    .attr('class','nav-btn')
                    .style('width','auto')
                    .style('padding','4px 8px')
                    .style('border-radius','6px')
                    .style('opacity', activeKeys.has(conf.key)?1:0.7)
                    .html(conf.label)
                    .on('click', function(){
                        const k = conf.key;
                        if (activeKeys.has(k)) {
                            activeKeys.delete(k);
                            activeOrder = activeOrder.filter(x=>x!==k);
                        } else {
                            if (activeKeys.size >= 2) {
                                const removed = activeOrder.shift();
                                if (removed) activeKeys.delete(removed);
                            }
                            activeKeys.add(k);
                            activeOrder.push(k);
                        }
                        // 更新按钮态
                        ui.selectAll('button').style('opacity', function(_, i){
                            const key = funcs[i] ? funcs[i].key : null;
                            return key && activeKeys.has(key) ? 1 : 0.7;
                        });
                        drawAll();
                        renderMathJax(this);
                    });
                // 初次渲染按钮 LaTeX
                renderMathJax(btn.node());
            });

            drawAll();
        }

        function visualizeInteractiveInvTrig(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 60});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;

            // 清理旧的按钮容器（若重复进入此页）
            d3.select(`#${containerId}`).selectAll('.invtrig-controls').remove();

            const title = svg.append('text')
                .attr('x', width / 2 + 30)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '20px')
                .style('font-weight', 'bold');

            const pi = Math.PI;
            const xScale = d3.scaleLinear().domain([-pi, pi]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-1.6, 1.6]).range([height, 0]);

            g.append('g').attr('transform', `translate(0, ${yScale(0)})`)
                .call(d3.axisBottom(xScale)
                    .tickValues([-pi, -pi/2, 0, pi/2, pi])
                    .tickFormat(d => ({
                        '-3.141592653589793': '-π',
                        '-1.5707963267948966': '-π/2',
                        '0': '0',
                        '1.5707963267948966': 'π/2',
                        '3.141592653589793': 'π'
                    }[d]))
                );
            g.append('g').call(d3.axisLeft(yScale).tickValues([-1, 0, 1]));

            // MathJax 标题
            const titleFO = g.append('foreignObject')
                .attr('x', width/2 - 150)
                .attr('y', -45)
                .attr('width', 300)
                .attr('height', 40)
                .html(`<div style="text-align:center;font-size:20px;font-weight:bold;color:#222;">$y=\\arcsin x$</div>`);

            // 底图网格：三角函数曲线（灰色）
            const dataFull = d3.range(-pi, pi + 0.001, 0.005);
            const sinLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.sin(d)));
            const cosLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.cos(d)));
            const tanLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.tan(d)));

            const baseCurve = g.append('path')
                .attr('fill', 'none')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 2);

            // 受限区间高亮
            const restrictedCurve = g.append('path')
                .attr('fill', 'none')
                .attr('stroke', 'var(--danger-color)')
                .attr('stroke-width', 4);

            // 反函数曲线
            const inverseCurve = g.append('path')
                .attr('fill', 'none')
                .attr('stroke', 'var(--primary-color)')
                .attr('stroke-width', 4)
                .style('opacity', 0);

            // 可拖动水平线与交点
            const yLine = g.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('stroke', 'var(--accent-color)')
                .attr('stroke-width', 2)
                .style('cursor', 'row-resize');
            const intersections = g.append('g');

            function updateIntersections(yVal, mode) {
                yLine.attr('y1', yScale(yVal)).attr('y2', yScale(yVal));
                let xVals = [];
                const eps = 0.01;
                if (mode === 'arcsin') {
                    xVals = dataFull.filter(t => Math.abs(Math.sin(t) - yVal) < eps);
                } else if (mode === 'arccos') {
                    xVals = dataFull.filter(t => Math.abs(Math.cos(t) - yVal) < eps);
                } else {
                    xVals = dataFull.filter(t => Math.abs(Math.tan(t) - yVal) < 0.05 && Math.abs(t) < pi/2 - 0.05);
                }
                intersections.selectAll('circle').remove();
                intersections.selectAll('circle')
                    .data(xVals)
                    .enter().append('circle')
                    .attr('cx', d => xScale(d))
                    .attr('cy', yScale(yVal))
                    .attr('r', 5)
                    .attr('fill', 'var(--accent-color)');
            }

            // 控件：模式切换
            const controls = container.append('div')
                .attr('class', 'invtrig-controls')
                .style('position', 'absolute')
                .style('top', '20px')
                .style('right', '20px')
                .style('display', 'flex')
                .style('gap', '8px');

            const modes = [
                { key: 'arcsin', label: 'arcsin', func: 'sin', restrict: [-pi/2, pi/2], invY: [-pi/2, pi/2] },
                { key: 'arccos', label: 'arccos', func: 'cos', restrict: [0, pi], invY: [0, pi] },
                { key: 'arctan', label: 'arctan', func: 'tan', restrict: [-pi/2, pi/2], invY: [-pi/2, pi/2] }
            ];

            let currentMode = 'arcsin';

            const buttons = controls.selectAll('button')
                .data(modes)
                .enter()
                .append('button')
                .attr('class', 'nav-btn')
                .style('width', 'auto')
                .style('padding', '5px 10px')
                .style('border-radius', '5px')
                .style('opacity', d => d.key === currentMode ? 1 : 0.7)
                .text(d => d.label)
                .on('click', (event, d) => {
                    currentMode = d.key;
                    buttons.style('opacity', b => b.key === currentMode ? 1 : 0.7);
                    inverseCurve.style('opacity', 0);
                    render(currentMode);
                });

            // 第二个按钮：显示/隐藏反函数
            const toggleInverseBtn = controls.append('button')
                .attr('class', 'nav-btn')
                .style('width', 'auto')
                .style('padding', '5px 10px')
                .style('border-radius', '5px')
                .text('显示反函数')
                .on('click', function() {
                    const visible = inverseCurve.style('opacity') !== '0';
                    inverseCurve.transition().duration(300).style('opacity', visible ? 0 : 1);
                    d3.select(this).text(visible ? '显示反函数' : '隐藏反函数');
                });

            const drag = d3.drag().on('drag', function(event) {
                const yVal = yScale.invert(event.y);
                const limit = currentMode === 'arctan' ? 1.5 : 1;
                if (yVal >= -limit && yVal <= limit) {
                    updateIntersections(yVal, currentMode);
                }
            });

            yLine.call(drag);

            function render(mode) {
                // 基础曲线
                if (mode === 'arcsin') {
                    titleFO.html(`<div style=\"text-align:center;font-size:20px;font-weight:bold;color:#222;\">$y=\\arcsin x$</div>`);
                    baseCurve.attr('d', sinLine(dataFull));
                } else if (mode === 'arccos') {
                    titleFO.html(`<div style=\"text-align:center;font-size:20px;font-weight:bold;color:#222;\">$y=\\arccos x$</div>`);
                    baseCurve.attr('d', cosLine(dataFull));
                } else {
                    titleFO.html(`<div style=\"text-align:center;font-size:20px;font-weight:bold;color:#222;\">$y=\\arctan x$</div>`);
                    // 限制显示，避免 tan 奇异点
                    const segments = [];
                    let seg = [];
                    for (let t = -pi/2 + 0.05; t <= pi/2 - 0.05; t += 0.01) seg.push(t);
                    segments.push(seg);
                    baseCurve.attr('d', tanLine(segments[0]));
                }

                // 受限区间
                const spec = modes.find(m => m.key === mode);
                const restricted = d3.range(spec.restrict[0], spec.restrict[1] + 0.0001, 0.005);
                if (mode === 'arcsin') restrictedCurve.attr('d', sinLine(restricted));
                if (mode === 'arccos') restrictedCurve.attr('d', cosLine(restricted));
                if (mode === 'arctan') restrictedCurve.attr('d', tanLine(restricted));

                // 反函数曲线映射到同一坐标系（通过自定义缩放到受限区间横向，[-1,1] 纵向）
                let invXDom, invXRange, invYDom;
                if (mode === 'arcsin') {
                    invXDom = [-1, 1];
                    invXRange = [xScale(-pi/2), xScale(pi/2)];
                    invYDom = [-pi/2, pi/2];
                } else if (mode === 'arccos') {
                    invXDom = [-1, 1];
                    invXRange = [xScale(0), xScale(pi)];
                    invYDom = [0, pi];
                } else { // arctan
                    invXDom = [-1.5, 1.5];
                    invXRange = [xScale(-pi/2), xScale(pi/2)];
                    invYDom = [-pi/2, pi/2];
                }

                const invXScale = d3.scaleLinear().domain(invXDom).range(invXRange);
                const invYScale = d3.scaleLinear().domain(invYDom).range([yScale(-1), yScale(1)]);

                let invData, invLine;
                if (mode === 'arcsin') {
                    invData = d3.range(-1, 1.001, 0.002);
                    invLine = d3.line().x(d => invXScale(d)).y(d => invYScale(Math.asin(d)));
                } else if (mode === 'arccos') {
                    invData = d3.range(-1, 1.001, 0.002);
                    invLine = d3.line().x(d => invXScale(d)).y(d => invYScale(Math.acos(d)));
                } else {
                    invData = d3.range(invXDom[0], invXDom[1] + 0.001, 0.002);
                    invLine = d3.line().x(d => invXScale(d)).y(d => invYScale(Math.atan(d)));
                }
                inverseCurve.attr('d', invLine(invData));

                // 初始化水平线与交点
                const initY = mode === 'arctan' ? 0.5 : 0.5;
                updateIntersections(initY, mode);
                renderMathJax(titleFO.node());
            }

            render(currentMode);
            renderMathJax(titleFO.node());
        }

        function visualizeInteractiveInverseExpLog(containerId) {
            const setup = setupD3(containerId, {top: 60, right: 40, bottom: 60, left: 50});
            if (!setup) return;
            const { container, svg, g, width, height } = setup;

            svg.append('text')
                .attr('x', width / 2 + 50)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '20px')
                .style('font-weight', 'bold')
                .text('指数函数与对数函数互为反函数');

            const domainRange = 5;
            const xScale = d3.scaleLinear().domain([-domainRange, domainRange]).range([0, width]);
            const yScale = d3.scaleLinear().domain([-domainRange, domainRange]).range([height, 0]);

            g.append('g')
                .attr('transform', `translate(0, ${yScale(0)})`)
                .call(d3.axisBottom(xScale));
            g.append('g')
                .attr('transform', `translate(${xScale(0)}, 0)`)
                .call(d3.axisLeft(yScale));

            g.append("line")
                .attr("x1", xScale(-domainRange))
                .attr("y1", yScale(-domainRange))
                .attr("x2", xScale(domainRange))
                .attr("y2", yScale(domainRange))
                .attr("stroke", "#aaa")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5,5");
            g.append('text').attr('x', xScale(4)).attr('y', yScale(4) - 5).text('y=x').style('fill', '#aaa');

            const expPath = g.append("path").attr("fill", "none").attr("stroke", "var(--danger-color)").attr("stroke-width", 2.5);
            const logPath = g.append("path").attr("fill", "none").attr("stroke", "var(--primary-color)").attr("stroke-width", 2.5);

            const sliderContainer = container.append('div')
                .style('position', 'absolute')
                .style('bottom', '20px')
                .style('left', '50%')
                .style('transform', 'translateX(-50%)')
                .style('background', 'rgba(255, 255, 255, 0.9)')
                .style('padding', '10px')
                .style('border-radius', '8px')
                .style('box-shadow', '0 2px 8px rgba(0,0,0,0.15)');

            sliderContainer.append('label').text('底数 a: ').style('color', 'black');
            const slider = sliderContainer.append('input').attr('type', 'range').attr('min', 0.2).attr('max', 4).attr('step', 0.1).attr('value', 2);
            const label = sliderContainer.append('span').text('2.0').style('color', 'black').style('font-weight', 'bold');

            const expLabel = g.append('text').attr('class', 'label').style('fill', 'var(--danger-color)');
            const logLabel = g.append('text').attr('class', 'label').style('fill', 'var(--primary-color)');

            function update(a) {
                label.text(a.toFixed(1));

                if (a.toFixed(1) === '1.0') {
                    expPath.style('opacity', 0);
                    logPath.style('opacity', 0);
                    return;
                }
                expPath.style('opacity', 1);
                logPath.style('opacity', 1);

                const expLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.pow(a, d)));
                const logLine = d3.line().x(d => xScale(d)).y(d => yScale(Math.log(d) / Math.log(a)));

                const expData = d3.range(-domainRange, domainRange, 0.1).filter(x => {
                    const y = Math.pow(a, x);
                    return y < domainRange && y > -domainRange;
                });
                const logData = d3.range(0.01, domainRange, 0.1);

                expPath.datum(expData).attr("d", expLine);
                logPath.datum(logData).attr("d", logLine);
                
                expLabel.attr('x', xScale(1.5)).attr('y', yScale(Math.pow(a, 1.5)) - 5).text(`y = a^x`);
                logLabel.attr('x', xScale(Math.max(2, Math.pow(a, 1.5)))).attr('y', yScale(1.5) + 15).text(`y = log_a(x)`);
            }

            update(2);
            slider.on('input', function() {
                update(+this.value);
            });
        }

        // 运行可视化函数映射
        function runVisualization(slideIndex) {
            stopCurrentAnimation();

            let handlers;

            switch (slideIndex) {
                case 3: handlers = visualizeVariables('vis-variables'); break;
                case 4: handlers = visualizeIntervals('vis-intervals'); break;
                case 5: handlers = visualizeFunctionMachine('vis-function-machine'); break;
                case 6: handlers = visualizeDomain('vis-domain'); break;
                case 7: handlers = visualizeRange('vis-range'); break;
                case 8: handlers = visualizeElementaryIntro('vis-elementary-intro'); break;
                case 9: handlers = visualizePowerFunction('vis-power-function'); break;
                case 10: handlers = visualizeExponents('vis-exponents'); break;
                case 11: handlers = visualizeExponentRules1('vis-exponent-rules-1'); break;
                case 12: handlers = visualizeExponentRules2('vis-exponent-rules-2'); break;
                case 13: handlers = visualizeSpecialExponentsNew('vis-special-exponents'); break;
                case 14: handlers = visualizeFractionalExponents('vis-fractional-exponents'); break;
                case 15: handlers = visualizeInteractiveExponential('vis-interactive-exponential'); break;
                case 16: handlers = visualizeLogHistory('vis-log-history'); break;
                case 17: handlers = visualizeLogDefinition('vis-log-definition'); break;
                case 18: handlers = visualizeInteractiveLogarithm('vis-interactive-logarithm'); break;
                case 19: handlers = visualizeLogProperties('vis-log-properties'); break;
                case 20: handlers = visualizeCommonLogs('vis-common-logs'); break;
                case 21: handlers = visualizeLogOperations('vis-log-operations'); break;
                case 22: handlers = visualizeInteractiveTrig('vis-interactive-trig'); break;
                case 23: handlers = visualizeTrigAll('vis-trig-all'); break;
                case 24: handlers = visualizeInteractiveInvTrig('vis-interactive-inv-trig'); break;
                case 25: handlers = visualizePropertiesIntro('vis-properties-intro'); break;
                case 26: handlers = visualizeMonotonicityInc('vis-monotonicity-inc'); break;
                case 27: handlers = visualizeMonotonicityDec('vis-monotonicity-dec'); break;
                case 28: handlers = visualizeMonotonicityIntervals('vis-monotonicity-intervals'); break;
                case 29: handlers = visualizeParityIntro('vis-parity-intro'); break;
                case 30: handlers = visualizeEvenFunction('vis-even-function'); break;
                case 31: handlers = visualizeOddFunction('vis-odd-function'); break;
                case 32: handlers = visualizeBoundedness('vis-boundedness'); break;
                case 33: handlers = visualizeInverseMachine('vis-inverse-machine'); break;
                case 34: handlers = visualizeInverseGraph('vis-inverse-graph'); break;
                case 35: handlers = visualizeInteractiveInverseExpLog('vis-interactive-inverse-exp-log'); break;
                case 36: handlers = visualizeCompositeMachine('vis-composite-machine'); break;
            }

            applyCurrentAnimation(handlers);
        }

        // 幂函数可视化函数 - 重新设计
        function visualizePowerFunction(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            // 清空容器
            container.innerHTML = '';

            // 创建SVG
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            const margin = { top: 40, right: 40, bottom: 40, left: 40 };
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // 创建主绘图组，原点在中心
            const g = svg.append('g')
                .attr('transform', `translate(${width/2}, ${height/2})`);

            // 设置比例尺 - 原点在中心
            const xScale = d3.scaleLinear()
                .domain([-10, 10])
                .range([-plotWidth/2, plotWidth/2]);

            const yScale = d3.scaleLinear()
                .domain([-10, 10])
                .range([plotHeight/2, -plotHeight/2]);

            // 当前指数值
            let currentExponent = 1;

            // 绘制坐标轴
            function drawAxes() {
                // 清除之前的坐标轴
                g.selectAll('.axis').remove();
                g.selectAll('.grid').remove();

                // X轴
                g.append('line')
                    .attr('class', 'axis x-axis')
                    .attr('x1', xScale(-10))
                    .attr('x2', xScale(10))
                    .attr('y1', 0)
                    .attr('y2', 0)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2);

                // Y轴
                g.append('line')
                    .attr('class', 'axis y-axis')
                    .attr('x1', 0)
                    .attr('x2', 0)
                    .attr('y1', yScale(-10))
                    .attr('y2', yScale(10))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2);

                // 网格线
                for (let i = -10; i <= 10; i += 2) {
                    if (i !== 0) {
                        // 垂直网格线
                        g.append('line')
                            .attr('class', 'grid')
                            .attr('x1', xScale(i))
                            .attr('x2', xScale(i))
                            .attr('y1', yScale(-10))
                            .attr('y2', yScale(10))
                            .attr('stroke', '#ddd')
                            .attr('stroke-width', 1)
                            .style('opacity', 0.5);

                        // 水平网格线
                        g.append('line')
                            .attr('class', 'grid')
                            .attr('x1', xScale(-10))
                            .attr('x2', xScale(10))
                            .attr('y1', yScale(i))
                            .attr('y2', yScale(i))
                            .attr('stroke', '#ddd')
                            .attr('stroke-width', 1)
                            .style('opacity', 0.5);
                    }
                }

                // 坐标轴标签
                g.append('text')
                    .attr('class', 'axis-label')
                    .attr('x', xScale(9))
                    .attr('y', -10)
                    .style('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('fill', '#333')
                    .text('x');

                g.append('text')
                    .attr('class', 'axis-label')
                    .attr('x', 10)
                    .attr('y', yScale(9))
                    .style('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('fill', '#333')
                    .text('y');
            }

            // 绘制幂函数
            function drawPowerFunction(exponent) {
                // 清除之前的函数
                g.selectAll('.power-curve').remove();
                g.selectAll('.power-points').remove();

                // 生成数据点 - 使用更小步长让曲线更圆润
                const data = [];
                for (let x = -10; x <= 10; x += 0.1) {
                    let y;
                    
                    if (exponent === 0) {
                        y = 1; // x^0 = 1
                    } else if (exponent > 0) {
                        if (x < 0 && exponent % 1 !== 0) {
                            continue; // 负数的小数次方无意义
                        } else {
                            y = Math.pow(x, exponent);
                        }
                    } else {
                        if (x === 0) {
                            continue; // 0的负次方无意义
                        } else {
                            y = Math.pow(x, exponent);
                        }
                    }
                    
                    if (!isNaN(y) && isFinite(y)) {
                        data.push({ x, y });
                    }
                }

                // 绘制曲线 - 使用平滑插值让曲线更圆润
                const line = d3.line()
                    .x(d => xScale(d.x))
                    .y(d => yScale(d.y))
                    .curve(d3.curveCardinal);

                g.append('path')
                    .attr('class', 'power-curve')
                    .attr('d', line(data))
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 4)
                    .style('stroke-linecap', 'round')
                    .style('stroke-linejoin', 'round');

                // 添加关键点
                const keyPoints = [];
                for (let x = -10; x <= 10; x += 1) {
                    let y;
                    
                    if (exponent === 0) {
                        y = 1;
                    } else if (exponent > 0) {
                        if (x < 0 && exponent % 1 !== 0) {
                            continue;
                        } else {
                            y = Math.pow(x, exponent);
                        }
                    } else {
                        if (x === 0) {
                            continue;
                        } else {
                            y = Math.pow(x, exponent);
                        }
                    }
                    
                    if (!isNaN(y) && isFinite(y)) {
                        keyPoints.push({ x, y });
                    }
                }

                g.selectAll('.power-points')
                    .data(keyPoints)
                    .enter()
                    .append('circle')
                    .attr('class', 'power-points')
                    .attr('cx', d => xScale(d.x))
                    .attr('cy', d => yScale(d.y))
                    .attr('r', 3)
                    .attr('fill', '#e74c3c');

                // 函数标签 - 使用MathJax渲染
                g.selectAll('.function-label').remove();
                const functionLabel = g.append('foreignObject')
                    .attr('class', 'function-label')
                    .attr('x', xScale(6))
                    .attr('y', yScale(8))
                    .attr('width', 80)
                    .attr('height', 30)
                    .html(`<div style="font-size: 16px; font-weight: bold; color: #e74c3c; text-align: center;">$y = x^{${exponent.toFixed(0)}}$</div>`);
                
                // 渲染MathJax
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise([functionLabel.node()]).catch(error => {
                        console.warn('MathJax rendering failed for function label:', error);
                    });
                }
            }

            // 滑轮控制
            const sliderContainer = d3.select(container)
                .append('div')
                .style('position', 'absolute')
                .style('bottom', '20px')
                .style('left', '50%')
                .style('transform', 'translateX(-50%)')
                .style('background', 'rgba(255,255,255,0.9)')
                .style('padding', '10px 20px')
                .style('border-radius', '10px')
                .style('box-shadow', '0 2px 10px rgba(0,0,0,0.1)')
                .style('z-index', '1001');

            sliderContainer.append('label')
                .style('display', 'block')
                .style('text-align', 'center')
                .style('margin-bottom', '5px')
                .style('font-size', '14px')
                .style('color', '#2c3e50')
                .text('指数 n = ');

            const slider = sliderContainer.append('input')
                .attr('type', 'range')
                .attr('min', 0)
                .attr('max', 10)
                .attr('step', 1)
                .attr('value', 1)
                .style('width', '200px')
                .style('margin', '0 10px');

            const valueDisplay = sliderContainer.append('span')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('color', '#e74c3c')
                .text('1');

            // 滑轮事件
            slider.on('input', function() {
                currentExponent = parseFloat(this.value);
                valueDisplay.text(currentExponent.toFixed(0));
                drawPowerFunction(currentExponent);
            });

            // 初始化
            drawAxes();
            drawPowerFunction(currentExponent);
            
            // 确保MathJax公式正确渲染
            setTimeout(() => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise([container]).catch(error => {
                        console.warn('MathJax rendering failed for power function:', error);
                    });
                }
            }, 100);
        }
    </script>
</body>
</html>