<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>无穷级数 (交互式课件)</title>
    <script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready');
                    });
                }
            }
        };
    </script>
      <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready!');
                    });
                }
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
            src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js">
    </script>

    <style>
        @import url('../common-assets/css/google-fonts.css');

        :root {
            --chalkboard-bg: transparent;
            --chalk-text: #ecf0f1;
            --visualization-bg: #fdfdfd00;
            --primary-color: #3498db;
            --accent-color: #e67e22;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #9b59b6;
            --text-color: #34495e;
            --series-color: #16a085;
            --convergent-color: #27ae60;
            --divergent-color: #e74c3c;
            --heading-font: 'Noto Serif SC', serif;
            --handwriting-font: 'Noto Serif SC', serif;
        }

        body {
            font-family: var(--heading-font);
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="chalkboard" x="0" y="0" width="4" height="4" patternUnits="userSpaceOnUse"><rect x="0" y="0" width="4" height="4" fill="%23234832"/><circle cx="2" cy="2" r="0.3" fill="%23345a42" opacity="0.3"/></pattern></defs><rect width="100%" height="100%" fill="url(%23chalkboard)"/></svg>');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            overflow: auto;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
        }

        #presentation-container {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            aspect-ratio: 16 / 9;
            position: relative;
            background: rgba(255, 255, 255, 0);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: auto;
        }

        .slide {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            display: flex;
            transition: opacity 0.6s ease-in-out;
            background-color: var(--visualization-bg);
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            z-index: 10;
        }

        .chalkboard {
            flex: 0 0 35%;
            background-color: transparent !important;
            background: transparent !important;
            color: var(--chalk-text);
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border-right: 5px solid #bdc3c7;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .chalkboard h2 {
            font-family: var(--handwriting-font);
            font-size: 2.8rem;
            color: #f1c40f;
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .chalkboard h3 {
            font-family: var(--handwriting-font);
            font-size: 1.8rem;
            color: var(--primary-color);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .chalkboard p, .chalkboard li {
            font-size: 1.1rem;
            line-height: 1.7;
            margin-bottom: 15px;
        }

        .chalkboard ol {
            padding-left: 25px;
        }

        .chalkboard ul {
            list-style-type: '→ ';
            padding-left: 20px;
        }

        .math-formula {
            font-size: 1.3rem;
            color: #1abc9c;
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin: 15px 0;
            line-height: 1.5;
        }

        .highlight {
            color: var(--warning-color);
            font-weight: bold;
        }

        .convergent {
            color: var(--convergent-color);
            font-weight: bold;
        }

        .divergent {
            color: var(--divergent-color);
            font-weight: bold;
        }

        .visualization {
            flex: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            background: linear-gradient(135deg, #f5f7fa 10%, #c3cfe2 100%);
            position: relative;
            box-sizing: border-box;
        }

        .visualization.full-width {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
        }

        .visualization.white-bg {
            background: white;
        }

        .visualization.series-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .vis-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .vis-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .formula-rule {
            font-size: 1.2rem;
            color: #16a085;
            background: rgba(0,0,0,0.15);
            padding: 12px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .page-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .nav-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            user-select: none;
            min-width: 40px;
            text-align: center;
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
        }

        .nav-btn:active {
            transform: translateY(0);
            background: rgba(0, 0, 0, 0.9);
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* 级数动画样式 */
        .series-term {
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }

        .series-term.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .series-sum-display {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin: 20px;
            font-family: 'Monaco', monospace;
        }

        .partial-sum {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--series-color);
        }

        .convergence-indicator {
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            margin: 10px 0;
        }

        .convergent-indicator {
            background: rgba(39, 174, 96, 0.2);
            color: var(--convergent-color);
            border: 2px solid var(--convergent-color);
        }

        .divergent-indicator {
            background: rgba(231, 76, 60, 0.2);
            color: var(--divergent-color);
            border: 2px solid var(--divergent-color);
        }

        /* 几何级数可视化样式 */
        .geometric-blocks {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-end;
            justify-content: center;
            gap: 5px;
            margin: 20px 0;
        }

        .geometric-block {
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* 交错级数样式 */
        .alternating-term {
            display: inline-block;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 6px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .positive-term {
            background: rgba(39, 174, 96, 0.8);
            color: white;
        }

        .negative-term {
            background: rgba(231, 76, 60, 0.8);
            color: white;
        }

        /* 控制面板样式 */
        .control-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: none;
            align-items: center;
            gap: 15px;
            z-index: 100;
        }

        .control-panel.active {
            display: flex;
        }

        .control-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: var(--accent-color);
            transform: translateY(-2px);
        }

        /* 动画关键帧 */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        @keyframes convergenceGlow {
            0%, 100% {
                box-shadow: 0 0 5px var(--convergent-color);
            }
            50% {
                box-shadow: 0 0 20px var(--convergent-color);
            }
        }

        .converging-animation {
            animation: convergenceGlow 2s infinite;
        }

        /* 数学公式增强样式 */
        .math-highlight {
            background: linear-gradient(45deg, rgba(52, 152, 219, 0.2), rgba(155, 89, 182, 0.2));
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .chalkboard {
                flex: 0 0 40%;
                font-size: 0.9rem;
            }
            
            .chalkboard h2 {
                font-size: 2.2rem;
            }
            
            .chalkboard h3 {
                font-size: 1.5rem;
            }
        }
    
        </style>
    <link rel="stylesheet" href="../common-assets/css/chapter-light-theme.css">
    <link rel="stylesheet" href="../common-assets/css/chapter-light-overrides.css">

</head>
<body>
<div id="presentation-container">

    <!-- 第1页：标题页 -->
    <div class="slide active">
        <div class="chalkboard" style="flex: 1; text-align: center; border: none;">
            <h2 style="font-size: 4rem; border: none;">无穷级数</h2>
            <p style="font-size: 2rem; color: #1a1a2e; margin-top: 40px;">无限个数的和</p>
            <p style="font-size: 1.5rem; color: #5f6c80; margin-top: 30px;">探索无穷的奥秘</p>
        </div>
    </div>

    <!-- 第2页：什么是无穷级数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>什么是无穷级数</h2>
            <p>把无限个数加起来，就叫<span class="highlight">无穷级数</span>。</p>
            
            <h3>例子：切蛋糕问题</h3>
            <ul>
                <li>第一次吃掉一半：$\frac{1}{2}$</li>
                <li>第二次吃掉剩下的一半：$\frac{1}{4}$</li>
                <li>第三次继续吃掉一半：$\frac{1}{8}$</li>
                <li>继续下去...</li>
            </ul>
            
            <div class="math-formula">
                $\frac{1}{2} + \frac{1}{4} + \frac{1}{8} + \frac{1}{16} + \cdots = ?$
            </div>
            
            <p>这样无限加下去的式子就是<span class="highlight">无穷级数</span>！</p>
        </div>
        <div class="visualization" id="vis-what-is-series"></div>
    </div>

    <!-- 第3页：级数的部分和 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>部分和</h2>
            <p>因为不可能真的加无限个数，所以我们先加前几个，叫<span class="highlight">部分和</span>。</p>
            
            <h3>符号表示</h3>
            <div class="math-formula">
                $S_n = a_1 + a_2 + a_3 + \cdots + a_n$
            </div>
            
            <p>$S_n$ 表示前 $n$ 项的和。</p>
            
            <h3>还是蛋糕例子</h3>
            <ul>
                <li>$S_1 = \frac{1}{2} = 0.5$</li>
                <li>$S_2 = \frac{1}{2} + \frac{1}{4} = 0.75$</li>
                <li>$S_3 = \frac{1}{2} + \frac{1}{4} + \frac{1}{8} = 0.875$</li>
                <li>$S_4 = 0.9375$</li>
            </ul>
            
            <p>部分和越来越接近某个数了！</p>
        </div>
        <div class="visualization" id="vis-partial-sums"></div>
    </div>

    <!-- 第4页：收敛与发散 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>收敛与发散</h2>
            <p>当我们不断增加项数时，部分和的行为有两种：</p>
            
            <h3>收敛</h3>
            <p>部分和越来越接近某个<span class="convergent">固定的数</span>。</p>
            <p>就像蛋糕例子，部分和接近1。</p>
            
            <h3>发散</h3>
            <p>部分和<span class="divergent">无限增大</span>，或者来回跳动。</p>
            
            <div class="math-formula">
                如果 $\lim\limits_{n \to \infty} S_n = S$（某个数）
                <br>则级数<span class="convergent">收敛</span>于 $S$
                <br>否则级数<span class="divergent">发散</span>
            </div>
            
            <p>收敛的级数有和，发散的级数没有和。</p>
        </div>
        <div class="visualization" id="vis-convergence-divergence"></div>
    </div>

    <!-- 第5页：几何级数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>几何级数</h2>
            <p>最重要的级数类型！每一项都是前一项乘以<span class="highlight">相同的数</span>。</p>
            
            <h3>一般形式</h3>
            <div class="math-formula">
                $a + ar + ar^2 + ar^3 + \cdots$
            </div>
            <p>其中 $a$ 是<span class="highlight">首项</span>，$r$ 是<span class="highlight">公比</span>。</p>
            
            <h3>收敛条件</h3>
            <ul>
                <li>当 $|r| < 1$ 时，级数<span class="convergent">收敛</span></li>
                <li>当 $|r| \geq 1$ 时，级数<span class="divergent">发散</span></li>
            </ul>
            
            <p>蛋糕例子：$a = \frac{1}{2}$，$r = \frac{1}{2}$，所以收敛！</p>
        </div>
        <div class="visualization" id="vis-geometric-series"></div>
    </div>

    <!-- 第6页：几何级数求和公式 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>几何级数求和</h2>
            <p>当 $|r| < 1$ 时，几何级数有一个<span class="highlight">简单的求和公式</span>！</p>
            
            <div class="math-formula">
                $a + ar + ar^2 + ar^3 + \cdots = \frac{a}{1-r}$
            </div>
            
            <h3>推导思路</h3>
            <p>设 $S = a + ar + ar^2 + ar^3 + \cdots$</p>
            <p>两边同时乘以 $r$：</p>
            <p>$rS = ar + ar^2 + ar^3 + \cdots$</p>
            <p>两式相减：$S - rS = a$</p>
            <p>所以：$S(1-r) = a$，得到 $S = \frac{a}{1-r}$</p>
            
            <h3>验证蛋糕例子</h3>
            <p>$S = \frac{\frac{1}{2}}{1-\frac{1}{2}} = \frac{\frac{1}{2}}{\frac{1}{2}} = 1$ ✓</p>
        </div>
        <div class="visualization" id="vis-geometric-formula"></div>
    </div>

    <!-- 第7页：几何级数的例子 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>几何级数例子</h2>
            
            <h3>例子1：收敛</h3>
            <div class="math-formula">
                $1 + \frac{1}{3} + \frac{1}{9} + \frac{1}{27} + \cdots$
            </div>
            <p>$a = 1$，$r = \frac{1}{3}$，$|r| < 1$</p>
            <p>和为：$\frac{1}{1-\frac{1}{3}} = \frac{3}{2} = 1.5$</p>
            
            <h3>例子2：发散</h3>
            <div class="math-formula">
                $1 + 2 + 4 + 8 + 16 + \cdots$
            </div>
            <p>$a = 1$，$r = 2$，$|r| > 1$</p>
            <p>发散，和为无穷大</p>
            
            <h3>例子3：振荡</h3>
            <div class="math-formula">
                $1 - 1 + 1 - 1 + 1 - \cdots$
            </div>
            <p>$a = 1$，$r = -1$，$|r| = 1$</p>
            <p>发散，部分和在0和1之间跳动</p>
        </div>
        <div class="visualization" id="vis-geometric-examples"></div>
    </div>

    <!-- 第8页：调和级数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>调和级数</h2>
            <p>一个看起来应该收敛，但实际<span class="divergent">发散</span>的著名级数！</p>
            
            <div class="math-formula">
                $1 + \frac{1}{2} + \frac{1}{3} + \frac{1}{4} + \frac{1}{5} + \cdots = \sum_{n=1}^{\infty} \frac{1}{n}$
            </div>
            
            <h3>为什么发散？</h3>
            <p>虽然每项越来越小，但小得不够快！</p>
            
            <h3>简单证明</h3>
            <ul>
                <li>$\frac{1}{3} + \frac{1}{4} > \frac{1}{4} + \frac{1}{4} = \frac{1}{2}$</li>
                <li>$\frac{1}{5} + \frac{1}{6} + \frac{1}{7} + \frac{1}{8} > 4 \times \frac{1}{8} = \frac{1}{2}$</li>
                <li>继续分组，每组都大于$\frac{1}{2}$</li>
                <li>所以总和无限大！</li>
            </ul>
            
            <p>记住：<span class="highlight">项趋于0不等于级数收敛</span>！</p>
        </div>
        <div class="visualization" id="vis-harmonic-series"></div>
    </div>

    <!-- 第9页：p级数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>p级数</h2>
            <p>调和级数的推广形式，非常重要的判断标准！</p>
            
            <div class="math-formula">
                $\sum_{n=1}^{\infty} \frac{1}{n^p} = 1 + \frac{1}{2^p} + \frac{1}{3^p} + \frac{1}{4^p} + \cdots$
            </div>
            
            <h3>收敛判别</h3>
            <ul>
                <li>当 $p > 1$ 时，级数<span class="convergent">收敛</span></li>
                <li>当 $p \leq 1$ 时，级数<span class="divergent">发散</span></li>
            </ul>
            
            <h3>常见例子</h3>
            <ul>
                <li>$p = 1$：调和级数，发散</li>
                <li>$p = 2$：$1 + \frac{1}{4} + \frac{1}{9} + \frac{1}{16} + \cdots$，收敛于$\frac{\pi^2}{6}$</li>
                <li>$p = 3$：收敛</li>
                <li>$p = \frac{1}{2}$：发散</li>
            </ul>
        </div>
        <div class="visualization" id="vis-p-series"></div>
    </div>

    <!-- 第10页：比值判别法 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>比值判别法</h2>
            <p>判断级数收敛性的<span class="highlight">实用方法</span>！</p>
            
            <h3>方法</h3>
            <p>对于级数 $\sum a_n$，计算：</p>
            <div class="math-formula">
                $L = \lim\limits_{n \to \infty} \left|\frac{a_{n+1}}{a_n}\right|$
            </div>
            
            <h3>判别结果</h3>
            <ul>
                <li>如果 $L < 1$，级数<span class="convergent">收敛</span></li>
                <li>如果 $L > 1$，级数<span class="divergent">发散</span></li>
                <li>如果 $L = 1$，方法失效</li>
            </ul>
            
            <h3>应用技巧</h3>
            <p>特别适合含有阶乘、指数的级数！</p>
            
            <p>例：$\sum \frac{2^n}{n!}$ 中，$L = \lim\limits_{n \to \infty} \frac{2}{n+1} = 0 < 1$，收敛</p>
        </div>
        <div class="visualization" id="vis-ratio-test"></div>
    </div>

    <!-- 第11页：交错级数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>交错级数</h2>
            <p>正负号<span class="highlight">交替出现</span>的级数！</p>
            
            <div class="math-formula">
                $a_1 - a_2 + a_3 - a_4 + a_5 - \cdots$
                <br>或写作：$\sum_{n=1}^{\infty} (-1)^{n+1} a_n$
            </div>
            
            <h3>莱布尼茨判别法</h3>
            <p>如果：</p>
            <ul>
                <li>$a_n > 0$（各项本身为正）</li>
                <li>$a_n$ 单调递减</li>
                <li>$\lim\limits_{n \to \infty} a_n = 0$</li>
            </ul>
            <p>那么交错级数<span class="convergent">收敛</span>！</p>
            
            <h3>交错调和级数</h3>
            <div class="math-formula">
                $1 - \frac{1}{2} + \frac{1}{3} - \frac{1}{4} + \frac{1}{5} - \cdots = \ln 2$
            </div>
            <p>虽然调和级数发散，但交错调和级数收敛！</p>
        </div>
        <div class="visualization" id="vis-alternating-series"></div>
    </div>

    <!-- 第12页：绝对收敛与条件收敛 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>绝对收敛与条件收敛</h2>
            
            <h3>绝对收敛</h3>
            <p>如果 $\sum |a_n|$ 收敛，那么原级数 $\sum a_n$ <span class="convergent">绝对收敛</span>。</p>
            <p>绝对收敛的级数一定收敛，而且<span class="highlight">可以任意重排项</span>！</p>
            
            <h3>条件收敛</h3>
            <p>$\sum a_n$ 收敛，但 $\sum |a_n|$ 发散，叫做<span class="warning">条件收敛</span>。</p>
            
            <h3>例子对比</h3>
            <ul>
                <li>交错调和级数：$1 - \frac{1}{2} + \frac{1}{3} - \frac{1}{4} + \cdots$ 收敛</li>
                <li>但：$1 + \frac{1}{2} + \frac{1}{3} + \frac{1}{4} + \cdots$ 发散</li>
                <li>所以交错调和级数<span class="warning">条件收敛</span></li>
            </ul>
            
            <p><span class="highlight">重要</span>：条件收敛的级数重排项后和可能改变！</p>
        </div>
        <div class="visualization" id="vis-absolute-convergence"></div>
    </div>

    <!-- 第13页：幂级数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>幂级数</h2>
            <p>含有变量 $x$ 的级数，是函数的<span class="highlight">无穷多项式</span>！</p>
            
            <div class="math-formula">
                $\sum_{n=0}^{\infty} a_n x^n = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \cdots$
            </div>
            
            <h3>收敛半径</h3>
            <p>存在 $R > 0$，使得：</p>
            <ul>
                <li>当 $|x| < R$ 时，级数收敛</li>
                <li>当 $|x| > R$ 时，级数发散</li>
                <li>$R$ 叫<span class="highlight">收敛半径</span></li>
            </ul>
            
            <h3>几何级数是特例</h3>
            <div class="math-formula">
                $\frac{1}{1-x} = 1 + x + x^2 + x^3 + \cdots$，$|x| < 1$
            </div>
            
            <p>幂级数在收敛区间内表示一个函数！</p>
        </div>
        <div class="visualization" id="vis-power-series"></div>
    </div>

    <!-- 第14页：泰勒级数 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>泰勒级数</h2>
            <p>把函数用<span class="highlight">无穷级数</span>表示出来！</p>
            
            <h3>基本思想</h3>
            <p>用无穷个多项式项来"拟合"一个函数。</p>
            
            <div class="math-formula">
                $f(x) = f(0) + f'(0)x + \frac{f''(0)}{2!}x^2 + \frac{f'''(0)}{3!}x^3 + \cdots$
            </div>
            
            <h3>常见泰勒展开</h3>
            <ul>
                <li>$e^x = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots$</li>
                <li>$\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \cdots$</li>
                <li>$\cos x = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \cdots$</li>
            </ul>
            
            <p>这些展开让复杂函数变成简单的加法！</p>
        </div>
        <div class="visualization" id="vis-taylor-series"></div>
    </div>

    <!-- 第15页：级数的应用 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>级数的应用</h2>
            
            <h3>近似计算</h3>
            <p>用前几项来近似计算函数值！</p>
            <p>例：$e \approx 1 + 1 + \frac{1}{2!} + \frac{1}{3!} + \frac{1}{4!} = 2.708\overline{3}$</p>
            
            <h3>解微分方程</h3>
            <p>很多微分方程的解可以用级数表示。</p>
            
            <h3>数值积分</h3>
            <p>一些积分无法直接计算，可以用级数展开后逐项积分。</p>
            
            <h3>概率计算</h3>
            <p>正态分布等概率密度函数的积分常用级数计算。</p>
            
            <h3>工程应用</h3>
            <ul>
                <li>信号处理中的傅里叶级数</li>
                <li>计算机图形学中的级数逼近</li>
                <li>金融数学中的期权定价</li>
            </ul>
        </div>
        <div class="visualization" id="vis-applications"></div>
    </div>

    <!-- 第16页：总结 -->
    <div class="slide">
        <div class="chalkboard">
            <h2>总结</h2>
            
            <h3>重要概念</h3>
            <ul>
                <li><span class="highlight">无穷级数</span>：无限个数的和</li>
                <li><span class="highlight">部分和</span>：前n项的和</li>
                <li><span class="highlight">收敛/发散</span>：部分和是否趋于某个值</li>
            </ul>
            
            <h3>重要级数类型</h3>
            <ul>
                <li><span class="convergent">几何级数</span>：$|r| < 1$ 时收敛于 $\frac{a}{1-r}$</li>
                <li><span class="divergent">调和级数</span>：$\sum \frac{1}{n}$ 发散</li>
                <li><span class="highlight">p级数</span>：$p > 1$ 时收敛</li>
                <li><span class="highlight">交错级数</span>：正负交替</li>
            </ul>
            
            <h3>判别方法</h3>
            <ul>
                <li>比值判别法：看相邻项的比值</li>
                <li>莱布尼茨法：交错级数专用</li>
            </ul>
            
            <p><span class="highlight">记住</span>：级数是连接有限与无限的桥梁！</p>
        </div>
        <div class="visualization series-bg" style="align-items: center; justify-content: center;">
            <div style="text-align: center; color: #1a1a2e;">
                <h1 style="font-size: 3rem; margin-bottom: 2rem;">∞</h1>
                <p style="font-size: 1.5rem;">无穷级数的世界</p>
                <p style="font-size: 1.2rem; opacity: 0.8; margin-top: 1rem;">从有限走向无限</p>
            </div>
        </div>
    </div>

    <!-- 导航按钮 -->

    <!-- 页面指示器 -->

</div>

<script>
    let slides, totalSlides, counter, currentSlide = 0;
    let animationIntervals = [];

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        counter = document.getElementById('page-indicator');
        
        showSlide(0);
        
        // 键盘导航
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                previousSlide();
            }
        });

        // 滚轮导航
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY > 0) {
                nextSlide();
            } else {
                previousSlide();
            }
        }, { passive: false });
    });

    function nextSlide() {
        if (currentSlide < totalSlides - 1) {
            currentSlide++;
            showSlide(currentSlide);
        }
    }

    function previousSlide() {
        if (currentSlide > 0) {
            currentSlide--;
            showSlide(currentSlide);
        }
    }

    function showSlide(index) {
        // 清理之前的动画
        clearAnimations();
        
        // 隐藏所有幻灯片
        slides.forEach(slide => slide.classList.remove('active'));
        
        // 显示当前幻灯片
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        // 更新页面指示器
        counter.textContent = `${currentSlide + 1} / ${totalSlides}`;
        
        // 更新导航按钮状态
        updateNavButtons();
        
        // 运行当前页面的可视化
        runVisualization(currentSlide);
        
        // 渲染数学公式
        setTimeout(() => renderMathJax(slides[currentSlide]), 100);
    }

    function updateNavButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        prevBtn.disabled = (currentSlide === 0);
        nextBtn.disabled = (currentSlide === totalSlides - 1);
    }

    function clearAnimations() {
        animationIntervals.forEach(interval => clearInterval(interval));
        animationIntervals = [];
    }

    // MathJax渲染
    const renderMathJax = async (container) => {
        if (window.MathJax && window.MathJax.typesetPromise) {
            try {
                await window.MathJax.typesetPromise([container]);
            } catch (error) {
                console.warn('MathJax rendering failed:', error);
            }
        }
    };

    // D3可视化辅助函数
    function setupD3(containerId, margins = {top: 40, right: 40, bottom: 40, left: 40}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) return null;
        
        container.html('');
        const bounds = container.node().getBoundingClientRect();
        if (bounds.width === 0 || bounds.height === 0) return null;

        const svg = container.append('svg')
            .attr('width', bounds.width)
            .attr('height', bounds.height);

        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;

        const g = svg.append('g')
            .attr('transform', `translate(${margins.left}, ${margins.top})`);

        return { container, svg, g, width, height };
    }

    function drawAxes(g, xScale, yScale, width, height) {
        // X轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(8))
            .call(g => g.select(".domain").attr("stroke", "#666"))
            .call(g => g.selectAll(".tick line").attr("stroke", "#666"))
            .call(g => g.selectAll(".tick text").attr("fill", "#333"));

        // Y轴
        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale).ticks(8))
            .call(g => g.select(".domain").attr("stroke", "#666"))
            .call(g => g.selectAll(".tick line").attr("stroke", "#666"))
            .call(g => g.selectAll(".tick text").attr("fill", "#333"));
    }

    // 具体的可视化函数
    function runVisualization(slideIndex) {
        switch (slideIndex) {
            case 1: visualizeWhatIsSeries('vis-what-is-series'); break;
            case 2: visualizePartialSums('vis-partial-sums'); break;
            case 3: visualizeConvergenceDivergence('vis-convergence-divergence'); break;
            case 4: visualizeGeometricSeries('vis-geometric-series'); break;
            case 5: visualizeGeometricFormula('vis-geometric-formula'); break;
            case 6: visualizeGeometricExamples('vis-geometric-examples'); break;
            case 7: visualizeHarmonicSeries('vis-harmonic-series'); break;
            case 8: visualizePSeries('vis-p-series'); break;
            case 9: visualizeRatioTest('vis-ratio-test'); break;
            case 10: visualizeAlternatingSeries('vis-alternating-series'); break;
            case 11: visualizeAbsoluteConvergence('vis-absolute-convergence'); break;
            case 12: visualizePowerSeries('vis-power-series'); break;
            case 13: visualizeTaylorSeries('vis-taylor-series'); break;
            case 14: visualizeApplications('vis-applications'); break;
        }
    }

    // 第2页：什么是级数的可视化
    function visualizeWhatIsSeries(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html('');
        
        const bounds = container.node().getBoundingClientRect();
        const width = bounds.width;
        const height = bounds.height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
            
        // 绘制蛋糕切片
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) / 3;
        
        const slices = [
            { angle: Math.PI, label: '1/2', color: '#FF6B6B' },
            { angle: Math.PI/2, label: '1/4', color: '#4ECDC4' },
            { angle: Math.PI/4, label: '1/8', color: '#45B7D1' },
            { angle: Math.PI/8, label: '1/16', color: '#96CEB4' },
            { angle: Math.PI/16, label: '1/32', color: '#FFEAA7' }
        ];
        
        let currentAngle = 0;
        
        slices.forEach((slice, i) => {
            setTimeout(() => {
                // 绘制扇形
                const startAngle = currentAngle;
                const endAngle = currentAngle + slice.angle;
                
                const arc = d3.arc()
                    .innerRadius(0)
                    .outerRadius(radius)
                    .startAngle(startAngle)
                    .endAngle(endAngle);
                
                svg.append('path')
                    .attr('d', arc)
                    .attr('transform', `translate(${centerX}, ${centerY})`)
                    .attr('fill', slice.color)
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2)
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 0.8);
                
                // 添加标签
                const labelAngle = startAngle + slice.angle / 2;
                const labelX = centerX + Math.cos(labelAngle) * radius * 0.7;
                const labelY = centerY + Math.sin(labelAngle) * radius * 0.7;
                
                svg.append('text')
                    .attr('x', labelX)
                    .attr('y', labelY)
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .style('font-size', '16px')
                    .style('font-weight', 'bold')
                    .style('fill', 'white')
                    .style('opacity', 0)
                    .text(slice.label)
                    .transition()
                    .delay(300)
                    .duration(500)
                    .style('opacity', 1);
                
                currentAngle = endAngle;
            }, i * 800);
        });
        
        // 添加级数表达式
        setTimeout(() => {
            svg.append('text')
                .attr('x', centerX)
                .attr('y', height - 40)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .style('fill', '#2c3e50')
                .style('opacity', 0)
                .text('1/2 + 1/4 + 1/8 + 1/16 + ... = 1')
                .transition()
                .duration(1000)
                .style('opacity', 1);
        }, 4500);
    }

    // 第3页：部分和的可视化
    function visualizePartialSums(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        
        const { g, width, height } = setup;
        
        // 几何级数的部分和数据
        const terms = [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625];
        let partialSums = [];
        let sum = 0;
        
        terms.forEach(term => {
            sum += term;
            partialSums.push(sum);
        });
        
        // 创建比例尺
        const xScale = d3.scaleLinear()
            .domain([0, terms.length + 1])
            .range([0, width]);
            
        const yScale = d3.scaleLinear()
            .domain([0, 1.1])
            .range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 添加坐标轴标签
        g.append('text')
            .attr('x', width / 2)
            .attr('y', height + 35)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .text('项数 n');
            
        g.append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -25)
            .attr('x', -height / 2)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .text('部分和 Sₙ');
        
        // 绘制目标线 y = 1
        g.append('line')
            .attr('x1', 0)
            .attr('x2', width)
            .attr('y1', yScale(1))
            .attr('y2', yScale(1))
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5')
            .style('opacity', 0.7);
            
        g.append('text')
            .attr('x', width - 10)
            .attr('y', yScale(1) - 10)
            .attr('text-anchor', 'end')
            .style('font-size', '14px')
            .style('fill', '#e74c3c')
            .text('目标值 = 1');
        
        // 动画显示部分和
        partialSums.forEach((sum, i) => {
            setTimeout(() => {
                // 绘制点
                g.append('circle')
                    .attr('cx', xScale(i + 1))
                    .attr('cy', yScale(sum))
                    .attr('r', 0)
                    .attr('fill', '#3498db')
                    .attr('stroke', '#2980b9')
                    .attr('stroke-width', 2)
                    .transition()
                    .duration(300)
                    .attr('r', 6);
                
                // 添加数值标签
                g.append('text')
                    .attr('x', xScale(i + 1))
                    .attr('y', yScale(sum) - 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .style('fill', '#2980b9')
                    .style('opacity', 0)
                    .text(`S${i+1} = ${sum.toFixed(4)}`)
                    .transition()
                    .delay(200)
                    .duration(300)
                    .style('opacity', 1);
                
                // 连接线
                if (i > 0) {
                    g.append('line')
                        .attr('x1', xScale(i))
                        .attr('y1', yScale(partialSums[i-1]))
                        .attr('x2', xScale(i))
                        .attr('y2', yScale(partialSums[i-1]))
                        .attr('stroke', '#3498db')
                        .attr('stroke-width', 2)
                        .transition()
                        .duration(400)
                        .attr('x2', xScale(i + 1))
                        .attr('y2', yScale(sum));
                }
            }, i * 800);
        });
    }

    // 第4页：收敛发散对比可视化
    function visualizeConvergenceDivergence(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html('');
        
        const bounds = container.node().getBoundingClientRect();
        const width = bounds.width;
        const height = bounds.height;
        
        // 创建两个子图
        const leftSvg = container.append('div')
            .style('float', 'left')
            .style('width', '48%')
            .style('height', '100%')
            .append('svg')
            .attr('width', width * 0.48)
            .attr('height', height);
            
        const rightSvg = container.append('div')
            .style('float', 'right')
            .style('width', '48%')
            .style('height', '100%')
            .append('svg')
            .attr('width', width * 0.48)
            .attr('height', height);
        
        // 收敛例子（左图）
        drawConvergenceExample(leftSvg, width * 0.48, height, '收敛级数', '#27ae60');
        
        // 发散例子（右图）  
        drawDivergenceExample(rightSvg, width * 0.48, height, '发散级数', '#e74c3c');
    }

    function drawConvergenceExample(svg, width, height, title, color) {
        const margin = {top: 40, right: 20, bottom: 40, left: 40};
        const plotWidth = width - margin.left - margin.right;
        const plotHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 几何级数部分和
        const data = [];
        let sum = 0;
        for (let n = 1; n <= 20; n++) {
            sum += 0.5 * Math.pow(0.5, n-1);
            data.push({n: n, sum: sum});
        }
        
        const xScale = d3.scaleLinear().domain([1, 20]).range([0, plotWidth]);
        const yScale = d3.scaleLinear().domain([0, 1.1]).range([plotHeight, 0]);
        
        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${plotHeight})`)
            .call(d3.axisBottom(xScale));
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 标题
        g.append('text')
            .attr('x', plotWidth / 2)
            .attr('y', -10)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .style('fill', color)
            .text(title);
        
        // 目标线
        g.append('line')
            .attr('x1', 0)
            .attr('x2', plotWidth)
            .attr('y1', yScale(1))
            .attr('y2', yScale(1))
            .attr('stroke', color)
            .attr('stroke-dasharray', '3,3')
            .style('opacity', 0.7);
        
        // 动画绘制点和线
        const line = d3.line()
            .x(d => xScale(d.n))
            .y(d => yScale(d.sum));
        
        const path = g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', color)
            .attr('stroke-width', 2)
            .attr('d', line);
        
        // 路径动画
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(3000)
            .attr('stroke-dashoffset', 0);
        
        // 添加点
        data.forEach((d, i) => {
            setTimeout(() => {
                g.append('circle')
                    .attr('cx', xScale(d.n))
                    .attr('cy', yScale(d.sum))
                    .attr('r', 3)
                    .attr('fill', color)
                    .style('opacity', 0)
                    .transition()
                    .duration(200)
                    .style('opacity', 1);
            }, i * 150);
        });
    }

    function drawDivergenceExample(svg, width, height, title, color) {
        const margin = {top: 40, right: 20, bottom: 40, left: 40};
        const plotWidth = width - margin.left - margin.right;
        const plotHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 调和级数部分和（前20项）
        const data = [];
        let sum = 0;
        for (let n = 1; n <= 20; n++) {
            sum += 1/n;
            data.push({n: n, sum: sum});
        }
        
        const xScale = d3.scaleLinear().domain([1, 20]).range([0, plotWidth]);
        const yScale = d3.scaleLinear().domain([0, Math.max(...data.map(d => d.sum)) + 0.5]).range([plotHeight, 0]);
        
        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${plotHeight})`)
            .call(d3.axisBottom(xScale));
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 标题
        g.append('text')
            .attr('x', plotWidth / 2)
            .attr('y', -10)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .style('fill', color)
            .text(title);
        
        // 绘制上升趋势线
        const line = d3.line()
            .x(d => xScale(d.n))
            .y(d => yScale(d.sum));
        
        const path = g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', color)
            .attr('stroke-width', 2)
            .attr('d', line);
        
        // 路径动画
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(3000)
            .attr('stroke-dashoffset', 0);
        
        // 添加箭头表示继续上升
        setTimeout(() => {
            g.append('path')
                .attr('d', 'M0,-10 L10,0 L0,10 L3,0 Z')
                .attr('transform', `translate(${plotWidth - 20}, ${yScale(data[data.length-1].sum)}) rotate(-45)`)
                .attr('fill', color)
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
                
            g.append('text')
                .attr('x', plotWidth - 5)
                .attr('y', yScale(data[data.length-1].sum) + 15)
                .attr('text-anchor', 'end')
                .style('font-size', '12px')
                .style('fill', color)
                .text('→ ∞')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 3000);
    }

    // 第5页：几何级数可视化
    function visualizeGeometricSeries(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html('');
        
        const bounds = container.node().getBoundingClientRect();
        const width = bounds.width;
        const height = bounds.height;
        
        // 创建控制面板
        const controlPanel = container.append('div')
            .style('position', 'absolute')
            .style('top', '20px')
            .style('left', '20px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('padding', '15px')
            .style('border-radius', '10px')
            .style('box-shadow', '0 2px 10px rgba(0,0,0,0.1)');
        
        controlPanel.append('div')
            .style('font-weight', 'bold')
            .style('margin-bottom', '10px')
            .text('几何级数：a = 1, r = ?');
        
        const slider = controlPanel.append('input')
            .attr('type', 'range')
            .attr('min', '0.1')
            .attr('max', '1.5')
            .attr('step', '0.1')
            .attr('value', '0.5')
            .style('width', '200px');
        
        const valueDisplay = controlPanel.append('div')
            .style('margin-top', '10px')
            .style('font-weight', 'bold');
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        function updateVisualization(r) {
            svg.selectAll('*').remove();
            
            const margin = {top: 80, right: 40, bottom: 60, left: 60};
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;
            
            const g = svg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);
            
            // 计算部分和
            const data = [];
            let sum = 0;
            for (let n = 0; n < 15; n++) {
                const term = Math.pow(r, n);
                sum += term;
                data.push({n: n + 1, term: term, sum: sum});
            }
            
            const maxSum = Math.abs(r) < 1 ? 1 / (1 - r) : Math.max(...data.map(d => d.sum));
            
            const xScale = d3.scaleLinear().domain([1, 15]).range([0, plotWidth]);
            const yScale = d3.scaleLinear().domain([0, maxSum * 1.1]).range([plotHeight, 0]);
            
            // 坐标轴
            g.append('g')
                .attr('transform', `translate(0, ${plotHeight})`)
                .call(d3.axisBottom(xScale));
            g.append('g')
                .call(d3.axisLeft(yScale));
            
            // 标题
            g.append('text')
                .attr('x', plotWidth / 2)
                .attr('y', -20)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .text(`1 + ${r} + ${r}² + ${r}³ + ...`);
            
            // 如果收敛，绘制理论值线
            if (Math.abs(r) < 1) {
                const theoreticalSum = 1 / (1 - r);
                g.append('line')
                    .attr('x1', 0)
                    .attr('x2', plotWidth)
                    .attr('y1', yScale(theoreticalSum))
                    .attr('y2', yScale(theoreticalSum))
                    .attr('stroke', '#27ae60')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                g.append('text')
                    .attr('x', plotWidth - 10)
                    .attr('y', yScale(theoreticalSum) - 10)
                    .attr('text-anchor', 'end')
                    .style('font-size', '14px')
                    .style('fill', '#27ae60')
                    .text(`和 = ${theoreticalSum.toFixed(3)}`);
            }
            
            // 绘制部分和
            const line = d3.line()
                .x(d => xScale(d.n))
                .y(d => yScale(d.sum));
            
            const path = g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', Math.abs(r) < 1 ? '#3498db' : '#e74c3c')
                .attr('stroke-width', 3)
                .attr('d', line);
            
            // 添加点
            g.selectAll('.dot')
                .data(data)
                .enter().append('circle')
                .attr('class', 'dot')
                .attr('cx', d => xScale(d.n))
                .attr('cy', d => yScale(d.sum))
                .attr('r', 4)
                .attr('fill', Math.abs(r) < 1 ? '#3498db' : '#e74c3c');
            
            // 更新状态显示
            const status = Math.abs(r) < 1 ? `收敛，和 = ${(1/(1-r)).toFixed(3)}` : '发散';
            const statusColor = Math.abs(r) < 1 ? '#27ae60' : '#e74c3c';
            
            valueDisplay.html(`
                r = ${r}<br>
                <span style="color: ${statusColor}; font-weight: bold;">${status}</span>
            `);
        }
        
        // 初始化
        updateVisualization(0.5);
        
        // 滑块事件
        slider.on('input', function() {
            const r = parseFloat(this.value);
            updateVisualization(r);
        });
    }

    // 其他可视化函数的占位符
    function visualizeGeometricFormula(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html('');
        
        // 创建公式推导动画
        const div = container.append('div')
            .style('width', '100%')
            .style('height', '100%')
            .style('display', 'flex')
            .style('flex-direction', 'column')
            .style('justify-content', 'center')
            .style('align-items', 'center')
            .style('font-size', '1.5rem')
            .style('line-height', '2');
        
        const steps = [
            'S = a + ar + ar² + ar³ + ...',
            'rS = ar + ar² + ar³ + ar⁴ + ...',
            'S - rS = a',
            'S(1 - r) = a',
            'S = a / (1 - r)'
        ];
        
        steps.forEach((step, i) => {
            setTimeout(() => {
                div.append('div')
                    .style('opacity', 0)
                    .style('margin', '10px 0')
                    .style('color', i === steps.length - 1 ? '#e74c3c' : '#2c3e50')
                    .style('font-weight', i === steps.length - 1 ? 'bold' : 'normal')
                    .text(step)
                    .transition()
                    .duration(800)
                    .style('opacity', 1);
            }, i * 1200);
        });
    }

    function visualizeGeometricExamples(containerId) {
        // 简化版本，显示三个例子的对比
        const container = d3.select(`#${containerId}`);
        container.html('');
        
        const examples = [
            { name: '收敛例子', r: 1/3, color: '#27ae60' },
            { name: '发散例子', r: 2, color: '#e74c3c' },
            { name: '振荡例子', r: -1, color: '#f39c12' }
        ];
        
        const width = container.node().getBoundingClientRect().width;
        const exampleWidth = width / 3;
        
        examples.forEach((example, i) => {
            const exampleDiv = container.append('div')
                .style('float', 'left')
                .style('width', `${exampleWidth}px`)
                .style('height', '100%')
                .style('text-align', 'center')
                .style('padding', '20px');
            
            exampleDiv.append('h3')
                .style('color', example.color)
                .style('margin-bottom', '20px')
                .text(example.name);
            
            exampleDiv.append('div')
                .style('font-size', '1.2rem')
                .text(`r = ${example.r}`);
            
            // 简单的视觉指示器
            const indicator = exampleDiv.append('div')
                .style('width', '60px')
                .style('height', '60px')
                .style('border-radius', '50%')
                .style('background', example.color)
                .style('margin', '20px auto')
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('justify-content', 'center')
                .style('color', 'white')
                .style('font-size', '2rem')
                .style('font-weight', 'bold');
            
            if (Math.abs(example.r) < 1) {
                indicator.text('✓');
            } else if (example.r > 1) {
                indicator.text('↑');
            } else {
                indicator.text('~');
            }
        });
    }

    // 添加更多可视化函数...
    function visualizeHarmonicSeries(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        
        const { g, width, height } = setup;
        
        // 调和级数的部分和增长
        const data = [];
        let sum = 0;
        for (let n = 1; n <= 50; n++) {
            sum += 1/n;
            data.push({n: n, sum: sum, term: 1/n});
        }
        
        const xScale = d3.scaleLinear().domain([1, 50]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, Math.max(...data.map(d => d.sum)) + 1]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 标题
        g.append('text')
            .attr('x', width / 2)
            .attr('y', -10)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('调和级数: 1 + 1/2 + 1/3 + 1/4 + ...');
        
        // 绘制缓慢增长的曲线
        const line = d3.line()
            .x(d => xScale(d.n))
            .y(d => yScale(d.sum));
        
        const path = g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('d', line);
        
        // 路径动画
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(4000)
            .attr('stroke-dashoffset', 0);
        
        // 添加"发散"标识
        setTimeout(() => {
            g.append('text')
                .attr('x', width - 50)
                .attr('y', yScale(data[data.length-1].sum) - 20)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .style('fill', '#e74c3c')
                .text('发散!')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 4000);
    }

    function visualizePSeries(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        
        const { container, g, width, height } = setup;
        
        // 创建p值控制器
        const controlDiv = container.append('div')
            .style('position', 'absolute')
            .style('top', '10px')
            .style('left', '10px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('padding', '10px')
            .style('border-radius', '5px');
        
        controlDiv.append('label').text('p值: ');
        const pSlider = controlDiv.append('input')
            .attr('type', 'range')
            .attr('min', '0.5')
            .attr('max', '2')
            .attr('step', '0.1')
            .attr('value', '1');
        
        const pDisplay = controlDiv.append('span').text('1.0');
        
        function updatePSeries(p) {
            g.selectAll('*').remove();
            
            // 计算p级数的部分和
            const data = [];
            let sum = 0;
            for (let n = 1; n <= 30; n++) {
                sum += 1 / Math.pow(n, p);
                data.push({n: n, sum: sum});
            }
            
            const xScale = d3.scaleLinear().domain([1, 30]).range([0, width]);
            const yScale = d3.scaleLinear().domain([0, Math.max(...data.map(d => d.sum)) * 1.1]).range([height, 0]);
            
            drawAxes(g, xScale, yScale, width, height);
            
            // 标题和状态
            const isConvergent = p > 1;
            const statusColor = isConvergent ? '#27ae60' : '#e74c3c';
            const statusText = isConvergent ? '收敛' : '发散';
            
            g.append('text')
                .attr('x', width / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .text(`p级数: Σ(1/n^${p}) - ${statusText}`)
                .style('fill', statusColor);
            
            // 绘制曲线
            const line = d3.line()
                .x(d => xScale(d.n))
                .y(d => yScale(d.sum));
            
            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', statusColor)
                .attr('stroke-width', 3)
                .attr('d', line);
            
            // 添加点
            g.selectAll('.dot')
                .data(data.filter((d, i) => i % 3 === 0))
                .enter().append('circle')
                .attr('class', 'dot')
                .attr('cx', d => xScale(d.n))
                .attr('cy', d => yScale(d.sum))
                .attr('r', 4)
                .attr('fill', statusColor);
        }
        
        updatePSeries(1);
        
        pSlider.on('input', function() {
            const p = parseFloat(this.value);
            pDisplay.text(p.toFixed(1));
            updatePSeries(p);
        });
    }

    // 添加其他可视化函数的简化实现...
    function visualizeRatioTest(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html('<div style="text-align: center; padding: 50px; font-size: 1.5rem;">比值判别法演示<br><br>L = lim |a_{n+1}/a_n|<br><br>L < 1: 收敛<br>L > 1: 发散<br>L = 1: 无法判断</div>');
    }

    function visualizeAlternatingSeries(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        
        const { g, width, height } = setup;
        
        // 交错调和级数
        const data = [];
        let sum = 0;
        for (let n = 1; n <= 20; n++) {
            const term = Math.pow(-1, n+1) / n;
            sum += term;
            data.push({n: n, sum: sum, term: term});
        }
        
        const xScale = d3.scaleLinear().domain([1, 20]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-0.2, 1.2]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 添加ln(2)的参考线
        g.append('line')
            .attr('x1', 0)
            .attr('x2', width)
            .attr('y1', yScale(Math.log(2)))
            .attr('y2', yScale(Math.log(2)))
            .attr('stroke', '#27ae60')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        g.append('text')
            .attr('x', width - 10)
            .attr('y', yScale(Math.log(2)) - 10)
            .attr('text-anchor', 'end')
            .style('font-size', '14px')
            .style('fill', '#27ae60')
            .text('ln(2) ≈ 0.693');
        
        // 绘制振荡的收敛过程
        const line = d3.line()
            .x(d => xScale(d.n))
            .y(d => yScale(d.sum));
        
        g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2)
            .attr('d', line);
        
        // 添加正负项的颜色编码
        g.selectAll('.dot')
            .data(data)
            .enter().append('circle')
            .attr('class', 'dot')
            .attr('cx', d => xScale(d.n))
            .attr('cy', d => yScale(d.sum))
            .attr('r', 4)
            .attr('fill', d => d.term > 0 ? '#e74c3c' : '#3498db');
    }

    function visualizeAbsoluteConvergence(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html(`
            <div style="text-align: center; padding: 20px;">
                <h3>绝对收敛 vs 条件收敛</h3>
                <div style="display: flex; justify-content: space-around; margin-top: 30px;">
                    <div style="flex: 1; padding: 20px;">
                        <h4 style="color: #27ae60;">绝对收敛</h4>
                        <p>Σ|aₙ| 收敛 → Σaₙ 收敛</p>
                        <p>可任意重排</p>
                    </div>
                    <div style="flex: 1; padding: 20px;">
                        <h4 style="color: #f39c12;">条件收敛</h4>
                        <p>Σaₙ 收敛，但 Σ|aₙ| 发散</p>
                        <p>重排可改变和</p>
                    </div>
                </div>
                <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                    <strong>例子：交错调和级数</strong><br>
                    1 - 1/2 + 1/3 - 1/4 + ... = ln(2) (条件收敛)<br>
                    但 1 + 1/2 + 1/3 + 1/4 + ... = ∞ (发散)
                </div>
            </div>
        `);
    }

    function visualizePowerSeries(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        
        const { g, width, height } = setup;
        
        // 显示 1/(1-x) = 1 + x + x² + x³ + ...
        const xScale = d3.scaleLinear().domain([-2, 2]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 5]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 绘制原函数 1/(1-x)
        const originalData = [];
        for (let x = -1.8; x <= 0.8; x += 0.1) {
            if (Math.abs(1 - x) > 0.1) {
                originalData.push({x: x, y: 1 / (1 - x)});
            }
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .defined(d => Math.abs(d.y) < 10);
        
        g.append('path')
            .datum(originalData)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('d', line);
        
        // 绘制级数逼近（前几项）
        const terms = [3, 5, 8];
        const colors = ['#3498db', '#2ecc71', '#f39c12'];
        
        terms.forEach((n, i) => {
            setTimeout(() => {
                const approxData = [];
                for (let x = -1.8; x <= 1.8; x += 0.1) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += Math.pow(x, k);
                    }
                    approxData.push({x: x, y: sum});
                }
                
                g.append('path')
                    .datum(approxData)
                    .attr('fill', 'none')
                    .attr('stroke', colors[i])
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '3,3')
                    .attr('d', line)
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 0.7);
                
                // 添加图例
                g.append('text')
                    .attr('x', 10)
                    .attr('y', 30 + i * 20)
                    .style('font-size', '12px')
                    .style('fill', colors[i])
                    .text(`前${n}项`)
                    .style('opacity', 0)
                    .transition()
                    .delay(300)
                    .duration(500)
                    .style('opacity', 1);
            }, i * 1000);
        });
        
        // 收敛区域标记
        g.append('rect')
            .attr('x', xScale(-1))
            .attr('y', 0)
            .attr('width', xScale(1) - xScale(-1))
            .attr('height', height)
            .attr('fill', 'lightblue')
            .attr('opacity', 0.1);
        
        g.append('text')
            .attr('x', xScale(0))
            .attr('y', height - 20)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .style('fill', '#3498db')
            .text('收敛区间: |x| < 1');
    }

    function visualizeTaylorSeries(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-2*Math.PI, 2*Math.PI]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 2]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 绘制 sin(x)
        const sinData = [];
        for (let x = -2*Math.PI; x <= 2*Math.PI; x += 0.1) {
            sinData.push({x: x, y: Math.sin(x)});
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(sinData)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('d', line);
        
        // 泰勒级数逼近
        function taylorSin(x, terms) {
            let sum = 0;
            for (let n = 0; n < terms; n++) {
                const coeff = Math.pow(-1, n) / factorial(2*n + 1);
                sum += coeff * Math.pow(x, 2*n + 1);
            }
            return sum;
        }
        
        function factorial(n) {
            return n <= 1 ? 1 : n * factorial(n - 1);
        }
        
        const termCounts = [1, 2, 3, 4];
        const colors = ['#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
        
        termCounts.forEach((terms, i) => {
            setTimeout(() => {
                const taylorData = [];
                for (let x = -2*Math.PI; x <= 2*Math.PI; x += 0.1) {
                    const y = taylorSin(x, terms);
                    if (Math.abs(y) < 10) {
                        taylorData.push({x: x, y: y});
                    }
                }
                
                g.append('path')
                    .datum(taylorData)
                    .attr('fill', 'none')
                    .attr('stroke', colors[i])
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '3,3')
                    .attr('d', line)
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 0.7);
                
                g.append('text')
                    .attr('x', 10)
                    .attr('y', 30 + i * 20)
                    .style('font-size', '12px')
                    .style('fill', colors[i])
                    .text(`${terms}项`)
                    .style('opacity', 0)
                    .transition()
                    .delay(300)
                    .duration(500)
                    .style('opacity', 1);
            }, i * 800);
        });
        
        // 标题
        g.append('text')
            .attr('x', width / 2)
            .attr('y', -10)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('sin(x) 的泰勒级数逼近');
    }

    function visualizeApplications(containerId) {
        const container = d3.select(`#${containerId}`);
        container.html(`
            <div style="text-align: center; padding: 20px; height: 100%; display: flex; flex-direction: column; justify-content: center;">
                <h2 style="margin-bottom: 30px; color: #2c3e50;">级数的实际应用</h2>
                
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; max-width: 800px; margin: 0 auto;">
                    <div style="background: #3498db; color: #1a1a2e; padding: 20px; border-radius: 10px;">
                        <h3>计算 π</h3>
                        <p>π/4 = 1 - 1/3 + 1/5 - 1/7 + ...</p>
                    </div>
                    
                    <div style="background: #2ecc71; color: #1a1a2e; padding: 20px; border-radius: 10px;">
                        <h3>计算 e</h3>
                        <p>e = 1 + 1/1! + 1/2! + 1/3! + ...</p>
                    </div>
                    
                    <div style="background: #e74c3c; color: #1a1a2e; padding: 20px; border-radius: 10px;">
                        <h3>信号处理</h3>
                        <p>傅里叶级数分解信号</p>
                    </div>
                    
                    <div style="background: #f39c12; color: #1a1a2e; padding: 20px; border-radius: 10px;">
                        <h3>数值计算</h3>
                        <p>用级数逼近复杂函数</p>
                    </div>
                </div>
                
                <div style="margin-top: 30px; font-size: 1.2rem; color: #7f8c8d;">
                    级数让我们能够用简单的加法运算处理复杂的数学问题！
                </div>
            
    <div class="nav-container">
        <button class="nav-btn" id="prev-btn" onclick="previousSlide()" title="上一页 (←)">上一页</button>
        <span id="page-indicator">1 / 15</span>
        <button class="nav-btn" id="next-btn" onclick="nextSlide()" title="下一页 (→)">下一页</button>
    </div>
</div>
        `);
    }

</script>

<!-- 翻页器组件 -->

</body>
</html>